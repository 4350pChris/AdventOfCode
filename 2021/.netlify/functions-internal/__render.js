var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var import_node_fs, import_node_path, import_node_worker_threads, import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_util, import_node_url, import_net, s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    init_shims();
    import_node_fs = __toModule(require("node:fs"));
    import_node_path = __toModule(require("node:path"));
    import_node_worker_threads = __toModule(require("node:worker_threads"));
    init_install_fetch();
    import_node_http = __toModule(require("node:http"));
    import_node_https = __toModule(require("node:https"));
    import_node_zlib = __toModule(require("node:zlib"));
    import_node_stream = __toModule(require("node:stream"));
    import_node_util = __toModule(require("node:util"));
    import_node_url = __toModule(require("node:url"));
    import_net = __toModule(require("net"));
    globalThis.DOMException || (() => {
      const port = new import_node_worker_threads.MessageChannel().port1;
      const ab = new ArrayBuffer(0);
      try {
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        return err.constructor;
      }
    })();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position2 = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position2 !== end) {
          const size = Math.min(end - position2, POOL_SIZE);
          const chunk = part.buffer.slice(position2, position2 + size);
          position2 += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position2 = 0;
      while (position2 !== part.size) {
        const chunk = part.slice(position2, Math.min(part.size, position2 + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position2 += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F2, B = Blob$1) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream2.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_net2.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const { parsedURL, options: options2 } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https2.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL, options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s3) => {
        let endedWithEventsCount;
        s3.prependListener("end", () => {
          endedWithEventsCount = s3._eventsCount;
        });
        s3.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s3._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib2.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib2.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createGunzip(zlibOptions), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflate(), reject) : (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflateRaw(), reject);
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createBrotliDecompress(), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var import_node_http2, import_node_https2, import_node_zlib2, import_node_stream2, import_node_util2, import_node_url2, import_net2, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob2, Blob$1, _File, File, t, i, h, r, m, f2, e, x, FormData, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_node_http2 = __toModule(require("node:http"));
    import_node_https2 = __toModule(require("node:https"));
    import_node_zlib2 = __toModule(require("node:zlib"));
    import_node_stream2 = __toModule(require("node:stream"));
    import_node_util2 = __toModule(require("node:util"));
    import_node_url2 = __toModule(require("node:url"));
    import_net2 = __toModule(require("net"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop4() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        const rethrowAssertionErrorRejection = noop4;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F2, V, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V, args);
        }
        function promiseCall(F2, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x2) {
          return typeof x2 === "number" && isFinite(x2);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x2) {
          return typeof x2 === "object" || typeof x2 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x2, context) {
          if (typeof x2 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        function assertObject(x2, context) {
          if (!isObject(x2)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x2, position2, context) {
          if (x2 === void 0) {
            throw new TypeError(`Parameter ${position2} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x2, field, context) {
          if (x2 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x2) {
          return x2 === 0 ? 0 : x2;
        }
        function integerPart(x2) {
          return censorNegativeZero(MathTrunc(x2));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x2 = Number(value);
          x2 = censorNegativeZero(x2);
          if (!NumberIsFinite(x2)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x2) || x2 === 0) {
            return 0;
          }
          return x2;
        }
        function assertReadableStream(x2, context) {
          if (!IsReadableStream(x2)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x2) {
          return x2 !== x2;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
            return false;
          }
          return x2 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              readIntoRequest._errorSteps(e2);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              throw e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e2) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x2, context) {
          if (!IsWritableStream(x2)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
            return false;
          }
          return x2 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e2 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e2);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop4);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e2) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable2 = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable2, "readable", "ReadableWritablePair");
          assertReadableStream(readable2, `${context} has member 'readable' that`);
          const writable3 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable3, "writable", "ReadableWritablePair");
          assertWritableStream(writable3, `${context} has member 'writable' that`);
          return { readable: readable2, writable: writable3 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform2 = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform2.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform2.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform2.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop4);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e2) {
          stream._state = "errored";
          stream._storedError = e2;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e2);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e2);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e2);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform2 = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform2 === void 0 ? void 0 : convertTransformerTransformCallback(transform2, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
            return false;
          }
          return x2 instanceof TransformStream;
        }
        function TransformStreamError(stream, e2) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
            return false;
          }
          return x2 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e2) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e2);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e2) {
          TransformStreamError(controller._controlledTransformStream, e2);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable3 = stream._writable;
              const state = writable3._state;
              if (state === "erroring") {
                throw writable3._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable2 = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable2._state === "errored") {
              throw readable2._storedError;
            }
            ReadableStreamDefaultControllerClose(readable2._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable2._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position2 = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position2, Math.min(blob.size, position2 + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position2 += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position2 === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options2 = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options2 !== "object" && typeof options2 !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options2 === null)
          options2 = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = encoder.encode(element);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        const type = options2.type === void 0 ? "" : String(options2.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    _File = class File2 extends Blob$1 {
      #lastModified = 0;
      #name = "";
      constructor(fileBits, fileName, options2 = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options2);
        if (options2 === null)
          options2 = {};
        const lastModified = options2.lastModified === void 0 ? Date.now() : Number(options2.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new File([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f2(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f2(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    };
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_node_util2.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream2.default)
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = import_node_stream2.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream2.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream2.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util2.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream2.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream2.PassThrough({ highWaterMark });
        p2 = new import_node_stream2.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util2.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_node_util2.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream2.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_node_http2.default.validateHeaderName === "function" ? import_node_http2.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http2.default.validateHeaderValue === "function" ? import_node_http2.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_node_util2.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_node_util2.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init2.referrer == null ? input.referrer : init2.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url2.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options2 = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options: options2
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/.pnpm/@sveltejs+adapter-netlify@1.0.0-next.36/node_modules/@sveltejs/adapter-netlify/files/shims.js
var init_shims = __esm({
  "node_modules/.pnpm/@sveltejs+adapter-netlify@1.0.0-next.36/node_modules/@sveltejs/adapter-netlify/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/chunks/url.js
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function resolve(base2, path) {
  if (scheme.test(path))
    return path;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
    const part = pathparts[i2];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path) {
  return path[0] === "/" && path[1] !== "/";
}
var absolute, scheme;
var init_url = __esm({
  "node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/chunks/url.js"() {
    init_shims();
    absolute = /^([a-z]+:)?\/?\//;
    scheme = /^[a-z]+:/;
  }
});

// node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/chunks/error.js
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var init_error = __esm({
  "node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/chunks/error.js"() {
    init_shims();
  }
});

// node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/ssr.js
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s3) {
  return typeof s3 === "string" || s3 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler2) {
    return;
  }
  const params = route.params(match);
  const response = await handler2({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i2) {
    names.set(entry[0], getName(i2));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i2) {
          return i2 in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i2) {
            statements_1.push(name + "[" + i2 + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i2 = 0; i2 < str.length; i2 += 1) {
    var char = str.charAt(i2);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i2];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop2() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function writable(value, start = noop2) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i2 = value.length;
  if (typeof value === "string") {
    while (i2)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
  } else {
    while (i2)
      hash2 = hash2 * 33 ^ value[--i2];
  }
  return (hash2 >>> 0).toString(36);
}
function escape_json_string_in_html(str) {
  return escape2(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
}
function escape_html_attr(str) {
  return '"' + escape2(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
}
function escape2(str, dict, unicode_encoder) {
  let result = "";
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    const char = str.charAt(i2);
    const code = char.charCodeAt(0);
    if (char in dict) {
      result += dict[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i2];
      } else {
        result += unicode_encoder(code);
      }
    } else {
      result += char;
    }
  }
  return result;
}
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page: page2
}) {
  const css4 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css4.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page: page2,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      props[`props_${i2}`] = await branch[i2].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css4).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
    init2 += options2.service_worker ? '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>' : "";
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page2 && page2.host ? s$1(page2.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page2 && page2.host ? s$1(page2.host) : "location.host"}, // TODO this is redundant
						path: ${page2 && page2.path ? try_serialize(page2.path, (error3) => {
      throw new Error(`Failed to serialize page.path: ${error3.message}`);
    }) : null},
						query: new URLSearchParams(${page2 && page2.query ? s$1(page2.query.toString()) : ""}),
						params: ${page2 && page2.params ? try_serialize(page2.params, (error3) => {
      throw new Error(`Failed to serialize page.params: ${error3.message}`);
    }) : null}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += options2.amp ? `<amp-install-serviceworker src="${options2.service_worker}" layout="nodisplay"></amp-install-serviceworker>` : `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url)}`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ ...error2, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
async function load_node({
  request,
  options: options2,
  state,
  route,
  page: page2,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page2, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const prefix = options2.paths.assets || options2.paths.base;
        const filename = (resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page2.host}/${asset.file}`, opts);
        } else if (is_root_relative(resolved)) {
          const relative = resolved;
          const headers = {
            ...opts.headers
          };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, _receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s2(response2.statusText)},"headers":${s2(headers)},"body":"${escape_json_string_in_html(body)}"}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: { ...stuff }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page: page2,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page: page2,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page: page2
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {}
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i2 = 0; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i2 === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e2 = coalesce_to_error(err);
            options2.handle_error(e2, request);
            status = 500;
            error2 = e2;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i2--) {
              if (route.b[i2]) {
                const error_node = await options2.load_component(route.b[i2]);
                let node_loaded;
                let j = i2;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e2 = coalesce_to_error(err);
                  options2.handle_error(e2, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = {
            ...stuff,
            ...loaded.loaded.stuff
          };
        }
      }
    }
  try {
    return with_cookies(await render_response({
      ...opts,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page: page2
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  };
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                let if_none_match_value = request2.headers["if-none-match"];
                if (if_none_match_value?.startsWith('W/"')) {
                  if_none_match_value = if_none_match_value.substring(2);
                }
                const etag = `"${hash(response.body || "")}"`;
                if (if_none_match_value === etag) {
                  return {
                    status: 304,
                    headers: {}
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e2 = coalesce_to_error(err);
    options2.handle_error(e2, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e2.stack : e2.message
    };
  }
}
var chars, unsafeChars, reserved, escaped, objectProtoOwnPropertyNames, subscriber_queue, escape_json_string_in_html_dict, escape_html_attr_dict, s$1, s2, ReadOnlyFormData;
var init_ssr = __esm({
  "node_modules/.pnpm/@sveltejs+kit@1.0.0-next.202_svelte@3.44.3/node_modules/@sveltejs/kit/dist/ssr.js"() {
    init_shims();
    init_url();
    init_error();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
    escaped = {
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    Promise.resolve();
    subscriber_queue = [];
    escape_json_string_in_html_dict = {
      '"': '\\"',
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    escape_html_attr_dict = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    s$1 = JSON.stringify;
    s2 = JSON.stringify;
    ReadOnlyFormData = class {
      #map;
      constructor(map) {
        this.#map = map;
      }
      get(key) {
        const value = this.#map.get(key);
        return value && value[0];
      }
      getAll(key) {
        return this.#map.get(key);
      }
      has(key) {
        return this.#map.has(key);
      }
      *[Symbol.iterator]() {
        for (const [key, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield [key, value[i2]];
          }
        }
      }
      *entries() {
        for (const [key, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield [key, value[i2]];
          }
        }
      }
      *keys() {
        for (const [key] of this.#map)
          yield key;
      }
      *values() {
        for (const [, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield value[i2];
          }
        }
      }
    };
  }
});

// .svelte-kit/output/server/chunks/index-3b04c25a.js
function readable(value, start) {
  return {
    subscribe: writable2(value, start).subscribe
  };
}
function writable2(value, start = noop3) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
            subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop3) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop3;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop3;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop3;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}
var subscriber_queue2;
var init_index_3b04c25a = __esm({
  ".svelte-kit/output/server/chunks/index-3b04c25a.js"() {
    init_shims();
    init_app_7566ed49();
    subscriber_queue2 = [];
  }
});

// .svelte-kit/output/server/chunks/__layout-0a3d2c91.js
var layout_0a3d2c91_exports = {};
__export(layout_0a3d2c91_exports, {
  default: () => _layout
});
var getStores, page, activeDay, css, _layout;
var init_layout_0a3d2c91 = __esm({
  ".svelte-kit/output/server/chunks/__layout-0a3d2c91.js"() {
    init_shims();
    init_app_7566ed49();
    init_index_3b04c25a();
    init_ssr();
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        page: {
          subscribe: stores.page.subscribe
        },
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        get preloading() {
          console.error("stores.preloading is deprecated; use stores.navigating instead");
          return {
            subscribe: stores.navigating.subscribe
          };
        },
        session: stores.session
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
    activeDay = derived(page, ({ path }) => {
      if (!path.startsWith("/days")) {
        return null;
      }
      const splitPath = path.split("/");
      return Number(splitPath[splitPath.length - 1]);
    });
    css = {
      code: "@tailwind base;@tailwind components;@tailwind utilities;",
      map: null
    };
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $activeDay, $$unsubscribe_activeDay;
      $$unsubscribe_activeDay = subscribe(activeDay, (value) => $activeDay = value);
      const days = Array.from(Array(25)).map((_, i2) => i2 + 1);
      $$result.css.add(css);
      $$unsubscribe_activeDay();
      return `<div class="${"rounded-lg shadow bg-base-200 drawer drawer-mobile"}"><input id="${"my-drawer-2"}" type="${"checkbox"}" class="${"drawer-toggle"}">
	<main class="${"flex flex-col p-4 md:p-8 lg:p-16 items-center overflow-x-hidden bg-base-100 text-base-content drawer-content"}"><label for="${"my-drawer-2"}" class="${"mb-4 btn btn-primary drawer-button lg:hidden"}">open menu</label>
		<a class="${"link text-lg"}"${add_attribute("href", `/input/${$activeDay}.txt`, 0)} target="${"_blank"}">Input</a>
		${slots.default ? slots.default({}) : ``}</main>
	<div class="${"drawer-side"}"><label for="${"my-drawer-2"}" class="${"drawer-overlay"}"></label>
		<aside class="${"flex flex-col justify-between border-r border-base-200 bg-base-100 text-base-content w-72"}"><div class="${"sticky top-0 bg-base-100"}"><a class="${"block text-xl text-center py-4 w-full link-primary"}" href="${"/"}">Advent Of Code 2021</a></div>
			<nav><ul class="${"menu p-4 overflow-y-auto bg-base-100 text-base-content"}">${each(days, (day) => `<li><a href="${"/days/" + escape3(day)}"${add_classes([$activeDay === day ? "active" : ""].join(" ").trim())}>Day ${escape3(day)}</a>
						</li>`)}</ul></nav></aside></div>
</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/error-0a901032.js
var error_0a901032_exports = {};
__export(error_0a901032_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error2;
var init_error_0a901032 = __esm({
  ".svelte-kit/output/server/chunks/error-0a901032.js"() {
    init_shims();
    init_app_7566ed49();
    init_ssr();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape3(status)}</h1>

<pre>${escape3(error2.message)}</pre>



${error2.frame ? `<pre>${escape3(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape3(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/index-f2eaf764.js
var index_f2eaf764_exports = {};
__export(index_f2eaf764_exports, {
  default: () => Routes
});
var Routes;
var init_index_f2eaf764 = __esm({
  ".svelte-kit/output/server/chunks/index-f2eaf764.js"() {
    init_shims();
    init_app_7566ed49();
    init_ssr();
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h1>My Advent Of Code project! Because overengineering is fun.</h1>
<p>Shoutout <a class="${"link-accent"}" href="${"https://adventofcode.com"}" target="${"_blank"}" rel="${"external noopener noreferrer nofollow"}">adventofcode.com</a> to read the documentation
</p>`;
    });
  }
});

// .svelte-kit/output/server/chunks/loadInput-5557da5b.js
var load2;
var init_loadInput_5557da5b = __esm({
  ".svelte-kit/output/server/chunks/loadInput-5557da5b.js"() {
    init_shims();
    load2 = async ({ page: page2, fetch: fetch2 }) => {
      const splitPath = page2.path.split("/");
      const day = Number(splitPath[splitPath.length - 1]);
      const url = `/input/${day}.txt`;
      const res = await fetch2(url);
      if (res.ok) {
        return {
          props: {
            input: await res.text()
          }
        };
      }
      return {
        status: res.status,
        error: new Error(`Could not load ${url}`)
      };
    };
  }
});

// .svelte-kit/output/server/chunks/1-91c066b6.js
var c066b6_exports = {};
__export(c066b6_exports, {
  default: () => _1,
  load: () => load2
});
function part1(lines) {
  const increases = [];
  const res = lines.reduce(([count, prev], current, i2) => {
    const increase = current > prev;
    if (increase) {
      increases.push(i2);
    }
    return [increase ? count + 1 : count, current];
  }, [0, Infinity]);
  return {
    lines,
    increases,
    result: res[0]
  };
}
function part2(lines) {
  const windows = [];
  for (const n of lines) {
    windows.push([n]);
    const wLen = windows.length - 1;
    if (windows[wLen - 1]) {
      windows[wLen - 1].push(n);
    }
    if (windows[wLen - 2]) {
      windows[wLen - 2].push(n);
    }
  }
  windows.splice(-2, 2);
  const sums = windows.flatMap((w) => w.reduce((acc, val) => acc + val, 0));
  return part1(sums);
}
var _1;
var init_c066b6 = __esm({
  ".svelte-kit/output/server/chunks/1-91c066b6.js"() {
    init_shims();
    init_app_7566ed49();
    init_loadInput_5557da5b();
    init_ssr();
    _1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { input } = $$props;
      const lines = input?.split("\n").map((n) => Number(n));
      const p1 = part1(lines);
      const p2 = part2(lines);
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      return `<h3 class="${"text-6xl"}">Sonar</h3>
${each([p1, p2], (part, i2) => `<section class="${"space-y-4 mt-4"}"><h4 class="${"text-2xl font-bold"}">Part ${escape3(i2 + 1)}</h4>
		<p class="${"font-bold"}">Total increases
			<code>${escape3(part.result)}</code></p>
		<p>Input</p>
		<code class="${"block px-4 py-2 bg-base-200 columns-2 md:columns-4 lg:columns-6"}">${each(part.lines, (line, i22) => `${escape3(line)}
				${part.increases.includes(i22) ? `Increase` : ``}
				<br>`)}</code>
	</section>`)}`;
    });
  }
});

// node_modules/.pnpm/three@0.135.0/node_modules/three/build/three.js
var require_three = __commonJS({
  "node_modules/.pnpm/three@0.135.0/node_modules/three/build/three.js"(exports, module2) {
    init_shims();
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.THREE = {}));
    })(exports, function(exports2) {
      "use strict";
      const REVISION = "135";
      const MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      };
      const TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      };
      const CullFaceNone = 0;
      const CullFaceBack = 1;
      const CullFaceFront = 2;
      const CullFaceFrontBack = 3;
      const BasicShadowMap = 0;
      const PCFShadowMap2 = 1;
      const PCFSoftShadowMap = 2;
      const VSMShadowMap = 3;
      const FrontSide = 0;
      const BackSide = 1;
      const DoubleSide = 2;
      const FlatShading = 1;
      const SmoothShading = 2;
      const NoBlending = 0;
      const NormalBlending = 1;
      const AdditiveBlending = 2;
      const SubtractiveBlending = 3;
      const MultiplyBlending = 4;
      const CustomBlending = 5;
      const AddEquation = 100;
      const SubtractEquation = 101;
      const ReverseSubtractEquation = 102;
      const MinEquation = 103;
      const MaxEquation = 104;
      const ZeroFactor = 200;
      const OneFactor = 201;
      const SrcColorFactor = 202;
      const OneMinusSrcColorFactor = 203;
      const SrcAlphaFactor = 204;
      const OneMinusSrcAlphaFactor = 205;
      const DstAlphaFactor = 206;
      const OneMinusDstAlphaFactor = 207;
      const DstColorFactor = 208;
      const OneMinusDstColorFactor = 209;
      const SrcAlphaSaturateFactor = 210;
      const NeverDepth = 0;
      const AlwaysDepth = 1;
      const LessDepth = 2;
      const LessEqualDepth = 3;
      const EqualDepth = 4;
      const GreaterEqualDepth = 5;
      const GreaterDepth = 6;
      const NotEqualDepth = 7;
      const MultiplyOperation = 0;
      const MixOperation = 1;
      const AddOperation = 2;
      const NoToneMapping2 = 0;
      const LinearToneMapping = 1;
      const ReinhardToneMapping = 2;
      const CineonToneMapping = 3;
      const ACESFilmicToneMapping = 4;
      const CustomToneMapping = 5;
      const UVMapping = 300;
      const CubeReflectionMapping = 301;
      const CubeRefractionMapping = 302;
      const EquirectangularReflectionMapping = 303;
      const EquirectangularRefractionMapping = 304;
      const CubeUVReflectionMapping = 306;
      const CubeUVRefractionMapping = 307;
      const RepeatWrapping = 1e3;
      const ClampToEdgeWrapping = 1001;
      const MirroredRepeatWrapping = 1002;
      const NearestFilter = 1003;
      const NearestMipmapNearestFilter = 1004;
      const NearestMipMapNearestFilter = 1004;
      const NearestMipmapLinearFilter = 1005;
      const NearestMipMapLinearFilter = 1005;
      const LinearFilter = 1006;
      const LinearMipmapNearestFilter = 1007;
      const LinearMipMapNearestFilter = 1007;
      const LinearMipmapLinearFilter = 1008;
      const LinearMipMapLinearFilter = 1008;
      const UnsignedByteType = 1009;
      const ByteType = 1010;
      const ShortType = 1011;
      const UnsignedShortType = 1012;
      const IntType = 1013;
      const UnsignedIntType = 1014;
      const FloatType = 1015;
      const HalfFloatType = 1016;
      const UnsignedShort4444Type = 1017;
      const UnsignedShort5551Type = 1018;
      const UnsignedShort565Type = 1019;
      const UnsignedInt248Type = 1020;
      const AlphaFormat = 1021;
      const RGBFormat = 1022;
      const RGBAFormat = 1023;
      const LuminanceFormat = 1024;
      const LuminanceAlphaFormat = 1025;
      const RGBEFormat = RGBAFormat;
      const DepthFormat = 1026;
      const DepthStencilFormat = 1027;
      const RedFormat = 1028;
      const RedIntegerFormat = 1029;
      const RGFormat = 1030;
      const RGIntegerFormat = 1031;
      const RGBIntegerFormat = 1032;
      const RGBAIntegerFormat = 1033;
      const RGB_S3TC_DXT1_Format = 33776;
      const RGBA_S3TC_DXT1_Format = 33777;
      const RGBA_S3TC_DXT3_Format = 33778;
      const RGBA_S3TC_DXT5_Format = 33779;
      const RGB_PVRTC_4BPPV1_Format = 35840;
      const RGB_PVRTC_2BPPV1_Format = 35841;
      const RGBA_PVRTC_4BPPV1_Format = 35842;
      const RGBA_PVRTC_2BPPV1_Format = 35843;
      const RGB_ETC1_Format = 36196;
      const RGB_ETC2_Format = 37492;
      const RGBA_ETC2_EAC_Format = 37496;
      const RGBA_ASTC_4x4_Format = 37808;
      const RGBA_ASTC_5x4_Format = 37809;
      const RGBA_ASTC_5x5_Format = 37810;
      const RGBA_ASTC_6x5_Format = 37811;
      const RGBA_ASTC_6x6_Format = 37812;
      const RGBA_ASTC_8x5_Format = 37813;
      const RGBA_ASTC_8x6_Format = 37814;
      const RGBA_ASTC_8x8_Format = 37815;
      const RGBA_ASTC_10x5_Format = 37816;
      const RGBA_ASTC_10x6_Format = 37817;
      const RGBA_ASTC_10x8_Format = 37818;
      const RGBA_ASTC_10x10_Format = 37819;
      const RGBA_ASTC_12x10_Format = 37820;
      const RGBA_ASTC_12x12_Format = 37821;
      const RGBA_BPTC_Format = 36492;
      const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
      const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
      const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
      const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
      const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
      const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
      const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
      const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
      const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
      const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
      const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
      const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
      const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
      const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
      const LoopOnce = 2200;
      const LoopRepeat = 2201;
      const LoopPingPong = 2202;
      const InterpolateDiscrete = 2300;
      const InterpolateLinear = 2301;
      const InterpolateSmooth = 2302;
      const ZeroCurvatureEnding = 2400;
      const ZeroSlopeEnding = 2401;
      const WrapAroundEnding = 2402;
      const NormalAnimationBlendMode = 2500;
      const AdditiveAnimationBlendMode = 2501;
      const TrianglesDrawMode = 0;
      const TriangleStripDrawMode = 1;
      const TriangleFanDrawMode = 2;
      const LinearEncoding = 3e3;
      const sRGBEncoding = 3001;
      const GammaEncoding = 3007;
      const RGBEEncoding = 3002;
      const RGBM7Encoding = 3004;
      const RGBM16Encoding = 3005;
      const RGBDEncoding = 3006;
      const BasicDepthPacking = 3200;
      const RGBADepthPacking = 3201;
      const TangentSpaceNormalMap = 0;
      const ObjectSpaceNormalMap = 1;
      const ZeroStencilOp = 0;
      const KeepStencilOp = 7680;
      const ReplaceStencilOp = 7681;
      const IncrementStencilOp = 7682;
      const DecrementStencilOp = 7683;
      const IncrementWrapStencilOp = 34055;
      const DecrementWrapStencilOp = 34056;
      const InvertStencilOp = 5386;
      const NeverStencilFunc = 512;
      const LessStencilFunc = 513;
      const EqualStencilFunc = 514;
      const LessEqualStencilFunc = 515;
      const GreaterStencilFunc = 516;
      const NotEqualStencilFunc = 517;
      const GreaterEqualStencilFunc = 518;
      const AlwaysStencilFunc = 519;
      const StaticDrawUsage = 35044;
      const DynamicDrawUsage = 35048;
      const StreamDrawUsage = 35040;
      const StaticReadUsage = 35045;
      const DynamicReadUsage = 35049;
      const StreamReadUsage = 35041;
      const StaticCopyUsage = 35046;
      const DynamicCopyUsage = 35050;
      const StreamCopyUsage = 35042;
      const GLSL1 = "100";
      const GLSL3 = "300 es";
      class EventDispatcher {
        addEventListener(type, listener) {
          if (this._listeners === void 0)
            this._listeners = {};
          const listeners = this._listeners;
          if (listeners[type] === void 0) {
            listeners[type] = [];
          }
          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }
        }
        hasEventListener(type, listener) {
          if (this._listeners === void 0)
            return false;
          const listeners = this._listeners;
          return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[type];
          if (listenerArray !== void 0) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
              listenerArray.splice(index, 1);
            }
          }
        }
        dispatchEvent(event) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[event.type];
          if (listenerArray !== void 0) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i2 = 0, l = array.length; i2 < l; i2++) {
              array[i2].call(this, event);
            }
            event.target = null;
          }
        }
      }
      const _lut = [];
      for (let i2 = 0; i2 < 256; i2++) {
        _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
      }
      let _seed = 1234567;
      const DEG2RAD = Math.PI / 180;
      const RAD2DEG = 180 / Math.PI;
      function generateUUID() {
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        return uuid.toUpperCase();
      }
      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function euclideanModulo(n, m2) {
        return (n % m2 + m2) % m2;
      }
      function mapLinear(x2, a1, a2, b1, b2) {
        return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
      }
      function inverseLerp(x2, y, value) {
        if (x2 !== y) {
          return (value - x2) / (y - x2);
        } else {
          return 0;
        }
      }
      function lerp(x2, y, t2) {
        return (1 - t2) * x2 + t2 * y;
      }
      function damp(x2, y, lambda, dt) {
        return lerp(x2, y, 1 - Math.exp(-lambda * dt));
      }
      function pingpong(x2, length = 1) {
        return length - Math.abs(euclideanModulo(x2, length * 2) - length);
      }
      function smoothstep(x2, min, max) {
        if (x2 <= min)
          return 0;
        if (x2 >= max)
          return 1;
        x2 = (x2 - min) / (max - min);
        return x2 * x2 * (3 - 2 * x2);
      }
      function smootherstep(x2, min, max) {
        if (x2 <= min)
          return 0;
        if (x2 >= max)
          return 1;
        x2 = (x2 - min) / (max - min);
        return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
      }
      function randInt(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      }
      function randFloat(low, high) {
        return low + Math.random() * (high - low);
      }
      function randFloatSpread(range) {
        return range * (0.5 - Math.random());
      }
      function seededRandom(s3) {
        if (s3 !== void 0)
          _seed = s3 % 2147483647;
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
      }
      function degToRad(degrees) {
        return degrees * DEG2RAD;
      }
      function radToDeg(radians) {
        return radians * RAD2DEG;
      }
      function isPowerOfTwo(value) {
        return (value & value - 1) === 0 && value !== 0;
      }
      function ceilPowerOfTwo(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
      }
      function floorPowerOfTwo(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
      }
      function setQuaternionFromProperEuler(q, a, b, c, order) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s22 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch (order) {
          case "XYX":
            q.set(c2 * s13, s22 * c1_3, s22 * s1_3, c2 * c13);
            break;
          case "YZY":
            q.set(s22 * s1_3, c2 * s13, s22 * c1_3, c2 * c13);
            break;
          case "ZXZ":
            q.set(s22 * c1_3, s22 * s1_3, c2 * s13, c2 * c13);
            break;
          case "XZX":
            q.set(c2 * s13, s22 * s3_1, s22 * c3_1, c2 * c13);
            break;
          case "YXY":
            q.set(s22 * c3_1, c2 * s13, s22 * s3_1, c2 * c13);
            break;
          case "ZYZ":
            q.set(s22 * s3_1, s22 * c3_1, c2 * s13, c2 * c13);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
        }
      }
      var MathUtils = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        DEG2RAD,
        RAD2DEG,
        generateUUID,
        clamp,
        euclideanModulo,
        mapLinear,
        inverseLerp,
        lerp,
        damp,
        pingpong,
        smoothstep,
        smootherstep,
        randInt,
        randFloat,
        randFloatSpread,
        seededRandom,
        degToRad,
        radToDeg,
        isPowerOfTwo,
        ceilPowerOfTwo,
        floorPowerOfTwo,
        setQuaternionFromProperEuler
      });
      class Vector2 {
        constructor(x2 = 0, y = 0) {
          this.x = x2;
          this.y = y;
        }
        get width() {
          return this.x;
        }
        set width(value) {
          this.x = value;
        }
        get height() {
          return this.y;
        }
        set height(value) {
          this.y = value;
        }
        set(x2, y) {
          this.x = x2;
          this.y = y;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          return this;
        }
        setX(x2) {
          this.x = x2;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          return this;
        }
        addScalar(s3) {
          this.x += s3;
          this.y += s3;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          return this;
        }
        addScaledVector(v, s3) {
          this.x += v.x * s3;
          this.y += v.y * s3;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          return this;
        }
        subScalar(s3) {
          this.x -= s3;
          this.y -= s3;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m2) {
          const x2 = this.x, y = this.y;
          const e2 = m2.elements;
          this.x = e2[0] * x2 + e2[3] * y + e2[6];
          this.y = e2[1] * x2 + e2[4] * y + e2[7];
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y;
        }
        cross(v) {
          return this.x * v.y - this.y * v.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const angle = Math.atan2(-this.y, -this.x) + Math.PI;
          return angle;
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y;
          return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          return this;
        }
        rotateAround(center, angle) {
          const c = Math.cos(angle), s3 = Math.sin(angle);
          const x2 = this.x - center.x;
          const y = this.y - center.y;
          this.x = x2 * c - y * s3 + center.x;
          this.y = x2 * s3 + y * c + center.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
        }
      }
      Vector2.prototype.isVector2 = true;
      class Matrix32 {
        constructor() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          const te = this.elements;
          te[0] = n11;
          te[1] = n21;
          te[2] = n31;
          te[3] = n12;
          te[4] = n22;
          te[5] = n32;
          te[6] = n13;
          te[7] = n23;
          te[8] = n33;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
          return this;
        }
        copy(m2) {
          const te = this.elements;
          const me = m2.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(m2) {
          const me = m2.elements;
          this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
          return this;
        }
        multiply(m2) {
          return this.multiplyMatrices(this, m2);
        }
        premultiply(m2) {
          return this.multiplyMatrices(m2, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[3], a13 = ae[6];
          const a21 = ae[1], a22 = ae[4], a23 = ae[7];
          const a31 = ae[2], a32 = ae[5], a33 = ae[8];
          const b11 = be[0], b12 = be[3], b13 = be[6];
          const b21 = be[1], b22 = be[4], b23 = be[7];
          const b31 = be[2], b32 = be[5], b33 = be[8];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te[6] = a11 * b13 + a12 * b23 + a13 * b33;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te[7] = a21 * b13 + a22 * b23 + a23 * b33;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te[8] = a31 * b13 + a32 * b23 + a33 * b33;
          return this;
        }
        multiplyScalar(s3) {
          const te = this.elements;
          te[0] *= s3;
          te[3] *= s3;
          te[6] *= s3;
          te[1] *= s3;
          te[4] *= s3;
          te[7] *= s3;
          te[2] *= s3;
          te[5] *= s3;
          te[8] *= s3;
          return this;
        }
        determinant() {
          const te = this.elements;
          const a = te[0], b = te[1], c = te[2], d = te[3], e2 = te[4], f3 = te[5], g = te[6], h2 = te[7], i2 = te[8];
          return a * e2 * i2 - a * f3 * h2 - b * d * i2 + b * f3 * g + c * d * h2 - c * e2 * g;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n31 * n23 - n33 * n21) * detInv;
          te[2] = (n32 * n21 - n31 * n22) * detInv;
          te[3] = t12 * detInv;
          te[4] = (n33 * n11 - n31 * n13) * detInv;
          te[5] = (n31 * n12 - n32 * n11) * detInv;
          te[6] = t13 * detInv;
          te[7] = (n21 * n13 - n23 * n11) * detInv;
          te[8] = (n22 * n11 - n21 * n12) * detInv;
          return this;
        }
        transpose() {
          let tmp2;
          const m2 = this.elements;
          tmp2 = m2[1];
          m2[1] = m2[3];
          m2[3] = tmp2;
          tmp2 = m2[2];
          m2[2] = m2[6];
          m2[6] = tmp2;
          tmp2 = m2[5];
          m2[5] = m2[7];
          m2[7] = tmp2;
          return this;
        }
        getNormalMatrix(matrix4) {
          return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r2) {
          const m2 = this.elements;
          r2[0] = m2[0];
          r2[1] = m2[3];
          r2[2] = m2[6];
          r2[3] = m2[1];
          r2[4] = m2[4];
          r2[5] = m2[7];
          r2[6] = m2[2];
          r2[7] = m2[5];
          r2[8] = m2[8];
          return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation2, cx, cy) {
          const c = Math.cos(rotation2);
          const s3 = Math.sin(rotation2);
          this.set(sx * c, sx * s3, -sx * (c * cx + s3 * cy) + cx + tx, -sy * s3, sy * c, -sy * (-s3 * cx + c * cy) + cy + ty, 0, 0, 1);
          return this;
        }
        scale(sx, sy) {
          const te = this.elements;
          te[0] *= sx;
          te[3] *= sx;
          te[6] *= sx;
          te[1] *= sy;
          te[4] *= sy;
          te[7] *= sy;
          return this;
        }
        rotate(theta) {
          const c = Math.cos(theta);
          const s3 = Math.sin(theta);
          const te = this.elements;
          const a11 = te[0], a12 = te[3], a13 = te[6];
          const a21 = te[1], a22 = te[4], a23 = te[7];
          te[0] = c * a11 + s3 * a21;
          te[3] = c * a12 + s3 * a22;
          te[6] = c * a13 + s3 * a23;
          te[1] = -s3 * a11 + c * a21;
          te[4] = -s3 * a12 + c * a22;
          te[7] = -s3 * a13 + c * a23;
          return this;
        }
        translate(tx, ty) {
          const te = this.elements;
          te[0] += tx * te[2];
          te[3] += tx * te[5];
          te[6] += tx * te[8];
          te[1] += ty * te[2];
          te[4] += ty * te[5];
          te[7] += ty * te[8];
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i2 = 0; i2 < 9; i2++) {
            if (te[i2] !== me[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          return array;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      Matrix32.prototype.isMatrix3 = true;
      function arrayMax(array) {
        if (array.length === 0)
          return -Infinity;
        let max = array[0];
        for (let i2 = 1, l = array.length; i2 < l; ++i2) {
          if (array[i2] > max)
            max = array[i2];
        }
        return max;
      }
      const TYPED_ARRAYS = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      };
      function getTypedArray(type, buffer) {
        return new TYPED_ARRAYS[type](buffer);
      }
      function createElementNS(name) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", name);
      }
      function hashString(str, seed = 0) {
        let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
        for (let i2 = 0, ch; i2 < str.length; i2++) {
          ch = str.charCodeAt(i2);
          h1 = Math.imul(h1 ^ ch, 2654435761);
          h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
        h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
      }
      let _canvas;
      class ImageUtils {
        static getDataURL(image) {
          if (/^data:/i.test(image.src)) {
            return image.src;
          }
          if (typeof HTMLCanvasElement == "undefined") {
            return image.src;
          }
          let canvas;
          if (image instanceof HTMLCanvasElement) {
            canvas = image;
          } else {
            if (_canvas === void 0)
              _canvas = createElementNS("canvas");
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext("2d");
            if (image instanceof ImageData) {
              context.putImageData(image, 0, 0);
            } else {
              context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas = _canvas;
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas.toDataURL("image/jpeg", 0.6);
          } else {
            return canvas.toDataURL("image/png");
          }
        }
      }
      let textureId = 0;
      class Texture extends EventDispatcher {
        constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format2 = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
          super();
          Object.defineProperty(this, "id", {
            value: textureId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.image = image;
          this.mipmaps = [];
          this.mapping = mapping;
          this.wrapS = wrapS;
          this.wrapT = wrapT;
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.anisotropy = anisotropy;
          this.format = format2;
          this.internalFormat = null;
          this.type = type;
          this.offset = new Vector2(0, 0);
          this.repeat = new Vector2(1, 1);
          this.center = new Vector2(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Matrix32();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          this.encoding = encoding;
          this.userData = {};
          this.version = 0;
          this.onUpdate = null;
          this.isRenderTargetTexture = false;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.image = source.image;
          this.mipmaps = source.mipmaps.slice(0);
          this.mapping = source.mapping;
          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;
          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;
          this.anisotropy = source.anisotropy;
          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;
          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);
          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.encoding = source.encoding;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.textures[this.uuid] !== void 0) {
            return meta.textures[this.uuid];
          }
          const output = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (this.image !== void 0) {
            const image = this.image;
            if (image.uuid === void 0) {
              image.uuid = generateUUID();
            }
            if (!isRootObject && meta.images[image.uuid] === void 0) {
              let url;
              if (Array.isArray(image)) {
                url = [];
                for (let i2 = 0, l = image.length; i2 < l; i2++) {
                  if (image[i2].isDataTexture) {
                    url.push(serializeImage(image[i2].image));
                  } else {
                    url.push(serializeImage(image[i2]));
                  }
                }
              } else {
                url = serializeImage(image);
              }
              meta.images[image.uuid] = {
                uuid: image.uuid,
                url
              };
            }
            output.image = image.uuid;
          }
          if (JSON.stringify(this.userData) !== "{}")
            output.userData = this.userData;
          if (!isRootObject) {
            meta.textures[this.uuid] = output;
          }
          return output;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(uv) {
          if (this.mapping !== UVMapping)
            return uv;
          uv.applyMatrix3(this.matrix);
          if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
              case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
              case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                  uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                  uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
          }
          if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
              case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
              case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                  uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                  uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
          }
          if (this.flipY) {
            uv.y = 1 - uv.y;
          }
          return uv;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      }
      Texture.DEFAULT_IMAGE = void 0;
      Texture.DEFAULT_MAPPING = UVMapping;
      Texture.prototype.isTexture = true;
      function serializeImage(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          return ImageUtils.getDataURL(image);
        } else {
          if (image.data) {
            return {
              data: Array.prototype.slice.call(image.data),
              width: image.width,
              height: image.height,
              type: image.data.constructor.name
            };
          } else {
            console.warn("THREE.Texture: Unable to serialize Texture.");
            return {};
          }
        }
      }
      class Vector4 {
        constructor(x2 = 0, y = 0, z = 0, w = 1) {
          this.x = x2;
          this.y = y;
          this.z = z;
          this.w = w;
        }
        get width() {
          return this.z;
        }
        set width(value) {
          this.z = value;
        }
        get height() {
          return this.w;
        }
        set height(value) {
          this.w = value;
        }
        set(x2, y, z, w) {
          this.x = x2;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;
          return this;
        }
        setX(x2) {
          this.x = x2;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setW(w) {
          this.w = w;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            case 3:
              this.w = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          this.w = v.w !== void 0 ? v.w : 1;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          this.w += v.w;
          return this;
        }
        addScalar(s3) {
          this.x += s3;
          this.y += s3;
          this.z += s3;
          this.w += s3;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          this.w = a.w + b.w;
          return this;
        }
        addScaledVector(v, s3) {
          this.x += v.x * s3;
          this.y += v.y * s3;
          this.z += v.z * s3;
          this.w += v.w * s3;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          this.w -= v.w;
          return this;
        }
        subScalar(s3) {
          this.x -= s3;
          this.y -= s3;
          this.z -= s3;
          this.w -= s3;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          this.w = a.w - b.w;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          this.w *= v.w;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        applyMatrix4(m2) {
          const x2 = this.x, y = this.y, z = this.z, w = this.w;
          const e2 = m2.elements;
          this.x = e2[0] * x2 + e2[4] * y + e2[8] * z + e2[12] * w;
          this.y = e2[1] * x2 + e2[5] * y + e2[9] * z + e2[13] * w;
          this.z = e2[2] * x2 + e2[6] * y + e2[10] * z + e2[14] * w;
          this.w = e2[3] * x2 + e2[7] * y + e2[11] * z + e2[15] * w;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q) {
          this.w = 2 * Math.acos(q.w);
          const s3 = Math.sqrt(1 - q.w * q.w);
          if (s3 < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = q.x / s3;
            this.y = q.y / s3;
            this.z = q.z / s3;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(m2) {
          let angle, x2, y, z;
          const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
          if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
              this.set(1, 0, 0, 0);
              return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
              if (xx < epsilon) {
                x2 = 0;
                y = 0.707106781;
                z = 0.707106781;
              } else {
                x2 = Math.sqrt(xx);
                y = xy / x2;
                z = xz / x2;
              }
            } else if (yy > zz) {
              if (yy < epsilon) {
                x2 = 0.707106781;
                y = 0;
                z = 0.707106781;
              } else {
                y = Math.sqrt(yy);
                x2 = xy / y;
                z = yz / y;
              }
            } else {
              if (zz < epsilon) {
                x2 = 0.707106781;
                y = 0.707106781;
                z = 0;
              } else {
                z = Math.sqrt(zz);
                x2 = xz / z;
                y = yz / z;
              }
            }
            this.set(x2, y, z, angle);
            return this;
          }
          let s3 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
          if (Math.abs(s3) < 1e-3)
            s3 = 1;
          this.x = (m32 - m23) / s3;
          this.y = (m13 - m31) / s3;
          this.z = (m21 - m12) / s3;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          this.w = Math.min(this.w, v.w);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          this.w = Math.max(this.w, v.w);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          this.w = Math.max(min.w, Math.min(max.w, this.w));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          this.w += (v.w - this.w) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          this.w = v1.w + (v2.w - v1.w) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          this.w = attribute.getW(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
          yield this.w;
        }
      }
      Vector4.prototype.isVector4 = true;
      class WebGLRenderTarget extends EventDispatcher {
        constructor(width, height, options2 = {}) {
          super();
          this.width = width;
          this.height = height;
          this.depth = 1;
          this.scissor = new Vector4(0, 0, width, height);
          this.scissorTest = false;
          this.viewport = new Vector4(0, 0, width, height);
          this.texture = new Texture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.image = {
            width,
            height,
            depth: 1
          };
          this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
          this.texture.internalFormat = options2.internalFormat !== void 0 ? options2.internalFormat : null;
          this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
          this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
          this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : false;
          this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
        }
        setTexture(texture) {
          texture.image = {
            width: this.width,
            height: this.height,
            depth: this.depth
          };
          this.texture = texture;
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.copy(source.viewport);
          this.texture = source.texture.clone();
          this.texture.image = {
            ...this.texture.image
          };
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
      class WebGLMultipleRenderTargets extends WebGLRenderTarget {
        constructor(width, height, count) {
          super(width, height);
          const texture = this.texture;
          this.texture = [];
          for (let i2 = 0; i2 < count; i2++) {
            this.texture[i2] = texture.clone();
          }
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
              this.texture[i2].image.width = width;
              this.texture[i2].image.height = height;
              this.texture[i2].image.depth = depth;
            }
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
          return this;
        }
        copy(source) {
          this.dispose();
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.set(0, 0, this.width, this.height);
          this.scissor.set(0, 0, this.width, this.height);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          this.texture.length = 0;
          for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
            this.texture[i2] = source.texture[i2].clone();
          }
          return this;
        }
      }
      WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
      class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
        constructor(width, height, options2 = {}) {
          super(width, height, options2);
          this.samples = 4;
          this.ignoreDepthForMultisampleCopy = options2.ignoreDepth !== void 0 ? options2.ignoreDepth : true;
          this.useRenderToTexture = options2.useRenderToTexture !== void 0 ? options2.useRenderToTexture : false;
          this.useRenderbuffer = this.useRenderToTexture === false;
        }
        copy(source) {
          super.copy.call(this, source);
          this.samples = source.samples;
          this.useRenderToTexture = source.useRenderToTexture;
          this.useRenderbuffer = source.useRenderbuffer;
          return this;
        }
      }
      WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
      class Quaternion {
        constructor(x2 = 0, y = 0, z = 0, w = 1) {
          this._x = x2;
          this._y = y;
          this._z = z;
          this._w = w;
        }
        static slerp(qa, qb, qm, t2) {
          console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
          return qm.slerpQuaternions(qa, qb, t2);
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
          let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
          if (t2 === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
          }
          if (t2 === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
          }
          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s3 = 1 - t2;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
              const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
              s3 = Math.sin(s3 * len) / sin;
              t2 = Math.sin(t2 * len) / sin;
            }
            const tDir = t2 * dir;
            x0 = x0 * s3 + x1 * tDir;
            y0 = y0 * s3 + y1 * tDir;
            z0 = z0 * s3 + z1 * tDir;
            w0 = w0 * s3 + w1 * tDir;
            if (s3 === 1 - t2) {
              const f3 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
              x0 *= f3;
              y0 *= f3;
              z0 *= f3;
              w0 *= f3;
            }
          }
          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];
          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
          return dst;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(value) {
          this._w = value;
          this._onChangeCallback();
        }
        set(x2, y, z, w) {
          this._x = x2;
          this._y = y;
          this._z = z;
          this._w = w;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(euler, update) {
          if (!(euler && euler.isEuler)) {
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;
          const cos = Math.cos;
          const sin = Math.sin;
          const c1 = cos(x2 / 2);
          const c2 = cos(y / 2);
          const c3 = cos(z / 2);
          const s1 = sin(x2 / 2);
          const s22 = sin(y / 2);
          const s3 = sin(z / 2);
          switch (order) {
            case "XYZ":
              this._x = s1 * c2 * c3 + c1 * s22 * s3;
              this._y = c1 * s22 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s22 * c3;
              this._w = c1 * c2 * c3 - s1 * s22 * s3;
              break;
            case "YXZ":
              this._x = s1 * c2 * c3 + c1 * s22 * s3;
              this._y = c1 * s22 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s22 * c3;
              this._w = c1 * c2 * c3 + s1 * s22 * s3;
              break;
            case "ZXY":
              this._x = s1 * c2 * c3 - c1 * s22 * s3;
              this._y = c1 * s22 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s22 * c3;
              this._w = c1 * c2 * c3 - s1 * s22 * s3;
              break;
            case "ZYX":
              this._x = s1 * c2 * c3 - c1 * s22 * s3;
              this._y = c1 * s22 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s22 * c3;
              this._w = c1 * c2 * c3 + s1 * s22 * s3;
              break;
            case "YZX":
              this._x = s1 * c2 * c3 + c1 * s22 * s3;
              this._y = c1 * s22 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s22 * c3;
              this._w = c1 * c2 * c3 - s1 * s22 * s3;
              break;
            case "XZY":
              this._x = s1 * c2 * c3 - c1 * s22 * s3;
              this._y = c1 * s22 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s22 * c3;
              this._w = c1 * c2 * c3 + s1 * s22 * s3;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
          }
          if (update !== false)
            this._onChangeCallback();
          return this;
        }
        setFromAxisAngle(axis, angle) {
          const halfAngle = angle / 2, s3 = Math.sin(halfAngle);
          this._x = axis.x * s3;
          this._y = axis.y * s3;
          this._z = axis.z * s3;
          this._w = Math.cos(halfAngle);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m2) {
          const te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
          if (trace > 0) {
            const s3 = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s3;
            this._x = (m32 - m23) * s3;
            this._y = (m13 - m31) * s3;
            this._z = (m21 - m12) * s3;
          } else if (m11 > m22 && m11 > m33) {
            const s3 = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s3;
            this._x = 0.25 * s3;
            this._y = (m12 + m21) / s3;
            this._z = (m13 + m31) / s3;
          } else if (m22 > m33) {
            const s3 = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s3;
            this._x = (m12 + m21) / s3;
            this._y = 0.25 * s3;
            this._z = (m23 + m32) / s3;
          } else {
            const s3 = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s3;
            this._x = (m13 + m31) / s3;
            this._y = (m23 + m32) / s3;
            this._z = 0.25 * s3;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(vFrom, vTo) {
          let r2 = vFrom.dot(vTo) + 1;
          if (r2 < Number.EPSILON) {
            r2 = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              this._x = -vFrom.y;
              this._y = vFrom.x;
              this._z = 0;
              this._w = r2;
            } else {
              this._x = 0;
              this._y = -vFrom.z;
              this._z = vFrom.y;
              this._w = r2;
            }
          } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r2;
          }
          return this.normalize();
        }
        angleTo(q) {
          return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
        }
        rotateTowards(q, step) {
          const angle = this.angleTo(q);
          if (angle === 0)
            return this;
          const t2 = Math.min(1, step / angle);
          this.slerp(q, t2);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(v) {
          return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let l = this.length();
          if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(q, p) {
          if (p !== void 0) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p);
          }
          return this.multiplyQuaternions(this, q);
        }
        premultiply(q) {
          return this.multiplyQuaternions(q, this);
        }
        multiplyQuaternions(a, b) {
          const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
          const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          this._onChangeCallback();
          return this;
        }
        slerp(qb, t2) {
          if (t2 === 0)
            return this;
          if (t2 === 1)
            return this.copy(qb);
          const x2 = this._x, y = this._y, z = this._z, w = this._w;
          let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;
          if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x2;
            this._y = y;
            this._z = z;
            return this;
          }
          const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
          if (sqrSinHalfTheta <= Number.EPSILON) {
            const s3 = 1 - t2;
            this._w = s3 * w + t2 * this._w;
            this._x = s3 * x2 + t2 * this._x;
            this._y = s3 * y + t2 * this._y;
            this._z = s3 * z + t2 * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
          this._w = w * ratioA + this._w * ratioB;
          this._x = x2 * ratioA + this._x * ratioB;
          this._y = y * ratioA + this._y * ratioB;
          this._z = z * ratioA + this._z * ratioB;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(qa, qb, t2) {
          this.copy(qa).slerp(qb, t2);
        }
        random() {
          const u1 = Math.random();
          const sqrt1u1 = Math.sqrt(1 - u1);
          const sqrtu1 = Math.sqrt(u1);
          const u2 = 2 * Math.PI * Math.random();
          const u3 = 2 * Math.PI * Math.random();
          return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
        }
        equals(quaternion) {
          return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        }
        fromArray(array, offset = 0) {
          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this._x = attribute.getX(index);
          this._y = attribute.getY(index);
          this._z = attribute.getZ(index);
          this._w = attribute.getW(index);
          return this;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      }
      Quaternion.prototype.isQuaternion = true;
      class Vector34 {
        constructor(x2 = 0, y = 0, z = 0) {
          this.x = x2;
          this.y = y;
          this.z = z;
        }
        set(x2, y, z) {
          if (z === void 0)
            z = this.z;
          this.x = x2;
          this.y = y;
          this.z = z;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          return this;
        }
        setX(x2) {
          this.x = x2;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
        }
        addScalar(s3) {
          this.x += s3;
          this.y += s3;
          this.z += s3;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          return this;
        }
        addScaledVector(v, s3) {
          this.x += v.x * s3;
          this.y += v.y * s3;
          this.z += v.z * s3;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
        }
        subScalar(s3) {
          this.x -= s3;
          this.y -= s3;
          this.z -= s3;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          return this;
        }
        multiply(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
          }
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiplyVectors(a, b) {
          this.x = a.x * b.x;
          this.y = a.y * b.y;
          this.z = a.z * b.z;
          return this;
        }
        applyEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle) {
          return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m2) {
          const x2 = this.x, y = this.y, z = this.z;
          const e2 = m2.elements;
          this.x = e2[0] * x2 + e2[3] * y + e2[6] * z;
          this.y = e2[1] * x2 + e2[4] * y + e2[7] * z;
          this.z = e2[2] * x2 + e2[5] * y + e2[8] * z;
          return this;
        }
        applyNormalMatrix(m2) {
          return this.applyMatrix3(m2).normalize();
        }
        applyMatrix4(m2) {
          const x2 = this.x, y = this.y, z = this.z;
          const e2 = m2.elements;
          const w = 1 / (e2[3] * x2 + e2[7] * y + e2[11] * z + e2[15]);
          this.x = (e2[0] * x2 + e2[4] * y + e2[8] * z + e2[12]) * w;
          this.y = (e2[1] * x2 + e2[5] * y + e2[9] * z + e2[13]) * w;
          this.z = (e2[2] * x2 + e2[6] * y + e2[10] * z + e2[14]) * w;
          return this;
        }
        applyQuaternion(q) {
          const x2 = this.x, y = this.y, z = this.z;
          const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
          const ix = qw * x2 + qy * z - qz * y;
          const iy = qw * y + qz * x2 - qx * z;
          const iz = qw * z + qx * y - qy * x2;
          const iw = -qx * x2 - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        }
        project(camera) {
          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m2) {
          const x2 = this.x, y = this.y, z = this.z;
          const e2 = m2.elements;
          this.x = e2[0] * x2 + e2[4] * y + e2[8] * z;
          this.y = e2[1] * x2 + e2[5] * y + e2[9] * z;
          this.z = e2[2] * x2 + e2[6] * y + e2[10] * z;
          return this.normalize();
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          return this;
        }
        cross(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
          }
          return this.crossVectors(this, v);
        }
        crossVectors(a, b) {
          const ax = a.x, ay = a.y, az = a.z;
          const bx = b.x, by = b.y, bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        projectOnVector(v) {
          const denominator = v.lengthSq();
          if (denominator === 0)
            return this.set(0, 0, 0);
          const scalar = v.dot(this) / denominator;
          return this.copy(v).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
          _vector$c.copy(this).projectOnVector(planeNormal);
          return this.sub(_vector$c);
        }
        reflect(normal) {
          return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v) {
          const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v) / denominator;
          return Math.acos(clamp(theta, -1, 1));
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
          return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        }
        setFromSpherical(s3) {
          return this.setFromSphericalCoords(s3.radius, s3.phi, s3.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
          const sinPhiRadius = Math.sin(phi) * radius;
          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);
          return this;
        }
        setFromCylindrical(c) {
          return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
        }
        setFromCylindricalCoords(radius, theta, y) {
          this.x = radius * Math.sin(theta);
          this.y = y;
          this.z = radius * Math.cos(theta);
          return this;
        }
        setFromMatrixPosition(m2) {
          const e2 = m2.elements;
          this.x = e2[12];
          this.y = e2[13];
          this.z = e2[14];
          return this;
        }
        setFromMatrixScale(m2) {
          const sx = this.setFromMatrixColumn(m2, 0).length();
          const sy = this.setFromMatrixColumn(m2, 1).length();
          const sz = this.setFromMatrixColumn(m2, 2).length();
          this.x = sx;
          this.y = sy;
          this.z = sz;
          return this;
        }
        setFromMatrixColumn(m2, index) {
          return this.fromArray(m2.elements, index * 4);
        }
        setFromMatrix3Column(m2, index) {
          return this.fromArray(m2.elements, index * 3);
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
        randomDirection() {
          const u = (Math.random() - 0.5) * 2;
          const t2 = Math.random() * Math.PI * 2;
          const f3 = Math.sqrt(1 - u ** 2);
          this.x = f3 * Math.cos(t2);
          this.y = f3 * Math.sin(t2);
          this.z = u;
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
        }
      }
      Vector34.prototype.isVector3 = true;
      const _vector$c = /* @__PURE__ */ new Vector34();
      const _quaternion$4 = /* @__PURE__ */ new Quaternion();
      class Box3 {
        constructor(min = new Vector34(Infinity, Infinity, Infinity), max = new Vector34(-Infinity, -Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromArray(array) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
            const x2 = array[i2];
            const y = array[i2 + 1];
            const z = array[i2 + 2];
            if (x2 < minX)
              minX = x2;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x2 > maxX)
              maxX = x2;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromBufferAttribute(attribute) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l = attribute.count; i2 < l; i2++) {
            const x2 = attribute.getX(i2);
            const y = attribute.getY(i2);
            const z = attribute.getZ(i2);
            if (x2 < minX)
              minX = x2;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x2 > maxX)
              maxX = x2;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        setFromObject(object) {
          this.makeEmpty();
          return this.expandByObject(object);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        expandByObject(object) {
          object.updateWorldMatrix(false, false);
          const geometry2 = object.geometry;
          if (geometry2 !== void 0) {
            if (geometry2.boundingBox === null) {
              geometry2.computeBoundingBox();
            }
            _box$3.copy(geometry2.boundingBox);
            _box$3.applyMatrix4(object.matrixWorld);
            this.union(_box$3);
          }
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            this.expandByObject(children[i2]);
          }
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
          this.clampPoint(sphere.center, _vector$b);
          return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        }
        intersectsPlane(plane) {
          let min, max;
          if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
          } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
          } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
          } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
          }
          return min <= -plane.constant && max >= -plane.constant;
        }
        intersectsTriangle(triangle) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(_center);
          _extents.subVectors(this.max, _center);
          _v0$2.subVectors(triangle.a, _center);
          _v1$7.subVectors(triangle.b, _center);
          _v2$3.subVectors(triangle.c, _center);
          _f0.subVectors(_v1$7, _v0$2);
          _f1.subVectors(_v2$3, _v1$7);
          _f2.subVectors(_v0$2, _v2$3);
          let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          _triangleNormal.crossVectors(_f0, _f1);
          axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
          return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        getBoundingSphere(target) {
          this.getCenter(target.center);
          target.radius = this.getSize(_vector$b).length() * 0.5;
          return target;
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          if (this.isEmpty())
            this.makeEmpty();
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        applyMatrix4(matrix) {
          if (this.isEmpty())
            return this;
          _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.setFromPoints(_points);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      }
      Box3.prototype.isBox3 = true;
      const _points = [/* @__PURE__ */ new Vector34(), /* @__PURE__ */ new Vector34(), /* @__PURE__ */ new Vector34(), /* @__PURE__ */ new Vector34(), /* @__PURE__ */ new Vector34(), /* @__PURE__ */ new Vector34(), /* @__PURE__ */ new Vector34(), /* @__PURE__ */ new Vector34()];
      const _vector$b = /* @__PURE__ */ new Vector34();
      const _box$3 = /* @__PURE__ */ new Box3();
      const _v0$2 = /* @__PURE__ */ new Vector34();
      const _v1$7 = /* @__PURE__ */ new Vector34();
      const _v2$3 = /* @__PURE__ */ new Vector34();
      const _f0 = /* @__PURE__ */ new Vector34();
      const _f1 = /* @__PURE__ */ new Vector34();
      const _f2 = /* @__PURE__ */ new Vector34();
      const _center = /* @__PURE__ */ new Vector34();
      const _extents = /* @__PURE__ */ new Vector34();
      const _triangleNormal = /* @__PURE__ */ new Vector34();
      const _testAxis = /* @__PURE__ */ new Vector34();
      function satForAxes(axes, v0, v1, v2, extents) {
        for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
          _testAxis.fromArray(axes, i2);
          const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
          const p0 = v0.dot(_testAxis);
          const p1 = v1.dot(_testAxis);
          const p2 = v2.dot(_testAxis);
          if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
            return false;
          }
        }
        return true;
      }
      const _box$2 = /* @__PURE__ */ new Box3();
      const _v1$6 = /* @__PURE__ */ new Vector34();
      const _toFarthestPoint = /* @__PURE__ */ new Vector34();
      const _toPoint = /* @__PURE__ */ new Vector34();
      class Sphere {
        constructor(center = new Vector34(), radius = -1) {
          this.center = center;
          this.radius = radius;
        }
        set(center, radius) {
          this.center.copy(center);
          this.radius = radius;
          return this;
        }
        setFromPoints(points, optionalCenter) {
          const center = this.center;
          if (optionalCenter !== void 0) {
            center.copy(optionalCenter);
          } else {
            _box$2.setFromPoints(points).getCenter(center);
          }
          let maxRadiusSq = 0;
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        }
        copy(sphere) {
          this.center.copy(sphere.center);
          this.radius = sphere.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(point) {
          return point.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(point) {
          return point.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(sphere) {
          const radiusSum = this.radius + sphere.radius;
          return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        }
        intersectsBox(box) {
          return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
          const deltaLengthSq = this.center.distanceToSquared(point);
          target.copy(point);
          if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
          }
          return target;
        }
        getBoundingBox(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
            return target;
          }
          target.set(this.center, this.center);
          target.expandByScalar(this.radius);
          return target;
        }
        applyMatrix4(matrix) {
          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();
          return this;
        }
        translate(offset) {
          this.center.add(offset);
          return this;
        }
        expandByPoint(point) {
          _toPoint.subVectors(point, this.center);
          const lengthSq = _toPoint.lengthSq();
          if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
          }
          return this;
        }
        union(sphere) {
          _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
          this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
          this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
          return this;
        }
        equals(sphere) {
          return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const _vector$a = /* @__PURE__ */ new Vector34();
      const _segCenter = /* @__PURE__ */ new Vector34();
      const _segDir = /* @__PURE__ */ new Vector34();
      const _diff = /* @__PURE__ */ new Vector34();
      const _edge1 = /* @__PURE__ */ new Vector34();
      const _edge2 = /* @__PURE__ */ new Vector34();
      const _normal$1 = /* @__PURE__ */ new Vector34();
      class Ray {
        constructor(origin = new Vector34(), direction = new Vector34(0, 0, -1)) {
          this.origin = origin;
          this.direction = direction;
        }
        set(origin, direction) {
          this.origin.copy(origin);
          this.direction.copy(direction);
          return this;
        }
        copy(ray) {
          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);
          return this;
        }
        at(t2, target) {
          return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
        }
        lookAt(v) {
          this.direction.copy(v).sub(this.origin).normalize();
          return this;
        }
        recast(t2) {
          this.origin.copy(this.at(t2, _vector$a));
          return this;
        }
        closestPointToPoint(point, target) {
          target.subVectors(point, this.origin);
          const directionDistance = target.dot(this.direction);
          if (directionDistance < 0) {
            return target.copy(this.origin);
          }
          return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        }
        distanceToPoint(point) {
          return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
          const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return _vector$a.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir.copy(v1).sub(v0).normalize();
          _diff.copy(this.origin).sub(_segCenter);
          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir);
          const b0 = _diff.dot(this.direction);
          const b1 = -_diff.dot(_segDir);
          const c = _diff.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  const invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
          }
          return sqrDist;
        }
        intersectSphere(sphere, target) {
          _vector$a.subVectors(sphere.center, this.origin);
          const tca = _vector$a.dot(this.direction);
          const d2 = _vector$a.dot(_vector$a) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          const thc = Math.sqrt(radius2 - d2);
          const t0 = tca - thc;
          const t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, target);
          return this.at(t0, target);
        }
        intersectsSphere(sphere) {
          return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        }
        distanceToPlane(plane) {
          const denominator = plane.normal.dot(this.direction);
          if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
              return 0;
            }
            return null;
          }
          const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
          return t2 >= 0 ? t2 : null;
        }
        intersectPlane(plane, target) {
          const t2 = this.distanceToPlane(plane);
          if (t2 === null) {
            return null;
          }
          return this.at(t2, target);
        }
        intersectsPlane(plane) {
          const distToPoint = plane.distanceToPoint(this.origin);
          if (distToPoint === 0) {
            return true;
          }
          const denominator = plane.normal.dot(this.direction);
          if (denominator * distToPoint < 0) {
            return true;
          }
          return false;
        }
        intersectBox(box, target) {
          let tmin, tmax, tymin, tymax, tzmin, tzmax;
          const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
          const origin = this.origin;
          if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
          } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
          }
          if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
          } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
          }
          if (tmin > tymax || tymin > tmax)
            return null;
          if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
          if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
          if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
          } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
          }
          if (tmin > tzmax || tzmin > tmax)
            return null;
          if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
          if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
          if (tmax < 0)
            return null;
          return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
          return this.intersectBox(box, _vector$a) !== null;
        }
        intersectTriangle(a, b, c, backfaceCulling, target) {
          _edge1.subVectors(b, a);
          _edge2.subVectors(c, a);
          _normal$1.crossVectors(_edge1, _edge2);
          let DdN = this.direction.dot(_normal$1);
          let sign2;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign2 = 1;
          } else if (DdN < 0) {
            sign2 = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          _diff.subVectors(this.origin, a);
          const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          const QdN = -sign2 * _diff.dot(_normal$1);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);
          return this;
        }
        equals(ray) {
          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Matrix4 {
        constructor() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          const te = this.elements;
          te[0] = n11;
          te[4] = n12;
          te[8] = n13;
          te[12] = n14;
          te[1] = n21;
          te[5] = n22;
          te[9] = n23;
          te[13] = n24;
          te[2] = n31;
          te[6] = n32;
          te[10] = n33;
          te[14] = n34;
          te[3] = n41;
          te[7] = n42;
          te[11] = n43;
          te[15] = n44;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        clone() {
          return new Matrix4().fromArray(this.elements);
        }
        copy(m2) {
          const te = this.elements;
          const me = m2.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          te[9] = me[9];
          te[10] = me[10];
          te[11] = me[11];
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          te[15] = me[15];
          return this;
        }
        copyPosition(m2) {
          const te = this.elements, me = m2.elements;
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          return this;
        }
        setFromMatrix3(m2) {
          const me = m2.elements;
          this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
          this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
          return this;
        }
        extractRotation(m2) {
          const te = this.elements;
          const me = m2.elements;
          const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
          const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
          const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[3] = 0;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[7] = 0;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          }
          const te = this.elements;
          const x2 = euler.x, y = euler.y, z = euler.z;
          const a = Math.cos(x2), b = Math.sin(x2);
          const c = Math.cos(y), d = Math.sin(y);
          const e2 = Math.cos(z), f3 = Math.sin(z);
          if (euler.order === "XYZ") {
            const ae = a * e2, af = a * f3, be = b * e2, bf = b * f3;
            te[0] = c * e2;
            te[4] = -c * f3;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
          } else if (euler.order === "YXZ") {
            const ce = c * e2, cf = c * f3, de = d * e2, df = d * f3;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f3;
            te[5] = a * e2;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
          } else if (euler.order === "ZXY") {
            const ce = c * e2, cf = c * f3, de = d * e2, df = d * f3;
            te[0] = ce - df * b;
            te[4] = -a * f3;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e2;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
          } else if (euler.order === "ZYX") {
            const ae = a * e2, af = a * f3, be = b * e2, bf = b * f3;
            te[0] = c * e2;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f3;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
          } else if (euler.order === "YZX") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e2;
            te[4] = bd - ac * f3;
            te[8] = bc * f3 + ad;
            te[1] = f3;
            te[5] = a * e2;
            te[9] = -b * e2;
            te[2] = -d * e2;
            te[6] = ad * f3 + bc;
            te[10] = ac - bd * f3;
          } else if (euler.order === "XZY") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e2;
            te[4] = -f3;
            te[8] = d * e2;
            te[1] = ac * f3 + bd;
            te[5] = a * e2;
            te[9] = ad * f3 - bc;
            te[2] = bc * f3 - ad;
            te[6] = b * e2;
            te[10] = bd * f3 + ac;
          }
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(q) {
          return this.compose(_zero, q, _one);
        }
        lookAt(eye, target, up) {
          const te = this.elements;
          _z.subVectors(eye, target);
          if (_z.lengthSq() === 0) {
            _z.z = 1;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
          if (_x.lengthSq() === 0) {
            if (Math.abs(up.z) === 1) {
              _z.x += 1e-4;
            } else {
              _z.z += 1e-4;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
          }
          _x.normalize();
          _y.crossVectors(_z, _x);
          te[0] = _x.x;
          te[4] = _y.x;
          te[8] = _z.x;
          te[1] = _x.y;
          te[5] = _y.y;
          te[9] = _z.y;
          te[2] = _x.z;
          te[6] = _y.z;
          te[10] = _z.z;
          return this;
        }
        multiply(m2, n) {
          if (n !== void 0) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m2, n);
          }
          return this.multiplyMatrices(this, m2);
        }
        premultiply(m2) {
          return this.multiplyMatrices(m2, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
          const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
          const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
          const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
          const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
          const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
          const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
          const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
          te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
          return this;
        }
        multiplyScalar(s3) {
          const te = this.elements;
          te[0] *= s3;
          te[4] *= s3;
          te[8] *= s3;
          te[12] *= s3;
          te[1] *= s3;
          te[5] *= s3;
          te[9] *= s3;
          te[13] *= s3;
          te[2] *= s3;
          te[6] *= s3;
          te[10] *= s3;
          te[14] *= s3;
          te[3] *= s3;
          te[7] *= s3;
          te[11] *= s3;
          te[15] *= s3;
          return this;
        }
        determinant() {
          const te = this.elements;
          const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
          const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
          const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
          const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
          return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        }
        transpose() {
          const te = this.elements;
          let tmp2;
          tmp2 = te[1];
          te[1] = te[4];
          te[4] = tmp2;
          tmp2 = te[2];
          te[2] = te[8];
          te[8] = tmp2;
          tmp2 = te[6];
          te[6] = te[9];
          te[9] = tmp2;
          tmp2 = te[3];
          te[3] = te[12];
          te[12] = tmp2;
          tmp2 = te[7];
          te[7] = te[13];
          te[13] = tmp2;
          tmp2 = te[11];
          te[11] = te[14];
          te[14] = tmp2;
          return this;
        }
        setPosition(x2, y, z) {
          const te = this.elements;
          if (x2.isVector3) {
            te[12] = x2.x;
            te[13] = x2.y;
            te[14] = x2.z;
          } else {
            te[12] = x2;
            te[13] = y;
            te[14] = z;
          }
          return this;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
          te[4] = t12 * detInv;
          te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
          te[8] = t13 * detInv;
          te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
          te[12] = t14 * detInv;
          te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
          return this;
        }
        scale(v) {
          const te = this.elements;
          const x2 = v.x, y = v.y, z = v.z;
          te[0] *= x2;
          te[4] *= y;
          te[8] *= z;
          te[1] *= x2;
          te[5] *= y;
          te[9] *= z;
          te[2] *= x2;
          te[6] *= y;
          te[10] *= z;
          te[3] *= x2;
          te[7] *= y;
          te[11] *= z;
          return this;
        }
        getMaxScaleOnAxis() {
          const te = this.elements;
          const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
          const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
          const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x2, y, z) {
          this.set(1, 0, 0, x2, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
          return this;
        }
        makeRotationX(theta) {
          const c = Math.cos(theta), s3 = Math.sin(theta);
          this.set(1, 0, 0, 0, 0, c, -s3, 0, 0, s3, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationY(theta) {
          const c = Math.cos(theta), s3 = Math.sin(theta);
          this.set(c, 0, s3, 0, 0, 1, 0, 0, -s3, 0, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationZ(theta) {
          const c = Math.cos(theta), s3 = Math.sin(theta);
          this.set(c, -s3, 0, 0, s3, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationAxis(axis, angle) {
          const c = Math.cos(angle);
          const s3 = Math.sin(angle);
          const t2 = 1 - c;
          const x2 = axis.x, y = axis.y, z = axis.z;
          const tx = t2 * x2, ty = t2 * y;
          this.set(tx * x2 + c, tx * y - s3 * z, tx * z + s3 * y, 0, tx * y + s3 * z, ty * y + c, ty * z - s3 * x2, 0, tx * z - s3 * y, ty * z + s3 * x2, t2 * z * z + c, 0, 0, 0, 0, 1);
          return this;
        }
        makeScale(x2, y, z) {
          this.set(x2, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
          return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
          this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
          return this;
        }
        compose(position2, quaternion, scale2) {
          const te = this.elements;
          const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
          const x22 = x2 + x2, y2 = y + y, z2 = z + z;
          const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;
          const yy = y * y2, yz = y * z2, zz = z * z2;
          const wx = w * x22, wy = w * y2, wz = w * z2;
          const sx = scale2.x, sy = scale2.y, sz = scale2.z;
          te[0] = (1 - (yy + zz)) * sx;
          te[1] = (xy + wz) * sx;
          te[2] = (xz - wy) * sx;
          te[3] = 0;
          te[4] = (xy - wz) * sy;
          te[5] = (1 - (xx + zz)) * sy;
          te[6] = (yz + wx) * sy;
          te[7] = 0;
          te[8] = (xz + wy) * sz;
          te[9] = (yz - wx) * sz;
          te[10] = (1 - (xx + yy)) * sz;
          te[11] = 0;
          te[12] = position2.x;
          te[13] = position2.y;
          te[14] = position2.z;
          te[15] = 1;
          return this;
        }
        decompose(position2, quaternion, scale2) {
          const te = this.elements;
          let sx = _v1$5.set(te[0], te[1], te[2]).length();
          const sy = _v1$5.set(te[4], te[5], te[6]).length();
          const sz = _v1$5.set(te[8], te[9], te[10]).length();
          const det = this.determinant();
          if (det < 0)
            sx = -sx;
          position2.x = te[12];
          position2.y = te[13];
          position2.z = te[14];
          _m1$2.copy(this);
          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;
          _m1$2.elements[0] *= invSX;
          _m1$2.elements[1] *= invSX;
          _m1$2.elements[2] *= invSX;
          _m1$2.elements[4] *= invSY;
          _m1$2.elements[5] *= invSY;
          _m1$2.elements[6] *= invSY;
          _m1$2.elements[8] *= invSZ;
          _m1$2.elements[9] *= invSZ;
          _m1$2.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(_m1$2);
          scale2.x = sx;
          scale2.y = sy;
          scale2.z = sz;
          return this;
        }
        makePerspective(left, right, top, bottom, near, far) {
          if (far === void 0) {
            console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          }
          const te = this.elements;
          const x2 = 2 * near / (right - left);
          const y = 2 * near / (top - bottom);
          const a = (right + left) / (right - left);
          const b = (top + bottom) / (top - bottom);
          const c = -(far + near) / (far - near);
          const d = -2 * far * near / (far - near);
          te[0] = x2;
          te[4] = 0;
          te[8] = a;
          te[12] = 0;
          te[1] = 0;
          te[5] = y;
          te[9] = b;
          te[13] = 0;
          te[2] = 0;
          te[6] = 0;
          te[10] = c;
          te[14] = d;
          te[3] = 0;
          te[7] = 0;
          te[11] = -1;
          te[15] = 0;
          return this;
        }
        makeOrthographic(left, right, top, bottom, near, far) {
          const te = this.elements;
          const w = 1 / (right - left);
          const h2 = 1 / (top - bottom);
          const p = 1 / (far - near);
          const x2 = (right + left) * w;
          const y = (top + bottom) * h2;
          const z = (far + near) * p;
          te[0] = 2 * w;
          te[4] = 0;
          te[8] = 0;
          te[12] = -x2;
          te[1] = 0;
          te[5] = 2 * h2;
          te[9] = 0;
          te[13] = -y;
          te[2] = 0;
          te[6] = 0;
          te[10] = -2 * p;
          te[14] = -z;
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[15] = 1;
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i2 = 0; i2 < 16; i2++) {
            if (te[i2] !== me[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 16; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          array[offset + 9] = te[9];
          array[offset + 10] = te[10];
          array[offset + 11] = te[11];
          array[offset + 12] = te[12];
          array[offset + 13] = te[13];
          array[offset + 14] = te[14];
          array[offset + 15] = te[15];
          return array;
        }
      }
      Matrix4.prototype.isMatrix4 = true;
      const _v1$5 = /* @__PURE__ */ new Vector34();
      const _m1$2 = /* @__PURE__ */ new Matrix4();
      const _zero = /* @__PURE__ */ new Vector34(0, 0, 0);
      const _one = /* @__PURE__ */ new Vector34(1, 1, 1);
      const _x = /* @__PURE__ */ new Vector34();
      const _y = /* @__PURE__ */ new Vector34();
      const _z = /* @__PURE__ */ new Vector34();
      const _matrix$1 = /* @__PURE__ */ new Matrix4();
      const _quaternion$3 = /* @__PURE__ */ new Quaternion();
      class Euler {
        constructor(x2 = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
          this._x = x2;
          this._y = y;
          this._z = z;
          this._order = order;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(value) {
          this._order = value;
          this._onChangeCallback();
        }
        set(x2, y, z, order = this._order) {
          this._x = x2;
          this._y = y;
          this._z = z;
          this._order = order;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m2, order = this._order, update = true) {
          const te = m2.elements;
          const m11 = te[0], m12 = te[4], m13 = te[8];
          const m21 = te[1], m22 = te[5], m23 = te[9];
          const m31 = te[2], m32 = te[6], m33 = te[10];
          switch (order) {
            case "XYZ":
              this._y = Math.asin(clamp(m13, -1, 1));
              if (Math.abs(m13) < 0.9999999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
              } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-clamp(m23, -1, 1));
              if (Math.abs(m23) < 0.9999999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
              } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(clamp(m32, -1, 1));
              if (Math.abs(m32) < 0.9999999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
              } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-clamp(m31, -1, 1));
              if (Math.abs(m31) < 0.9999999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
              } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
              }
              break;
            case "YZX":
              this._z = Math.asin(clamp(m21, -1, 1));
              if (Math.abs(m21) < 0.9999999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
              } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
              }
              break;
            case "XZY":
              this._z = Math.asin(-clamp(m12, -1, 1));
              if (Math.abs(m12) < 0.9999999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
              } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
          }
          this._order = order;
          if (update === true)
            this._onChangeCallback();
          return this;
        }
        setFromQuaternion(q, order, update) {
          _matrix$1.makeRotationFromQuaternion(q);
          return this.setFromRotationMatrix(_matrix$1, order, update);
        }
        setFromVector3(v, order = this._order) {
          return this.set(v.x, v.y, v.z, order);
        }
        reorder(newOrder) {
          _quaternion$3.setFromEuler(this);
          return this.setFromQuaternion(_quaternion$3, newOrder);
        }
        equals(euler) {
          return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        }
        fromArray(array) {
          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== void 0)
            this._order = array[3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;
          return array;
        }
        toVector3(optionalResult) {
          if (optionalResult) {
            return optionalResult.set(this._x, this._y, this._z);
          } else {
            return new Vector34(this._x, this._y, this._z);
          }
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      }
      Euler.prototype.isEuler = true;
      Euler.DefaultOrder = "XYZ";
      Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Layers {
        constructor() {
          this.mask = 1 | 0;
        }
        set(channel) {
          this.mask = (1 << channel | 0) >>> 0;
        }
        enable(channel) {
          this.mask |= 1 << channel | 0;
        }
        enableAll() {
          this.mask = 4294967295 | 0;
        }
        toggle(channel) {
          this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
          this.mask &= ~(1 << channel | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(layers) {
          return (this.mask & layers.mask) !== 0;
        }
        isEnabled(channel) {
          return (this.mask & (1 << channel | 0)) !== 0;
        }
      }
      let _object3DId = 0;
      const _v1$4 = /* @__PURE__ */ new Vector34();
      const _q1 = /* @__PURE__ */ new Quaternion();
      const _m1$1 = /* @__PURE__ */ new Matrix4();
      const _target = /* @__PURE__ */ new Vector34();
      const _position$3 = /* @__PURE__ */ new Vector34();
      const _scale$2 = /* @__PURE__ */ new Vector34();
      const _quaternion$2 = /* @__PURE__ */ new Quaternion();
      const _xAxis = /* @__PURE__ */ new Vector34(1, 0, 0);
      const _yAxis = /* @__PURE__ */ new Vector34(0, 1, 0);
      const _zAxis = /* @__PURE__ */ new Vector34(0, 0, 1);
      const _addedEvent = {
        type: "added"
      };
      const _removedEvent = {
        type: "removed"
      };
      class Object3D2 extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _object3DId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = Object3D2.DefaultUp.clone();
          const position2 = new Vector34();
          const rotation2 = new Euler();
          const quaternion = new Quaternion();
          const scale2 = new Vector34(1, 1, 1);
          function onRotationChange() {
            quaternion.setFromEuler(rotation2, false);
          }
          function onQuaternionChange() {
            rotation2.setFromQuaternion(quaternion, void 0, false);
          }
          rotation2._onChange(onRotationChange);
          quaternion._onChange(onQuaternionChange);
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: position2
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: rotation2
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: scale2
            },
            modelViewMatrix: {
              value: new Matrix4()
            },
            normalMatrix: {
              value: new Matrix32()
            }
          });
          this.matrix = new Matrix4();
          this.matrixWorld = new Matrix4();
          this.matrixAutoUpdate = Object3D2.DefaultMatrixAutoUpdate;
          this.matrixWorldNeedsUpdate = false;
          this.layers = new Layers();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(matrix) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          this.matrix.premultiply(matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q) {
          this.quaternion.premultiply(q);
          return this;
        }
        setRotationFromAxisAngle(axis, angle) {
          this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
          this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m2) {
          this.quaternion.setFromRotationMatrix(m2);
        }
        setRotationFromQuaternion(q) {
          this.quaternion.copy(q);
        }
        rotateOnAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(_q1);
          return this;
        }
        rotateOnWorldAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.premultiply(_q1);
          return this;
        }
        rotateX(angle) {
          return this.rotateOnAxis(_xAxis, angle);
        }
        rotateY(angle) {
          return this.rotateOnAxis(_yAxis, angle);
        }
        rotateZ(angle) {
          return this.rotateOnAxis(_zAxis, angle);
        }
        translateOnAxis(axis, distance) {
          _v1$4.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(_v1$4.multiplyScalar(distance));
          return this;
        }
        translateX(distance) {
          return this.translateOnAxis(_xAxis, distance);
        }
        translateY(distance) {
          return this.translateOnAxis(_yAxis, distance);
        }
        translateZ(distance) {
          return this.translateOnAxis(_zAxis, distance);
        }
        localToWorld(vector) {
          return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
          return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        }
        lookAt(x2, y, z) {
          if (x2.isVector3) {
            _target.copy(x2);
          } else {
            _target.set(x2, y, z);
          }
          const parent = this.parent;
          this.updateWorldMatrix(true, false);
          _position$3.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            _m1$1.lookAt(_position$3, _target, this.up);
          } else {
            _m1$1.lookAt(_target, _position$3, this.up);
          }
          this.quaternion.setFromRotationMatrix(_m1$1);
          if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
          }
        }
        add(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.add(arguments[i2]);
            }
            return this;
          }
          if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
          }
          if (object && object.isObject3D) {
            if (object.parent !== null) {
              object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
          } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
          }
          return this;
        }
        remove(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.remove(arguments[i2]);
            }
            return this;
          }
          const index = this.children.indexOf(object);
          if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
          }
          return this;
        }
        removeFromParent() {
          const parent = this.parent;
          if (parent !== null) {
            parent.remove(this);
          }
          return this;
        }
        clear() {
          for (let i2 = 0; i2 < this.children.length; i2++) {
            const object = this.children[i2];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
          }
          this.children.length = 0;
          return this;
        }
        attach(object) {
          this.updateWorldMatrix(true, false);
          _m1$1.copy(this.matrixWorld).invert();
          if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
          }
          object.applyMatrix4(_m1$1);
          this.add(object);
          object.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(id) {
          return this.getObjectByProperty("id", id);
        }
        getObjectByName(name) {
          return this.getObjectByProperty("name", name);
        }
        getObjectByProperty(name, value) {
          if (this[name] === value)
            return this;
          for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
            const child = this.children[i2];
            const object = child.getObjectByProperty(name, value);
            if (object !== void 0) {
              return object;
            }
          }
          return void 0;
        }
        getWorldPosition(target) {
          this.updateWorldMatrix(true, false);
          return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, target, _scale$2);
          return target;
        }
        getWorldScale(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, _quaternion$2, target);
          return target;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e2 = this.matrixWorld.elements;
          return target.set(e2[8], e2[9], e2[10]).normalize();
        }
        raycast() {
        }
        traverse(callback) {
          callback(this);
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].traverse(callback);
          }
        }
        traverseVisible(callback) {
          if (this.visible === false)
            return;
          callback(this);
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].traverseVisible(callback);
          }
        }
        traverseAncestors(callback) {
          const parent = this.parent;
          if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
          }
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].updateMatrixWorld(force);
          }
        }
        updateWorldMatrix(updateParents, updateChildren) {
          const parent = this.parent;
          if (updateParents === true && parent !== null) {
            parent.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (updateChildren === true) {
            const children = this.children;
            for (let i2 = 0, l = children.length; i2 < l; i2++) {
              children[i2].updateWorldMatrix(false, true);
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          const output = {};
          if (isRootObject) {
            meta = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {}
            };
            output.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const object = {};
          object.uuid = this.uuid;
          object.type = this.type;
          if (this.name !== "")
            object.name = this.name;
          if (this.castShadow === true)
            object.castShadow = true;
          if (this.receiveShadow === true)
            object.receiveShadow = true;
          if (this.visible === false)
            object.visible = false;
          if (this.frustumCulled === false)
            object.frustumCulled = false;
          if (this.renderOrder !== 0)
            object.renderOrder = this.renderOrder;
          if (JSON.stringify(this.userData) !== "{}")
            object.userData = this.userData;
          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();
          if (this.matrixAutoUpdate === false)
            object.matrixAutoUpdate = false;
          if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null)
              object.instanceColor = this.instanceColor.toJSON();
          }
          function serialize(library, element) {
            if (library[element.uuid] === void 0) {
              library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                object.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                object.background = this.background.toJSON(meta).uuid;
              }
            }
            if (this.environment && this.environment.isTexture) {
              object.environment = this.environment.toJSON(meta).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== void 0 && parameters.shapes !== void 0) {
              const shapes = parameters.shapes;
              if (Array.isArray(shapes)) {
                for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
                  const shape = shapes[i2];
                  serialize(meta.shapes, shape);
                }
              } else {
                serialize(meta.shapes, shapes);
              }
            }
          }
          if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== void 0) {
              serialize(meta.skeletons, this.skeleton);
              object.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== void 0) {
            if (Array.isArray(this.material)) {
              const uuids = [];
              for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
                uuids.push(serialize(meta.materials, this.material[i2]));
              }
              object.material = uuids;
            } else {
              object.material = serialize(meta.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            object.children = [];
            for (let i2 = 0; i2 < this.children.length; i2++) {
              object.children.push(this.children[i2].toJSON(meta).object);
            }
          }
          if (this.animations.length > 0) {
            object.animations = [];
            for (let i2 = 0; i2 < this.animations.length; i2++) {
              const animation = this.animations[i2];
              object.animations.push(serialize(meta.animations, animation));
            }
          }
          if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            if (geometries.length > 0)
              output.geometries = geometries;
            if (materials.length > 0)
              output.materials = materials;
            if (textures.length > 0)
              output.textures = textures;
            if (images.length > 0)
              output.images = images;
            if (shapes.length > 0)
              output.shapes = shapes;
            if (skeletons.length > 0)
              output.skeletons = skeletons;
            if (animations.length > 0)
              output.animations = animations;
          }
          output.object = object;
          return output;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data = cache[key];
              delete data.metadata;
              values.push(data);
            }
            return values;
          }
        }
        clone(recursive) {
          return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
          this.name = source.name;
          this.up.copy(source.up);
          this.position.copy(source.position);
          this.rotation.order = source.rotation.order;
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);
          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
          this.layers.mask = source.layers.mask;
          this.visible = source.visible;
          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;
          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          if (recursive === true) {
            for (let i2 = 0; i2 < source.children.length; i2++) {
              const child = source.children[i2];
              this.add(child.clone());
            }
          }
          return this;
        }
      }
      Object3D2.DefaultUp = new Vector34(0, 1, 0);
      Object3D2.DefaultMatrixAutoUpdate = true;
      Object3D2.prototype.isObject3D = true;
      const _v0$1 = /* @__PURE__ */ new Vector34();
      const _v1$3 = /* @__PURE__ */ new Vector34();
      const _v2$2 = /* @__PURE__ */ new Vector34();
      const _v3$1 = /* @__PURE__ */ new Vector34();
      const _vab = /* @__PURE__ */ new Vector34();
      const _vac = /* @__PURE__ */ new Vector34();
      const _vbc = /* @__PURE__ */ new Vector34();
      const _vap = /* @__PURE__ */ new Vector34();
      const _vbp = /* @__PURE__ */ new Vector34();
      const _vcp = /* @__PURE__ */ new Vector34();
      class Triangle {
        constructor(a = new Vector34(), b = new Vector34(), c = new Vector34()) {
          this.a = a;
          this.b = b;
          this.c = c;
        }
        static getNormal(a, b, c, target) {
          target.subVectors(c, b);
          _v0$1.subVectors(a, b);
          target.cross(_v0$1);
          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
          }
          return target.set(0, 0, 0);
        }
        static getBarycoord(point, a, b, c, target) {
          _v0$1.subVectors(c, a);
          _v1$3.subVectors(b, a);
          _v2$2.subVectors(point, a);
          const dot00 = _v0$1.dot(_v0$1);
          const dot01 = _v0$1.dot(_v1$3);
          const dot02 = _v0$1.dot(_v2$2);
          const dot11 = _v1$3.dot(_v1$3);
          const dot12 = _v1$3.dot(_v2$2);
          const denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          const invDenom = 1 / denom;
          const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        }
        static containsPoint(point, a, b, c) {
          this.getBarycoord(point, a, b, c, _v3$1);
          return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
        }
        static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          this.getBarycoord(point, p1, p2, p3, _v3$1);
          target.set(0, 0);
          target.addScaledVector(uv1, _v3$1.x);
          target.addScaledVector(uv2, _v3$1.y);
          target.addScaledVector(uv3, _v3$1.z);
          return target;
        }
        static isFrontFacing(a, b, c, direction) {
          _v0$1.subVectors(c, b);
          _v1$3.subVectors(a, b);
          return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
        }
        set(a, b, c) {
          this.a.copy(a);
          this.b.copy(b);
          this.c.copy(c);
          return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i2]);
          return this;
        }
        setFromAttributeAndIndices(attribute, i0, i1, i2) {
          this.a.fromBufferAttribute(attribute, i0);
          this.b.fromBufferAttribute(attribute, i1);
          this.c.fromBufferAttribute(attribute, i2);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(triangle) {
          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);
          return this;
        }
        getArea() {
          _v0$1.subVectors(this.c, this.b);
          _v1$3.subVectors(this.a, this.b);
          return _v0$1.cross(_v1$3).length() * 0.5;
        }
        getMidpoint(target) {
          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
          return Triangle.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
          return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
          return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getUV(point, uv1, uv2, uv3, target) {
          return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        }
        containsPoint(point) {
          return Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
          return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
          return box.intersectsTriangle(this);
        }
        closestPointToPoint(p, target) {
          const a = this.a, b = this.b, c = this.c;
          let v, w;
          _vab.subVectors(b, a);
          _vac.subVectors(c, a);
          _vap.subVectors(p, a);
          const d1 = _vab.dot(_vap);
          const d2 = _vac.dot(_vap);
          if (d1 <= 0 && d2 <= 0) {
            return target.copy(a);
          }
          _vbp.subVectors(p, b);
          const d3 = _vab.dot(_vbp);
          const d4 = _vac.dot(_vbp);
          if (d3 >= 0 && d4 <= d3) {
            return target.copy(b);
          }
          const vc = d1 * d4 - d3 * d2;
          if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            return target.copy(a).addScaledVector(_vab, v);
          }
          _vcp.subVectors(p, c);
          const d5 = _vab.dot(_vcp);
          const d6 = _vac.dot(_vcp);
          if (d6 >= 0 && d5 <= d6) {
            return target.copy(c);
          }
          const vb = d5 * d2 - d1 * d6;
          if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            return target.copy(a).addScaledVector(_vac, w);
          }
          const va = d3 * d6 - d5 * d4;
          if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b).addScaledVector(_vbc, w);
          }
          const denom = 1 / (va + vb + vc);
          v = vb * denom;
          w = vc * denom;
          return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
        }
        equals(triangle) {
          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
      }
      let materialId = 0;
      class Material extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: materialId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Material";
          this.fog = true;
          this.blending = NormalBlending;
          this.side = FrontSide;
          this.vertexColors = false;
          this.opacity = 1;
          this.format = RGBAFormat;
          this.transparent = false;
          this.blendSrc = SrcAlphaFactor;
          this.blendDst = OneMinusSrcAlphaFactor;
          this.blendEquation = AddEquation;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.depthFunc = LessEqualDepth;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = AlwaysStencilFunc;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = KeepStencilOp;
          this.stencilZFail = KeepStencilOp;
          this.stencilZPass = KeepStencilOp;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
          this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(value) {
          if (this._alphaTest > 0 !== value > 0) {
            this.version++;
          }
          this._alphaTest = value;
        }
        onBuild() {
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(values) {
          if (values === void 0)
            return;
          for (const key in values) {
            const newValue = values[key];
            if (newValue === void 0) {
              console.warn("THREE.Material: '" + key + "' parameter is undefined.");
              continue;
            }
            if (key === "shading") {
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
              this.flatShading = newValue === FlatShading ? true : false;
              continue;
            }
            const currentValue = this[key];
            if (currentValue === void 0) {
              console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
              continue;
            }
            if (currentValue && currentValue.isColor) {
              currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
              currentValue.copy(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
        toJSON(meta) {
          const isRoot = meta === void 0 || typeof meta === "string";
          if (isRoot) {
            meta = {
              textures: {},
              images: {}
            };
          }
          const data = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (this.color && this.color.isColor)
            data.color = this.color.getHex();
          if (this.roughness !== void 0)
            data.roughness = this.roughness;
          if (this.metalness !== void 0)
            data.metalness = this.metalness;
          if (this.sheen !== void 0)
            data.sheen = this.sheen;
          if (this.sheenColor && this.sheenColor.isColor)
            data.sheenColor = this.sheenColor.getHex();
          if (this.sheenRoughness !== void 0)
            data.sheenRoughness = this.sheenRoughness;
          if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1)
            data.emissiveIntensity = this.emissiveIntensity;
          if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
          if (this.specularIntensity !== void 0)
            data.specularIntensity = this.specularIntensity;
          if (this.specularColor && this.specularColor.isColor)
            data.specularColor = this.specularColor.getHex();
          if (this.shininess !== void 0)
            data.shininess = this.shininess;
          if (this.clearcoat !== void 0)
            data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== void 0)
            data.clearcoatRoughness = this.clearcoatRoughness;
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture)
            data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
          if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
          if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
            data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
          if (this.specularColorMap && this.specularColorMap.isTexture)
            data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
          if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== void 0)
              data.combine = this.combine;
          }
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
          if (this.reflectivity !== void 0)
            data.reflectivity = this.reflectivity;
          if (this.refractionRatio !== void 0)
            data.refractionRatio = this.refractionRatio;
          if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
          }
          if (this.transmission !== void 0)
            data.transmission = this.transmission;
          if (this.transmissionMap && this.transmissionMap.isTexture)
            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
          if (this.thickness !== void 0)
            data.thickness = this.thickness;
          if (this.thicknessMap && this.thicknessMap.isTexture)
            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
          if (this.attenuationDistance !== void 0)
            data.attenuationDistance = this.attenuationDistance;
          if (this.attenuationColor !== void 0)
            data.attenuationColor = this.attenuationColor.getHex();
          if (this.size !== void 0)
            data.size = this.size;
          if (this.shadowSide !== null)
            data.shadowSide = this.shadowSide;
          if (this.sizeAttenuation !== void 0)
            data.sizeAttenuation = this.sizeAttenuation;
          if (this.blending !== NormalBlending)
            data.blending = this.blending;
          if (this.side !== FrontSide)
            data.side = this.side;
          if (this.vertexColors)
            data.vertexColors = true;
          if (this.opacity < 1)
            data.opacity = this.opacity;
          if (this.format !== RGBAFormat)
            data.format = this.format;
          if (this.transparent === true)
            data.transparent = this.transparent;
          data.depthFunc = this.depthFunc;
          data.depthTest = this.depthTest;
          data.depthWrite = this.depthWrite;
          data.colorWrite = this.colorWrite;
          data.stencilWrite = this.stencilWrite;
          data.stencilWriteMask = this.stencilWriteMask;
          data.stencilFunc = this.stencilFunc;
          data.stencilRef = this.stencilRef;
          data.stencilFuncMask = this.stencilFuncMask;
          data.stencilFail = this.stencilFail;
          data.stencilZFail = this.stencilZFail;
          data.stencilZPass = this.stencilZPass;
          if (this.rotation && this.rotation !== 0)
            data.rotation = this.rotation;
          if (this.polygonOffset === true)
            data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0)
            data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0)
            data.polygonOffsetUnits = this.polygonOffsetUnits;
          if (this.linewidth && this.linewidth !== 1)
            data.linewidth = this.linewidth;
          if (this.dashSize !== void 0)
            data.dashSize = this.dashSize;
          if (this.gapSize !== void 0)
            data.gapSize = this.gapSize;
          if (this.scale !== void 0)
            data.scale = this.scale;
          if (this.dithering === true)
            data.dithering = true;
          if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
          if (this.alphaToCoverage === true)
            data.alphaToCoverage = this.alphaToCoverage;
          if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
          if (this.wireframe === true)
            data.wireframe = this.wireframe;
          if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== "round")
            data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== "round")
            data.wireframeLinejoin = this.wireframeLinejoin;
          if (this.flatShading === true)
            data.flatShading = this.flatShading;
          if (this.visible === false)
            data.visible = false;
          if (this.toneMapped === false)
            data.toneMapped = false;
          if (JSON.stringify(this.userData) !== "{}")
            data.userData = this.userData;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data2 = cache[key];
              delete data2.metadata;
              values.push(data2);
            }
            return values;
          }
          if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0)
              data.textures = textures;
            if (images.length > 0)
              data.images = images;
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.fog = source.fog;
          this.blending = source.blending;
          this.side = source.side;
          this.vertexColors = source.vertexColors;
          this.opacity = source.opacity;
          this.format = source.format;
          this.transparent = source.transparent;
          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;
          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;
          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;
          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;
          if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for (let i2 = 0; i2 !== n; ++i2) {
              dstPlanes[i2] = srcPlanes[i2].clone();
            }
          }
          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;
          this.shadowSide = source.shadowSide;
          this.colorWrite = source.colorWrite;
          this.precision = source.precision;
          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;
          this.dithering = source.dithering;
          this.alphaTest = source.alphaTest;
          this.alphaToCoverage = source.alphaToCoverage;
          this.premultipliedAlpha = source.premultipliedAlpha;
          this.visible = source.visible;
          this.toneMapped = source.toneMapped;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      }
      Material.prototype.isMaterial = true;
      const _colorKeywords = {
        "aliceblue": 15792383,
        "antiquewhite": 16444375,
        "aqua": 65535,
        "aquamarine": 8388564,
        "azure": 15794175,
        "beige": 16119260,
        "bisque": 16770244,
        "black": 0,
        "blanchedalmond": 16772045,
        "blue": 255,
        "blueviolet": 9055202,
        "brown": 10824234,
        "burlywood": 14596231,
        "cadetblue": 6266528,
        "chartreuse": 8388352,
        "chocolate": 13789470,
        "coral": 16744272,
        "cornflowerblue": 6591981,
        "cornsilk": 16775388,
        "crimson": 14423100,
        "cyan": 65535,
        "darkblue": 139,
        "darkcyan": 35723,
        "darkgoldenrod": 12092939,
        "darkgray": 11119017,
        "darkgreen": 25600,
        "darkgrey": 11119017,
        "darkkhaki": 12433259,
        "darkmagenta": 9109643,
        "darkolivegreen": 5597999,
        "darkorange": 16747520,
        "darkorchid": 10040012,
        "darkred": 9109504,
        "darksalmon": 15308410,
        "darkseagreen": 9419919,
        "darkslateblue": 4734347,
        "darkslategray": 3100495,
        "darkslategrey": 3100495,
        "darkturquoise": 52945,
        "darkviolet": 9699539,
        "deeppink": 16716947,
        "deepskyblue": 49151,
        "dimgray": 6908265,
        "dimgrey": 6908265,
        "dodgerblue": 2003199,
        "firebrick": 11674146,
        "floralwhite": 16775920,
        "forestgreen": 2263842,
        "fuchsia": 16711935,
        "gainsboro": 14474460,
        "ghostwhite": 16316671,
        "gold": 16766720,
        "goldenrod": 14329120,
        "gray": 8421504,
        "green": 32768,
        "greenyellow": 11403055,
        "grey": 8421504,
        "honeydew": 15794160,
        "hotpink": 16738740,
        "indianred": 13458524,
        "indigo": 4915330,
        "ivory": 16777200,
        "khaki": 15787660,
        "lavender": 15132410,
        "lavenderblush": 16773365,
        "lawngreen": 8190976,
        "lemonchiffon": 16775885,
        "lightblue": 11393254,
        "lightcoral": 15761536,
        "lightcyan": 14745599,
        "lightgoldenrodyellow": 16448210,
        "lightgray": 13882323,
        "lightgreen": 9498256,
        "lightgrey": 13882323,
        "lightpink": 16758465,
        "lightsalmon": 16752762,
        "lightseagreen": 2142890,
        "lightskyblue": 8900346,
        "lightslategray": 7833753,
        "lightslategrey": 7833753,
        "lightsteelblue": 11584734,
        "lightyellow": 16777184,
        "lime": 65280,
        "limegreen": 3329330,
        "linen": 16445670,
        "magenta": 16711935,
        "maroon": 8388608,
        "mediumaquamarine": 6737322,
        "mediumblue": 205,
        "mediumorchid": 12211667,
        "mediumpurple": 9662683,
        "mediumseagreen": 3978097,
        "mediumslateblue": 8087790,
        "mediumspringgreen": 64154,
        "mediumturquoise": 4772300,
        "mediumvioletred": 13047173,
        "midnightblue": 1644912,
        "mintcream": 16121850,
        "mistyrose": 16770273,
        "moccasin": 16770229,
        "navajowhite": 16768685,
        "navy": 128,
        "oldlace": 16643558,
        "olive": 8421376,
        "olivedrab": 7048739,
        "orange": 16753920,
        "orangered": 16729344,
        "orchid": 14315734,
        "palegoldenrod": 15657130,
        "palegreen": 10025880,
        "paleturquoise": 11529966,
        "palevioletred": 14381203,
        "papayawhip": 16773077,
        "peachpuff": 16767673,
        "peru": 13468991,
        "pink": 16761035,
        "plum": 14524637,
        "powderblue": 11591910,
        "purple": 8388736,
        "rebeccapurple": 6697881,
        "red": 16711680,
        "rosybrown": 12357519,
        "royalblue": 4286945,
        "saddlebrown": 9127187,
        "salmon": 16416882,
        "sandybrown": 16032864,
        "seagreen": 3050327,
        "seashell": 16774638,
        "sienna": 10506797,
        "silver": 12632256,
        "skyblue": 8900331,
        "slateblue": 6970061,
        "slategray": 7372944,
        "slategrey": 7372944,
        "snow": 16775930,
        "springgreen": 65407,
        "steelblue": 4620980,
        "tan": 13808780,
        "teal": 32896,
        "thistle": 14204888,
        "tomato": 16737095,
        "turquoise": 4251856,
        "violet": 15631086,
        "wheat": 16113331,
        "white": 16777215,
        "whitesmoke": 16119285,
        "yellow": 16776960,
        "yellowgreen": 10145074
      };
      const _hslA = {
        h: 0,
        s: 0,
        l: 0
      };
      const _hslB = {
        h: 0,
        s: 0,
        l: 0
      };
      function hue2rgb(p, q, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p + (q - p) * 6 * t2;
        if (t2 < 1 / 2)
          return q;
        if (t2 < 2 / 3)
          return p + (q - p) * 6 * (2 / 3 - t2);
        return p;
      }
      function SRGBToLinear(c) {
        return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
      }
      function LinearToSRGB(c) {
        return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
      }
      class Color {
        constructor(r2, g, b) {
          if (g === void 0 && b === void 0) {
            return this.set(r2);
          }
          return this.setRGB(r2, g, b);
        }
        set(value) {
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === "number") {
            this.setHex(value);
          } else if (typeof value === "string") {
            this.setStyle(value);
          }
          return this;
        }
        setScalar(scalar) {
          this.r = scalar;
          this.g = scalar;
          this.b = scalar;
          return this;
        }
        setHex(hex) {
          hex = Math.floor(hex);
          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;
          return this;
        }
        setRGB(r2, g, b) {
          this.r = r2;
          this.g = g;
          this.b = b;
          return this;
        }
        setHSL(h2, s3, l) {
          h2 = euclideanModulo(h2, 1);
          s3 = clamp(s3, 0, 1);
          l = clamp(l, 0, 1);
          if (s3 === 0) {
            this.r = this.g = this.b = l;
          } else {
            const p = l <= 0.5 ? l * (1 + s3) : l + s3 - l * s3;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h2 + 1 / 3);
            this.g = hue2rgb(q, p, h2);
            this.b = hue2rgb(q, p, h2 - 1 / 3);
          }
          return this;
        }
        setStyle(style) {
          function handleAlpha(string) {
            if (string === void 0)
              return;
            if (parseFloat(string) < 1) {
              console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
          }
          let m2;
          if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            let color;
            const name = m2[1];
            const components = m2[2];
            switch (name) {
              case "rgb":
              case "rgba":
                if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                  this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                  this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                  handleAlpha(color[4]);
                  return this;
                }
                if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                  this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                  this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                  handleAlpha(color[4]);
                  return this;
                }
                break;
              case "hsl":
              case "hsla":
                if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  const h2 = parseFloat(color[1]) / 360;
                  const s3 = parseInt(color[2], 10) / 100;
                  const l = parseInt(color[3], 10) / 100;
                  handleAlpha(color[4]);
                  return this.setHSL(h2, s3, l);
                }
                break;
            }
          } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            const hex = m2[1];
            const size = hex.length;
            if (size === 3) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
              this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
              this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
              return this;
            } else if (size === 6) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
              this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
              this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
              return this;
            }
          }
          if (style && style.length > 0) {
            return this.setColorName(style);
          }
          return this;
        }
        setColorName(style) {
          const hex = _colorKeywords[style.toLowerCase()];
          if (hex !== void 0) {
            this.setHex(hex);
          } else {
            console.warn("THREE.Color: Unknown color " + style);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          return this;
        }
        copyGammaToLinear(color, gammaFactor = 2) {
          this.r = Math.pow(color.r, gammaFactor);
          this.g = Math.pow(color.g, gammaFactor);
          this.b = Math.pow(color.b, gammaFactor);
          return this;
        }
        copyLinearToGamma(color, gammaFactor = 2) {
          const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
          this.r = Math.pow(color.r, safeInverse);
          this.g = Math.pow(color.g, safeInverse);
          this.b = Math.pow(color.b, safeInverse);
          return this;
        }
        convertGammaToLinear(gammaFactor) {
          this.copyGammaToLinear(this, gammaFactor);
          return this;
        }
        convertLinearToGamma(gammaFactor) {
          this.copyLinearToGamma(this, gammaFactor);
          return this;
        }
        copySRGBToLinear(color) {
          this.r = SRGBToLinear(color.r);
          this.g = SRGBToLinear(color.g);
          this.b = SRGBToLinear(color.b);
          return this;
        }
        copyLinearToSRGB(color) {
          this.r = LinearToSRGB(color.r);
          this.g = LinearToSRGB(color.g);
          this.b = LinearToSRGB(color.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex() {
          return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(target) {
          const r2 = this.r, g = this.g, b = this.b;
          const max = Math.max(r2, g, b);
          const min = Math.min(r2, g, b);
          let hue, saturation;
          const lightness = (min + max) / 2;
          if (min === max) {
            hue = 0;
            saturation = 0;
          } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
              case r2:
                hue = (g - b) / delta + (g < b ? 6 : 0);
                break;
              case g:
                hue = (b - r2) / delta + 2;
                break;
              case b:
                hue = (r2 - g) / delta + 4;
                break;
            }
            hue /= 6;
          }
          target.h = hue;
          target.s = saturation;
          target.l = lightness;
          return target;
        }
        getStyle() {
          return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
        }
        offsetHSL(h2, s3, l) {
          this.getHSL(_hslA);
          _hslA.h += h2;
          _hslA.s += s3;
          _hslA.l += l;
          this.setHSL(_hslA.h, _hslA.s, _hslA.l);
          return this;
        }
        add(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          return this;
        }
        addColors(color1, color2) {
          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;
          return this;
        }
        addScalar(s3) {
          this.r += s3;
          this.g += s3;
          this.b += s3;
          return this;
        }
        sub(color) {
          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);
          return this;
        }
        multiply(color) {
          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;
          return this;
        }
        multiplyScalar(s3) {
          this.r *= s3;
          this.g *= s3;
          this.b *= s3;
          return this;
        }
        lerp(color, alpha) {
          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;
          return this;
        }
        lerpColors(color1, color2, alpha) {
          this.r = color1.r + (color2.r - color1.r) * alpha;
          this.g = color1.g + (color2.g - color1.g) * alpha;
          this.b = color1.b + (color2.b - color1.b) * alpha;
          return this;
        }
        lerpHSL(color, alpha) {
          this.getHSL(_hslA);
          color.getHSL(_hslB);
          const h2 = lerp(_hslA.h, _hslB.h, alpha);
          const s3 = lerp(_hslA.s, _hslB.s, alpha);
          const l = lerp(_hslA.l, _hslB.l, alpha);
          this.setHSL(h2, s3, l);
          return this;
        }
        equals(c) {
          return c.r === this.r && c.g === this.g && c.b === this.b;
        }
        fromArray(array, offset = 0) {
          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.r = attribute.getX(index);
          this.g = attribute.getY(index);
          this.b = attribute.getZ(index);
          if (attribute.normalized === true) {
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
          }
          return this;
        }
        toJSON() {
          return this.getHex();
        }
      }
      Color.NAMES = _colorKeywords;
      Color.prototype.isColor = true;
      Color.prototype.r = 1;
      Color.prototype.g = 1;
      Color.prototype.b = 1;
      class MeshBasicMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshBasicMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      }
      MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
      const _vector$9 = /* @__PURE__ */ new Vector34();
      const _vector2$1 = /* @__PURE__ */ new Vector2();
      class BufferAttribute {
        constructor(array, itemSize, normalized) {
          if (Array.isArray(array)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.name = "";
          this.array = array;
          this.itemSize = itemSize;
          this.count = array !== void 0 ? array.length / itemSize : 0;
          this.normalized = normalized === true;
          this.usage = StaticDrawUsage;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.itemSize;
          index2 *= attribute.itemSize;
          for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        copyArray(array) {
          this.array.set(array);
          return this;
        }
        copyColorsArray(colors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = colors.length; i2 < l; i2++) {
            let color = colors[i2];
            if (color === void 0) {
              console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
              color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
          }
          return this;
        }
        copyVector2sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
              vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
          }
          return this;
        }
        copyVector3sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
              vector = new Vector34();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
          }
          return this;
        }
        copyVector4sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
              vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
          }
          return this;
        }
        applyMatrix3(m2) {
          if (this.itemSize === 2) {
            for (let i2 = 0, l = this.count; i2 < l; i2++) {
              _vector2$1.fromBufferAttribute(this, i2);
              _vector2$1.applyMatrix3(m2);
              this.setXY(i2, _vector2$1.x, _vector2$1.y);
            }
          } else if (this.itemSize === 3) {
            for (let i2 = 0, l = this.count; i2 < l; i2++) {
              _vector$9.fromBufferAttribute(this, i2);
              _vector$9.applyMatrix3(m2);
              this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
            }
          }
          return this;
        }
        applyMatrix4(m2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.applyMatrix4(m2);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        applyNormalMatrix(m2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.applyNormalMatrix(m2);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        transformDirection(m2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.transformDirection(m2);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        getX(index) {
          return this.array[index * this.itemSize];
        }
        setX(index, x2) {
          this.array[index * this.itemSize] = x2;
          return this;
        }
        getY(index) {
          return this.array[index * this.itemSize + 1];
        }
        setY(index, y) {
          this.array[index * this.itemSize + 1] = y;
          return this;
        }
        getZ(index) {
          return this.array[index * this.itemSize + 2];
        }
        setZ(index, z) {
          this.array[index * this.itemSize + 2] = z;
          return this;
        }
        getW(index) {
          return this.array[index * this.itemSize + 3];
        }
        setW(index, w) {
          this.array[index * this.itemSize + 3] = w;
          return this;
        }
        setXY(index, x2, y) {
          index *= this.itemSize;
          this.array[index + 0] = x2;
          this.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x2, y, z) {
          index *= this.itemSize;
          this.array[index + 0] = x2;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x2, y, z, w) {
          index *= this.itemSize;
          this.array[index + 0] = x2;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          this.array[index + 3] = w;
          return this;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
          };
          if (this.name !== "")
            data.name = this.name;
          if (this.usage !== StaticDrawUsage)
            data.usage = this.usage;
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
            data.updateRange = this.updateRange;
          return data;
        }
      }
      BufferAttribute.prototype.isBufferAttribute = true;
      class Int8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int8Array(array), itemSize, normalized);
        }
      }
      class Uint8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8Array(array), itemSize, normalized);
        }
      }
      class Uint8ClampedBufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8ClampedArray(array), itemSize, normalized);
        }
      }
      class Int16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int16Array(array), itemSize, normalized);
        }
      }
      class Uint16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      }
      class Int32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int32Array(array), itemSize, normalized);
        }
      }
      class Uint32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint32Array(array), itemSize, normalized);
        }
      }
      class Float16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      }
      Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
      class Float32BufferAttribute2 extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float32Array(array), itemSize, normalized);
        }
      }
      class Float64BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float64Array(array), itemSize, normalized);
        }
      }
      let _id = 0;
      const _m1 = /* @__PURE__ */ new Matrix4();
      const _obj = /* @__PURE__ */ new Object3D2();
      const _offset = /* @__PURE__ */ new Vector34();
      const _box$1 = /* @__PURE__ */ new Box3();
      const _boxMorphTargets = /* @__PURE__ */ new Box3();
      const _vector$8 = /* @__PURE__ */ new Vector34();
      class BufferGeometry3 extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _id++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = {
            start: 0,
            count: Infinity
          };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(index) {
          if (Array.isArray(index)) {
            this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
          } else {
            this.index = index;
          }
          return this;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        setAttribute(name, attribute) {
          this.attributes[name] = attribute;
          return this;
        }
        deleteAttribute(name) {
          delete this.attributes[name];
          return this;
        }
        hasAttribute(name) {
          return this.attributes[name] !== void 0;
        }
        addGroup(start, count, materialIndex = 0) {
          this.groups.push({
            start,
            count,
            materialIndex
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(start, count) {
          this.drawRange.start = start;
          this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
          const position2 = this.attributes.position;
          if (position2 !== void 0) {
            position2.applyMatrix4(matrix);
            position2.needsUpdate = true;
          }
          const normal = this.attributes.normal;
          if (normal !== void 0) {
            const normalMatrix = new Matrix32().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
          }
          const tangent = this.attributes.tangent;
          if (tangent !== void 0) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(q) {
          _m1.makeRotationFromQuaternion(q);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateX(angle) {
          _m1.makeRotationX(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateY(angle) {
          _m1.makeRotationY(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateZ(angle) {
          _m1.makeRotationZ(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        translate(x2, y, z) {
          _m1.makeTranslation(x2, y, z);
          this.applyMatrix4(_m1);
          return this;
        }
        scale(x2, y, z) {
          _m1.makeScale(x2, y, z);
          this.applyMatrix4(_m1);
          return this;
        }
        lookAt(vector) {
          _obj.lookAt(vector);
          _obj.updateMatrix();
          this.applyMatrix4(_obj.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(_offset).negate();
          this.translate(_offset.x, _offset.y, _offset.z);
          return this;
        }
        setFromPoints(points) {
          const position2 = [];
          for (let i2 = 0, l = points.length; i2 < l; i2++) {
            const point = points[i2];
            position2.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute("position", new Float32BufferAttribute2(position2, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          const position2 = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position2 && position2.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector34(-Infinity, -Infinity, -Infinity), new Vector34(Infinity, Infinity, Infinity));
            return;
          }
          if (position2 !== void 0) {
            this.boundingBox.setFromBufferAttribute(position2);
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                  this.boundingBox.expandByPoint(_vector$8);
                  _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                  this.boundingBox.expandByPoint(_vector$8);
                } else {
                  this.boundingBox.expandByPoint(_box$1.min);
                  this.boundingBox.expandByPoint(_box$1.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          const position2 = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position2 && position2.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector34(), Infinity);
            return;
          }
          if (position2) {
            const center = this.boundingSphere.center;
            _box$1.setFromBufferAttribute(position2);
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                  _box$1.expandByPoint(_vector$8);
                  _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                  _box$1.expandByPoint(_vector$8);
                } else {
                  _box$1.expandByPoint(_boxMorphTargets.min);
                  _box$1.expandByPoint(_boxMorphTargets.max);
                }
              }
            }
            _box$1.getCenter(center);
            let maxRadiusSq = 0;
            for (let i2 = 0, il = position2.count; i2 < il; i2++) {
              _vector$8.fromBufferAttribute(position2, i2);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                const morphTargetsRelative = this.morphTargetsRelative;
                for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                  _vector$8.fromBufferAttribute(morphAttribute, j);
                  if (morphTargetsRelative) {
                    _offset.fromBufferAttribute(position2, j);
                    _vector$8.add(_offset);
                  }
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        }
        computeTangents() {
          const index = this.index;
          const attributes = this.attributes;
          if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const indices = index.array;
          const positions = attributes.position.array;
          const normals = attributes.normal.array;
          const uvs = attributes.uv.array;
          const nVertices = positions.length / 3;
          if (attributes.tangent === void 0) {
            this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
          }
          const tangents = attributes.tangent.array;
          const tan1 = [], tan2 = [];
          for (let i2 = 0; i2 < nVertices; i2++) {
            tan1[i2] = new Vector34();
            tan2[i2] = new Vector34();
          }
          const vA = new Vector34(), vB = new Vector34(), vC = new Vector34(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector34(), tdir = new Vector34();
          function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            if (!isFinite(r2))
              return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
          }
          let groups = this.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.length
            }];
          }
          for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
            }
          }
          const tmp2 = new Vector34(), tmp22 = new Vector34();
          const n = new Vector34(), n2 = new Vector34();
          function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t2 = tan1[v];
            tmp2.copy(t2);
            tmp2.sub(n.multiplyScalar(n.dot(t2))).normalize();
            tmp22.crossVectors(n2, t2);
            const test = tmp22.dot(tan2[v]);
            const w = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp2.x;
            tangents[v * 4 + 1] = tmp2.y;
            tangents[v * 4 + 2] = tmp2.z;
            tangents[v * 4 + 3] = w;
          }
          for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleVertex(indices[j + 0]);
              handleVertex(indices[j + 1]);
              handleVertex(indices[j + 2]);
            }
          }
        }
        computeVertexNormals() {
          const index = this.index;
          const positionAttribute = this.getAttribute("position");
          if (positionAttribute !== void 0) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === void 0) {
              normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
              this.setAttribute("normal", normalAttribute);
            } else {
              for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
                normalAttribute.setXYZ(i2, 0, 0, 0);
              }
            }
            const pA = new Vector34(), pB = new Vector34(), pC = new Vector34();
            const nA = new Vector34(), nB = new Vector34(), nC = new Vector34();
            const cb = new Vector34(), ab = new Vector34();
            if (index) {
              for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
                const vA = index.getX(i2 + 0);
                const vB = index.getX(i2 + 1);
                const vC = index.getX(i2 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
              }
            } else {
              for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
                pA.fromBufferAttribute(positionAttribute, i2 + 0);
                pB.fromBufferAttribute(positionAttribute, i2 + 1);
                pC.fromBufferAttribute(positionAttribute, i2 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
              }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
          }
        }
        merge(geometry2, offset) {
          if (!(geometry2 && geometry2.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry2);
            return;
          }
          if (offset === void 0) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            if (geometry2.attributes[key] === void 0)
              continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry2.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for (let i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
              attributeArray1[j] = attributeArray2[i2];
            }
          }
          return this;
        }
        normalizeNormals() {
          const normals = this.attributes.normal;
          for (let i2 = 0, il = normals.count; i2 < il; i2++) {
            _vector$8.fromBufferAttribute(normals, i2);
            _vector$8.normalize();
            normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
          }
        }
        toNonIndexed() {
          function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index = 0, index2 = 0;
            for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
              if (attribute.isInterleavedBufferAttribute) {
                index = indices2[i2] * attribute.data.stride + attribute.offset;
              } else {
                index = indices2[i2] * itemSize;
              }
              for (let j = 0; j < itemSize; j++) {
                array2[index2++] = array[index++];
              }
            }
            return new BufferAttribute(array2, itemSize, normalized);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const geometry2 = new BufferGeometry3();
          const indices = this.index.array;
          const attributes = this.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
          }
          const morphAttributes = this.morphAttributes;
          for (const name in morphAttributes) {
            const morphArray = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
              const attribute = morphAttribute[i2];
              const newAttribute = convertBufferAttribute(attribute, indices);
              morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
          }
          geometry2.morphTargetsRelative = this.morphTargetsRelative;
          const groups = this.groups;
          for (let i2 = 0, l = groups.length; i2 < l; i2++) {
            const group = groups[i2];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
          }
          return geometry2;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          if (this.parameters !== void 0) {
            const parameters = this.parameters;
            for (const key in parameters) {
              if (parameters[key] !== void 0)
                data[key] = parameters[key];
            }
            return data;
          }
          data.data = {
            attributes: {}
          };
          const index = this.index;
          if (index !== null) {
            data.data.index = {
              type: index.array.constructor.name,
              array: Array.prototype.slice.call(index.array)
            };
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
          }
          const morphAttributes = {};
          let hasMorphAttributes = false;
          for (const key in this.morphAttributes) {
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
              const attribute = attributeArray[i2];
              array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
              morphAttributes[key] = array;
              hasMorphAttributes = true;
            }
          }
          if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const groups = this.groups;
          if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
          }
          const boundingSphere = this.boundingSphere;
          if (boundingSphere !== null) {
            data.data.boundingSphere = {
              center: boundingSphere.center.toArray(),
              radius: boundingSphere.radius
            };
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const data = {};
          this.name = source.name;
          const index = source.index;
          if (index !== null) {
            this.setIndex(index.clone(data));
          }
          const attributes = source.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
          }
          const morphAttributes = source.morphAttributes;
          for (const name in morphAttributes) {
            const array = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
              array.push(morphAttribute[i2].clone(data));
            }
            this.morphAttributes[name] = array;
          }
          this.morphTargetsRelative = source.morphTargetsRelative;
          const groups = source.groups;
          for (let i2 = 0, l = groups.length; i2 < l; i2++) {
            const group = groups[i2];
            this.addGroup(group.start, group.count, group.materialIndex);
          }
          const boundingBox = source.boundingBox;
          if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
          }
          const boundingSphere = source.boundingSphere;
          if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
          }
          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;
          this.userData = source.userData;
          if (source.parameters !== void 0)
            this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      BufferGeometry3.prototype.isBufferGeometry = true;
      const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
      const _ray$2 = /* @__PURE__ */ new Ray();
      const _sphere$3 = /* @__PURE__ */ new Sphere();
      const _vA$1 = /* @__PURE__ */ new Vector34();
      const _vB$1 = /* @__PURE__ */ new Vector34();
      const _vC$1 = /* @__PURE__ */ new Vector34();
      const _tempA = /* @__PURE__ */ new Vector34();
      const _tempB = /* @__PURE__ */ new Vector34();
      const _tempC = /* @__PURE__ */ new Vector34();
      const _morphA = /* @__PURE__ */ new Vector34();
      const _morphB = /* @__PURE__ */ new Vector34();
      const _morphC = /* @__PURE__ */ new Vector34();
      const _uvA$1 = /* @__PURE__ */ new Vector2();
      const _uvB$1 = /* @__PURE__ */ new Vector2();
      const _uvC$1 = /* @__PURE__ */ new Vector2();
      const _intersectionPoint = /* @__PURE__ */ new Vector34();
      const _intersectionPointWorld = /* @__PURE__ */ new Vector34();
      class Mesh3 extends Object3D2 {
        constructor(geometry2 = new BufferGeometry3(), material2 = new MeshBasicMaterial()) {
          super();
          this.type = "Mesh";
          this.geometry = geometry2;
          this.material = material2;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          if (source.morphTargetInfluences !== void 0) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
          }
          if (source.morphTargetDictionary !== void 0) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
          }
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        updateMorphTargets() {
          const geometry2 = this.geometry;
          if (geometry2.isBufferGeometry) {
            const morphAttributes = geometry2.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                  const name = morphAttribute[m2].name || String(m2);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m2;
                }
              }
            }
          } else {
            const morphTargets = geometry2.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
        raycast(raycaster, intersects2) {
          const geometry2 = this.geometry;
          const material2 = this.material;
          const matrixWorld = this.matrixWorld;
          if (material2 === void 0)
            return;
          if (geometry2.boundingSphere === null)
            geometry2.computeBoundingSphere();
          _sphere$3.copy(geometry2.boundingSphere);
          _sphere$3.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$3) === false)
            return;
          _inverseMatrix$2.copy(matrixWorld).invert();
          _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
          if (geometry2.boundingBox !== null) {
            if (_ray$2.intersectsBox(geometry2.boundingBox) === false)
              return;
          }
          let intersection;
          if (geometry2.isBufferGeometry) {
            const index = geometry2.index;
            const position2 = geometry2.attributes.position;
            const morphPosition = geometry2.morphAttributes.position;
            const morphTargetsRelative = geometry2.morphTargetsRelative;
            const uv = geometry2.attributes.uv;
            const uv2 = geometry2.attributes.uv2;
            const groups = geometry2.groups;
            const drawRange = geometry2.drawRange;
            if (index !== null) {
              if (Array.isArray(material2)) {
                for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material2[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = index.getX(j);
                    const b = index.getX(j + 1);
                    const c = index.getX(j + 2);
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for (let i2 = start, il = end; i2 < il; i2 += 3) {
                  const a = index.getX(i2);
                  const b = index.getX(i2 + 1);
                  const c = index.getX(i2 + 2);
                  intersection = checkBufferGeometryIntersection(this, material2, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            } else if (position2 !== void 0) {
              if (Array.isArray(material2)) {
                for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material2[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(position2.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = j;
                    const b = j + 1;
                    const c = j + 2;
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(position2.count, drawRange.start + drawRange.count);
                for (let i2 = start, il = end; i2 < il; i2 += 3) {
                  const a = i2;
                  const b = i2 + 1;
                  const c = i2 + 2;
                  intersection = checkBufferGeometryIntersection(this, material2, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            }
          } else if (geometry2.isGeometry) {
            console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      Mesh3.prototype.isMesh = true;
      function checkIntersection(object, material2, raycaster, ray, pA, pB, pC, point) {
        let intersect;
        if (material2.side === BackSide) {
          intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        } else {
          intersect = ray.intersectTriangle(pA, pB, pC, material2.side !== DoubleSide, point);
        }
        if (intersect === null)
          return null;
        _intersectionPointWorld.copy(point);
        _intersectionPointWorld.applyMatrix4(object.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far)
          return null;
        return {
          distance,
          point: _intersectionPointWorld.clone(),
          object
        };
      }
      function checkBufferGeometryIntersection(object, material2, raycaster, ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
        _vA$1.fromBufferAttribute(position2, a);
        _vB$1.fromBufferAttribute(position2, b);
        _vC$1.fromBufferAttribute(position2, c);
        const morphInfluences = object.morphTargetInfluences;
        if (morphPosition && morphInfluences) {
          _morphA.set(0, 0, 0);
          _morphB.set(0, 0, 0);
          _morphC.set(0, 0, 0);
          for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
            const influence = morphInfluences[i2];
            const morphAttribute = morphPosition[i2];
            if (influence === 0)
              continue;
            _tempA.fromBufferAttribute(morphAttribute, a);
            _tempB.fromBufferAttribute(morphAttribute, b);
            _tempC.fromBufferAttribute(morphAttribute, c);
            if (morphTargetsRelative) {
              _morphA.addScaledVector(_tempA, influence);
              _morphB.addScaledVector(_tempB, influence);
              _morphC.addScaledVector(_tempC, influence);
            } else {
              _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
              _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
              _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
            }
          }
          _vA$1.add(_morphA);
          _vB$1.add(_morphB);
          _vC$1.add(_morphC);
        }
        if (object.isSkinnedMesh) {
          object.boneTransform(a, _vA$1);
          object.boneTransform(b, _vB$1);
          object.boneTransform(c, _vC$1);
        }
        const intersection = checkIntersection(object, material2, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
        if (intersection) {
          if (uv) {
            _uvA$1.fromBufferAttribute(uv, a);
            _uvB$1.fromBufferAttribute(uv, b);
            _uvC$1.fromBufferAttribute(uv, c);
            intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
          }
          if (uv2) {
            _uvA$1.fromBufferAttribute(uv2, a);
            _uvB$1.fromBufferAttribute(uv2, b);
            _uvC$1.fromBufferAttribute(uv2, c);
            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
          }
          const face = {
            a,
            b,
            c,
            normal: new Vector34(),
            materialIndex: 0
          };
          Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
          intersection.face = face;
        }
        return intersection;
      }
      class BoxGeometry extends BufferGeometry3 {
        constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width,
            height,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          };
          const scope = this;
          widthSegments = Math.floor(widthSegments);
          heightSegments = Math.floor(heightSegments);
          depthSegments = Math.floor(depthSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let numberOfVertices = 0;
          let groupStart = 0;
          buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
          buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
          buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
          buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
          buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
          buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
            const segmentWidth = width2 / gridX;
            const segmentHeight = height2 / gridY;
            const widthHalf = width2 / 2;
            const heightHalf = height2 / 2;
            const depthHalf = depth2 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector34();
            for (let iy = 0; iy < gridY1; iy++) {
              const y = iy * segmentHeight - heightHalf;
              for (let ix = 0; ix < gridX1; ix++) {
                const x2 = ix * segmentWidth - widthHalf;
                vector[u] = x2 * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                vertices.push(vector.x, vector.y, vector.z);
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth2 > 0 ? 1 : -1;
                normals.push(vector.x, vector.y, vector.z);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                vertexCounter += 1;
              }
            }
            for (let iy = 0; iy < gridY; iy++) {
              for (let ix = 0; ix < gridX; ix++) {
                const a = numberOfVertices + ix + gridX1 * iy;
                const b = numberOfVertices + ix + gridX1 * (iy + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
          }
        }
        static fromJSON(data) {
          return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
      }
      function cloneUniforms(src) {
        const dst = {};
        for (const u in src) {
          dst[u] = {};
          for (const p in src[u]) {
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
              dst[u][p] = property.clone();
            } else if (Array.isArray(property)) {
              dst[u][p] = property.slice();
            } else {
              dst[u][p] = property;
            }
          }
        }
        return dst;
      }
      function mergeUniforms(uniforms) {
        const merged = {};
        for (let u = 0; u < uniforms.length; u++) {
          const tmp2 = cloneUniforms(uniforms[u]);
          for (const p in tmp2) {
            merged[p] = tmp2[p];
          }
        }
        return merged;
      }
      const UniformsUtils = {
        clone: cloneUniforms,
        merge: mergeUniforms
      };
      var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
      var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      class ShaderMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.vertexShader = default_vertex;
          this.fragmentShader = default_fragment;
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
          };
          this.defaultAttributeValues = {
            "color": [1, 1, 1],
            "uv": [0, 0],
            "uv2": [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (parameters !== void 0) {
            if (parameters.attributes !== void 0) {
              console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
            }
            this.setValues(parameters);
          }
        }
        copy(source) {
          super.copy(source);
          this.fragmentShader = source.fragmentShader;
          this.vertexShader = source.vertexShader;
          this.uniforms = cloneUniforms(source.uniforms);
          this.defines = Object.assign({}, source.defines);
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.lights = source.lights;
          this.clipping = source.clipping;
          this.extensions = Object.assign({}, source.extensions);
          this.glslVersion = source.glslVersion;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.glslVersion = this.glslVersion;
          data.uniforms = {};
          for (const name in this.uniforms) {
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) {
              data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
              };
            } else if (value && value.isColor) {
              data.uniforms[name] = {
                type: "c",
                value: value.getHex()
              };
            } else if (value && value.isVector2) {
              data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
              };
            } else if (value && value.isVector3) {
              data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
              };
            } else if (value && value.isVector4) {
              data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
              };
            } else if (value && value.isMatrix3) {
              data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
              };
            } else if (value && value.isMatrix4) {
              data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
              };
            } else {
              data.uniforms[name] = {
                value
              };
            }
          }
          if (Object.keys(this.defines).length > 0)
            data.defines = this.defines;
          data.vertexShader = this.vertexShader;
          data.fragmentShader = this.fragmentShader;
          const extensions = {};
          for (const key in this.extensions) {
            if (this.extensions[key] === true)
              extensions[key] = true;
          }
          if (Object.keys(extensions).length > 0)
            data.extensions = extensions;
          return data;
        }
      }
      ShaderMaterial.prototype.isShaderMaterial = true;
      class Camera extends Object3D2 {
        constructor() {
          super();
          this.type = "Camera";
          this.matrixWorldInverse = new Matrix4();
          this.projectionMatrix = new Matrix4();
          this.projectionMatrixInverse = new Matrix4();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.matrixWorldInverse.copy(source.matrixWorldInverse);
          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
          return this;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e2 = this.matrixWorld.elements;
          return target.set(-e2[8], -e2[9], -e2[10]).normalize();
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
          super.updateWorldMatrix(updateParents, updateChildren);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Camera.prototype.isCamera = true;
      class PerspectiveCamera2 extends Camera {
        constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
          super();
          this.type = "PerspectiveCamera";
          this.fov = fov2;
          this.zoom = 1;
          this.near = near;
          this.far = far;
          this.focus = 10;
          this.aspect = aspect2;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.fov = source.fov;
          this.zoom = source.zoom;
          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;
          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;
          return this;
        }
        setFocalLength(focalLength) {
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
          this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();
        }
        getFocalLength() {
          const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
          return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(fullWidth, fullHeight, x2, y, width, height) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x2;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const near = this.near;
          let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
          let height = 2 * top;
          let width = this.aspect * height;
          let left = -0.5 * width;
          const view = this.view;
          if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
          }
          const skew = this.filmOffset;
          if (skew !== 0)
            left += near * skew / this.getFilmWidth();
          this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.fov = this.fov;
          data.object.zoom = this.zoom;
          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;
          data.object.aspect = this.aspect;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;
          return data;
        }
      }
      PerspectiveCamera2.prototype.isPerspectiveCamera = true;
      const fov = 90, aspect = 1;
      class CubeCamera extends Object3D2 {
        constructor(near, far, renderTarget) {
          super();
          this.type = "CubeCamera";
          if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return;
          }
          this.renderTarget = renderTarget;
          const cameraPX = new PerspectiveCamera2(fov, aspect, near, far);
          cameraPX.layers = this.layers;
          cameraPX.up.set(0, -1, 0);
          cameraPX.lookAt(new Vector34(1, 0, 0));
          this.add(cameraPX);
          const cameraNX = new PerspectiveCamera2(fov, aspect, near, far);
          cameraNX.layers = this.layers;
          cameraNX.up.set(0, -1, 0);
          cameraNX.lookAt(new Vector34(-1, 0, 0));
          this.add(cameraNX);
          const cameraPY = new PerspectiveCamera2(fov, aspect, near, far);
          cameraPY.layers = this.layers;
          cameraPY.up.set(0, 0, 1);
          cameraPY.lookAt(new Vector34(0, 1, 0));
          this.add(cameraPY);
          const cameraNY = new PerspectiveCamera2(fov, aspect, near, far);
          cameraNY.layers = this.layers;
          cameraNY.up.set(0, 0, -1);
          cameraNY.lookAt(new Vector34(0, -1, 0));
          this.add(cameraNY);
          const cameraPZ = new PerspectiveCamera2(fov, aspect, near, far);
          cameraPZ.layers = this.layers;
          cameraPZ.up.set(0, -1, 0);
          cameraPZ.lookAt(new Vector34(0, 0, 1));
          this.add(cameraPZ);
          const cameraNZ = new PerspectiveCamera2(fov, aspect, near, far);
          cameraNZ.layers = this.layers;
          cameraNZ.up.set(0, -1, 0);
          cameraNZ.lookAt(new Vector34(0, 0, -1));
          this.add(cameraNZ);
        }
        update(renderer, scene) {
          if (this.parent === null)
            this.updateMatrixWorld();
          const renderTarget = this.renderTarget;
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
          const currentXrEnabled = renderer.xr.enabled;
          const currentRenderTarget = renderer.getRenderTarget();
          renderer.xr.enabled = false;
          const generateMipmaps = renderTarget.texture.generateMipmaps;
          renderTarget.texture.generateMipmaps = false;
          renderer.setRenderTarget(renderTarget, 0);
          renderer.render(scene, cameraPX);
          renderer.setRenderTarget(renderTarget, 1);
          renderer.render(scene, cameraNX);
          renderer.setRenderTarget(renderTarget, 2);
          renderer.render(scene, cameraPY);
          renderer.setRenderTarget(renderTarget, 3);
          renderer.render(scene, cameraNY);
          renderer.setRenderTarget(renderTarget, 4);
          renderer.render(scene, cameraPZ);
          renderTarget.texture.generateMipmaps = generateMipmaps;
          renderer.setRenderTarget(renderTarget, 5);
          renderer.render(scene, cameraNZ);
          renderer.setRenderTarget(currentRenderTarget);
          renderer.xr.enabled = currentXrEnabled;
        }
      }
      class CubeTexture extends Texture {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding) {
          images = images !== void 0 ? images : [];
          mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
          super(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(value) {
          this.image = value;
        }
      }
      CubeTexture.prototype.isCubeTexture = true;
      class WebGLCubeRenderTarget extends WebGLRenderTarget {
        constructor(size, options2, dummy) {
          if (Number.isInteger(options2)) {
            console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
            options2 = dummy;
          }
          super(size, size, options2);
          options2 = options2 || {};
          this.texture = new CubeTexture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
          this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
          this.texture._needsFlipEnvMap = false;
        }
        fromEquirectangularTexture(renderer, texture) {
          this.texture.type = texture.type;
          this.texture.format = RGBAFormat;
          this.texture.encoding = texture.encoding;
          this.texture.generateMipmaps = texture.generateMipmaps;
          this.texture.minFilter = texture.minFilter;
          this.texture.magFilter = texture.magFilter;
          const shader = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          };
          const geometry2 = new BoxGeometry(5, 5, 5);
          const material2 = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
          });
          material2.uniforms.tEquirect.value = texture;
          const mesh = new Mesh3(geometry2, material2);
          const currentMinFilter = texture.minFilter;
          if (texture.minFilter === LinearMipmapLinearFilter)
            texture.minFilter = LinearFilter;
          const camera = new CubeCamera(1, 10, this);
          camera.update(renderer, mesh);
          texture.minFilter = currentMinFilter;
          mesh.geometry.dispose();
          mesh.material.dispose();
          return this;
        }
        clear(renderer, color, depth, stencil) {
          const currentRenderTarget = renderer.getRenderTarget();
          for (let i2 = 0; i2 < 6; i2++) {
            renderer.setRenderTarget(this, i2);
            renderer.clear(color, depth, stencil);
          }
          renderer.setRenderTarget(currentRenderTarget);
        }
      }
      WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
      const _vector1 = /* @__PURE__ */ new Vector34();
      const _vector2 = /* @__PURE__ */ new Vector34();
      const _normalMatrix2 = /* @__PURE__ */ new Matrix32();
      class Plane {
        constructor(normal = new Vector34(1, 0, 0), constant = 0) {
          this.normal = normal;
          this.constant = constant;
        }
        set(normal, constant) {
          this.normal.copy(normal);
          this.constant = constant;
          return this;
        }
        setComponents(x2, y, z, w) {
          this.normal.set(x2, y, z);
          this.constant = w;
          return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(a, b, c) {
          const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        }
        copy(plane) {
          this.normal.copy(plane.normal);
          this.constant = plane.constant;
          return this;
        }
        normalize() {
          const inverseNormalLength = 1 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(point) {
          return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
          return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
          return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        }
        intersectLine(line, target) {
          const direction = line.delta(_vector1);
          const denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return target.copy(line.start);
            }
            return null;
          }
          const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t2 < 0 || t2 > 1) {
            return null;
          }
          return target.copy(direction).multiplyScalar(t2).add(line.start);
        }
        intersectsLine(line) {
          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);
          return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        }
        intersectsBox(box) {
          return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
          return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
          return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
          const normalMatrix = optionalNormalMatrix || _normalMatrix2.getNormalMatrix(matrix);
          const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
          const normal = this.normal.applyMatrix3(normalMatrix).normalize();
          this.constant = -referencePoint.dot(normal);
          return this;
        }
        translate(offset) {
          this.constant -= offset.dot(this.normal);
          return this;
        }
        equals(plane) {
          return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Plane.prototype.isPlane = true;
      const _sphere$2 = /* @__PURE__ */ new Sphere();
      const _vector$7 = /* @__PURE__ */ new Vector34();
      class Frustum {
        constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
          this.planes = [p0, p1, p2, p3, p4, p5];
        }
        set(p0, p1, p2, p3, p4, p5) {
          const planes = this.planes;
          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p2);
          planes[3].copy(p3);
          planes[4].copy(p4);
          planes[5].copy(p5);
          return this;
        }
        copy(frustum) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            planes[i2].copy(frustum.planes[i2]);
          }
          return this;
        }
        setFromProjectionMatrix(m2) {
          const planes = this.planes;
          const me = m2.elements;
          const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
          const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
          const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
          const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
          planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
          return this;
        }
        intersectsObject(object) {
          const geometry2 = object.geometry;
          if (geometry2.boundingSphere === null)
            geometry2.computeBoundingSphere();
          _sphere$2.copy(geometry2.boundingSphere).applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSprite(sprite) {
          _sphere$2.center.set(0, 0, 0);
          _sphere$2.radius = 0.7071067811865476;
          _sphere$2.applyMatrix4(sprite.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSphere(sphere) {
          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;
          for (let i2 = 0; i2 < 6; i2++) {
            const distance = planes[i2].distanceToPoint(center);
            if (distance < negRadius) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(box) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            const plane = planes[i2];
            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$7) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(point) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            if (planes[i2].distanceToPoint(point) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function WebGLAnimation() {
        let context = null;
        let isAnimating = false;
        let animationLoop = null;
        let requestId = null;
        function onAnimationFrame(time, frame) {
          animationLoop(time, frame);
          requestId = context.requestAnimationFrame(onAnimationFrame);
        }
        return {
          start: function() {
            if (isAnimating === true)
              return;
            if (animationLoop === null)
              return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
          },
          stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
          },
          setAnimationLoop: function(callback) {
            animationLoop = callback;
          },
          setContext: function(value) {
            context = value;
          }
        };
      }
      function WebGLAttributes(gl, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        const buffers = new WeakMap();
        function createBuffer(attribute, bufferType) {
          const array = attribute.array;
          const usage = attribute.usage;
          const buffer = gl.createBuffer();
          gl.bindBuffer(bufferType, buffer);
          gl.bufferData(bufferType, array, usage);
          attribute.onUploadCallback();
          let type = gl.FLOAT;
          if (array instanceof Float32Array) {
            type = gl.FLOAT;
          } else if (array instanceof Float64Array) {
            console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
          } else if (array instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
              if (isWebGL2) {
                type = gl.HALF_FLOAT;
              } else {
                console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
              }
            } else {
              type = gl.UNSIGNED_SHORT;
            }
          } else if (array instanceof Int16Array) {
            type = gl.SHORT;
          } else if (array instanceof Uint32Array) {
            type = gl.UNSIGNED_INT;
          } else if (array instanceof Int32Array) {
            type = gl.INT;
          } else if (array instanceof Int8Array) {
            type = gl.BYTE;
          } else if (array instanceof Uint8Array) {
            type = gl.UNSIGNED_BYTE;
          } else if (array instanceof Uint8ClampedArray) {
            type = gl.UNSIGNED_BYTE;
          }
          return {
            buffer,
            type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
          };
        }
        function updateBuffer(buffer, attribute, bufferType) {
          const array = attribute.array;
          const updateRange = attribute.updateRange;
          gl.bindBuffer(bufferType, buffer);
          if (updateRange.count === -1) {
            gl.bufferSubData(bufferType, 0, array);
          } else {
            if (isWebGL2) {
              gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            } else {
              gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            }
            updateRange.count = -1;
          }
        }
        function get(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          return buffers.get(attribute);
        }
        function remove(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
          }
        }
        function update(attribute, bufferType) {
          if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) {
              buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
              });
            }
            return;
          }
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data === void 0) {
            buffers.set(attribute, createBuffer(attribute, bufferType));
          } else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
          }
        }
        return {
          get,
          remove,
          update
        };
      }
      class PlaneGeometry2 extends BufferGeometry3 {
        constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width,
            height,
            widthSegments,
            heightSegments
          };
          const width_half = width / 2;
          const height_half = height / 2;
          const gridX = Math.floor(widthSegments);
          const gridY = Math.floor(heightSegments);
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          const segment_width = width / gridX;
          const segment_height = height / gridY;
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy < gridY1; iy++) {
            const y = iy * segment_height - height_half;
            for (let ix = 0; ix < gridX1; ix++) {
              const x2 = ix * segment_width - width_half;
              vertices.push(x2, -y, 0);
              normals.push(0, 0, 1);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = ix + gridX1 * iy;
              const b = ix + gridX1 * (iy + 1);
              const c = ix + 1 + gridX1 * (iy + 1);
              const d = ix + 1 + gridX1 * iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new PlaneGeometry2(data.width, data.height, data.widthSegments, data.heightSegments);
        }
      }
      var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
      var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
      var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
      var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
      var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
      var begin_vertex = "vec3 transformed = vec3( position );";
      var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
      var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
      var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
      var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
      var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
      var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
      var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
      var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
      var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
      var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
      var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
      var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
      var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
      var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
      var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
      var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
      var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
      var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}";
      var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
      var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
      var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
      var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
      var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
      var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
      var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
      var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
      var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
      var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
      var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
      var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
      var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
      var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
      var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
      var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
      var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
      var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
      var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
      var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
      var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(		0, 1,		0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
      var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
      var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
      var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
      var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
      var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
      var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
      var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
      var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
      var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
      var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
      var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
      var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
      var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
      var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
      var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
      var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
      var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
      var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
      var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
      var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
      var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
      var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
      var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
      var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
      var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
      var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
      var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
      var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
      var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
      var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
      var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n							f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n							f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
      var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
      var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
      var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
      var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
      var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
      var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
      var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
      var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
      var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
      var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,	1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
      var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
      var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
      var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
      var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
      var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
      var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
      var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
      var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
      var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
      const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
      const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
      const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
      const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
      const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
      const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
      const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
      const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
      const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
      const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
      const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
      const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
      const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      const ShaderChunk = {
        alphamap_fragment,
        alphamap_pars_fragment,
        alphatest_fragment,
        alphatest_pars_fragment,
        aomap_fragment,
        aomap_pars_fragment,
        begin_vertex,
        beginnormal_vertex,
        bsdfs,
        bumpmap_pars_fragment,
        clipping_planes_fragment,
        clipping_planes_pars_fragment,
        clipping_planes_pars_vertex,
        clipping_planes_vertex,
        color_fragment,
        color_pars_fragment,
        color_pars_vertex,
        color_vertex,
        common,
        cube_uv_reflection_fragment,
        defaultnormal_vertex,
        displacementmap_pars_vertex,
        displacementmap_vertex,
        emissivemap_fragment,
        emissivemap_pars_fragment,
        encodings_fragment,
        encodings_pars_fragment,
        envmap_fragment,
        envmap_common_pars_fragment,
        envmap_pars_fragment,
        envmap_pars_vertex,
        envmap_physical_pars_fragment,
        envmap_vertex,
        fog_vertex,
        fog_pars_vertex,
        fog_fragment,
        fog_pars_fragment,
        gradientmap_pars_fragment,
        lightmap_fragment,
        lightmap_pars_fragment,
        lights_lambert_vertex,
        lights_pars_begin,
        lights_toon_fragment,
        lights_toon_pars_fragment,
        lights_phong_fragment,
        lights_phong_pars_fragment,
        lights_physical_fragment,
        lights_physical_pars_fragment,
        lights_fragment_begin,
        lights_fragment_maps,
        lights_fragment_end,
        logdepthbuf_fragment,
        logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex,
        logdepthbuf_vertex,
        map_fragment,
        map_pars_fragment,
        map_particle_fragment,
        map_particle_pars_fragment,
        metalnessmap_fragment,
        metalnessmap_pars_fragment,
        morphnormal_vertex,
        morphtarget_pars_vertex,
        morphtarget_vertex,
        normal_fragment_begin,
        normal_fragment_maps,
        normal_pars_fragment,
        normal_pars_vertex,
        normal_vertex,
        normalmap_pars_fragment,
        clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment,
        output_fragment,
        packing,
        premultiplied_alpha_fragment,
        project_vertex,
        dithering_fragment,
        dithering_pars_fragment,
        roughnessmap_fragment,
        roughnessmap_pars_fragment,
        shadowmap_pars_fragment,
        shadowmap_pars_vertex,
        shadowmap_vertex,
        shadowmask_pars_fragment,
        skinbase_vertex,
        skinning_pars_vertex,
        skinning_vertex,
        skinnormal_vertex,
        specularmap_fragment,
        specularmap_pars_fragment,
        tonemapping_fragment,
        tonemapping_pars_fragment,
        transmission_fragment,
        transmission_pars_fragment,
        uv_pars_fragment,
        uv_pars_vertex,
        uv_vertex,
        uv2_pars_fragment,
        uv2_pars_vertex,
        uv2_vertex,
        worldpos_vertex,
        background_vert: vertex$g,
        background_frag: fragment$g,
        cube_vert: vertex$f,
        cube_frag: fragment$f,
        depth_vert: vertex$e,
        depth_frag: fragment$e,
        distanceRGBA_vert: vertex$d,
        distanceRGBA_frag: fragment$d,
        equirect_vert: vertex$c,
        equirect_frag: fragment$c,
        linedashed_vert: vertex$b,
        linedashed_frag: fragment$b,
        meshbasic_vert: vertex$a,
        meshbasic_frag: fragment$a,
        meshlambert_vert: vertex$9,
        meshlambert_frag: fragment$9,
        meshmatcap_vert: vertex$8,
        meshmatcap_frag: fragment$8,
        meshnormal_vert: vertex$7,
        meshnormal_frag: fragment$7,
        meshphong_vert: vertex$6,
        meshphong_frag: fragment$6,
        meshphysical_vert: vertex$5,
        meshphysical_frag: fragment$5,
        meshtoon_vert: vertex$4,
        meshtoon_frag: fragment$4,
        points_vert: vertex$3,
        points_frag: fragment$3,
        shadow_vert: vertex$2,
        shadow_frag: fragment$2,
        sprite_vert: vertex$1,
        sprite_frag: fragment$1
      };
      const UniformsLib = {
        common: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          uvTransform: {
            value: new Matrix32()
          },
          uv2Transform: {
            value: new Matrix32()
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalScale: {
            value: new Vector2(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new Color(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotShadowMap: {
            value: []
          },
          spotShadowMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Matrix32()
          }
        },
        sprite: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new Vector2(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Matrix32()
          }
        }
      };
      const ShaderLib = {
        basic: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
          vertexShader: ShaderChunk.meshbasic_vert,
          fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            }
          }]),
          vertexShader: ShaderChunk.meshlambert_vert,
          fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            },
            specular: {
              value: new Color(1118481)
            },
            shininess: {
              value: 30
            }
          }]),
          vertexShader: ShaderChunk.meshphong_vert,
          fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            },
            roughness: {
              value: 1
            },
            metalness: {
              value: 0
            },
            envMapIntensity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            }
          }]),
          vertexShader: ShaderChunk.meshtoon_vert,
          fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
            matcap: {
              value: null
            }
          }]),
          vertexShader: ShaderChunk.meshmatcap_vert,
          fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
          uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
          vertexShader: ShaderChunk.points_vert,
          fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
            scale: {
              value: 1
            },
            dashSize: {
              value: 1
            },
            totalSize: {
              value: 2
            }
          }]),
          vertexShader: ShaderChunk.linedashed_vert,
          fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
          vertexShader: ShaderChunk.depth_vert,
          fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.meshnormal_vert,
          fragmentShader: ShaderChunk.meshnormal_frag
        },
        sprite: {
          uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
          vertexShader: ShaderChunk.sprite_vert,
          fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Matrix32()
            },
            t2D: {
              value: null
            }
          },
          vertexShader: ShaderChunk.background_vert,
          fragmentShader: ShaderChunk.background_frag
        },
        cube: {
          uniforms: mergeUniforms([UniformsLib.envmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.cube_vert,
          fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: ShaderChunk.equirect_vert,
          fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
            referencePosition: {
              value: new Vector34()
            },
            nearDistance: {
              value: 1
            },
            farDistance: {
              value: 1e3
            }
          }]),
          vertexShader: ShaderChunk.distanceRGBA_vert,
          fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
          uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
            color: {
              value: new Color(0)
            },
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.shadow_vert,
          fragmentShader: ShaderChunk.shadow_frag
        }
      };
      ShaderLib.physical = {
        uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
          clearcoat: {
            value: 0
          },
          clearcoatMap: {
            value: null
          },
          clearcoatRoughness: {
            value: 0
          },
          clearcoatRoughnessMap: {
            value: null
          },
          clearcoatNormalScale: {
            value: new Vector2(1, 1)
          },
          clearcoatNormalMap: {
            value: null
          },
          sheen: {
            value: 0
          },
          sheenColor: {
            value: new Color(0)
          },
          sheenColorMap: {
            value: null
          },
          sheenRoughness: {
            value: 0
          },
          sheenRoughnessMap: {
            value: null
          },
          transmission: {
            value: 0
          },
          transmissionMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new Vector2()
          },
          transmissionSamplerMap: {
            value: null
          },
          thickness: {
            value: 0
          },
          thicknessMap: {
            value: null
          },
          attenuationDistance: {
            value: 0
          },
          attenuationColor: {
            value: new Color(0)
          },
          specularIntensity: {
            value: 0
          },
          specularIntensityMap: {
            value: null
          },
          specularColor: {
            value: new Color(1, 1, 1)
          },
          specularColorMap: {
            value: null
          }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      };
      function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
        const clearColor = new Color(0);
        let clearAlpha = 0;
        let planeMesh;
        let boxMesh;
        let currentBackground = null;
        let currentBackgroundVersion = 0;
        let currentTonemapping = null;
        function render2(renderList, scene) {
          let forceClear = false;
          let background = scene.isScene === true ? scene.background : null;
          if (background && background.isTexture) {
            background = cubemaps.get(background);
          }
          const xr = renderer.xr;
          const session = xr.getSession && xr.getSession();
          if (session && session.environmentBlendMode === "additive") {
            background = null;
          }
          if (background === null) {
            setClear(clearColor, clearAlpha);
          } else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
          }
          if (renderer.autoClear || forceClear) {
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
          }
          if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === void 0) {
              boxMesh = new Mesh3(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                vertexShader: ShaderLib.cube.vertexShader,
                fragmentShader: ShaderLib.cube.fragmentShader,
                side: BackSide,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              boxMesh.geometry.deleteAttribute("normal");
              boxMesh.geometry.deleteAttribute("uv");
              boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
                this.matrixWorld.copyPosition(camera.matrixWorld);
              };
              Object.defineProperty(boxMesh.material, "envMap", {
                get: function() {
                  return this.uniforms.envMap.value;
                }
              });
              objects.update(boxMesh);
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              boxMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
          } else if (background && background.isTexture) {
            if (planeMesh === void 0) {
              planeMesh = new Mesh3(new PlaneGeometry2(2, 2), new ShaderMaterial({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms(ShaderLib.background.uniforms),
                vertexShader: ShaderLib.background.vertexShader,
                fragmentShader: ShaderLib.background.fragmentShader,
                side: FrontSide,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              planeMesh.geometry.deleteAttribute("normal");
              Object.defineProperty(planeMesh.material, "map", {
                get: function() {
                  return this.uniforms.t2D.value;
                }
              });
              objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) {
              background.updateMatrix();
            }
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              planeMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
          }
        }
        function setClear(color, alpha) {
          state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        return {
          getClearColor: function() {
            return clearColor;
          },
          setClearColor: function(color, alpha = 1) {
            clearColor.set(color);
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
          },
          getClearAlpha: function() {
            return clearAlpha;
          },
          setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
          },
          render: render2
        };
      }
      function WebGLBindingStates(gl, extensions, attributes, capabilities) {
        const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
        const vaoAvailable = capabilities.isWebGL2 || extension !== null;
        const bindingStates = {};
        const defaultState = createBindingState(null);
        let currentState = defaultState;
        function setup2(object, material2, program, geometry2, index) {
          let updateBuffers = false;
          if (vaoAvailable) {
            const state = getBindingState(geometry2, program, material2);
            if (currentState !== state) {
              currentState = state;
              bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry2, index);
            if (updateBuffers)
              saveCache(geometry2, index);
          } else {
            const wireframe = material2.wireframe === true;
            if (currentState.geometry !== geometry2.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
              currentState.geometry = geometry2.id;
              currentState.program = program.id;
              currentState.wireframe = wireframe;
              updateBuffers = true;
            }
          }
          if (object.isInstancedMesh === true) {
            updateBuffers = true;
          }
          if (index !== null) {
            attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
          }
          if (updateBuffers) {
            setupVertexAttributes(object, material2, program, geometry2);
            if (index !== null) {
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
            }
          }
        }
        function createVertexArrayObject() {
          if (capabilities.isWebGL2)
            return gl.createVertexArray();
          return extension.createVertexArrayOES();
        }
        function bindVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl.bindVertexArray(vao);
          return extension.bindVertexArrayOES(vao);
        }
        function deleteVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl.deleteVertexArray(vao);
          return extension.deleteVertexArrayOES(vao);
        }
        function getBindingState(geometry2, program, material2) {
          const wireframe = material2.wireframe === true;
          let programMap = bindingStates[geometry2.id];
          if (programMap === void 0) {
            programMap = {};
            bindingStates[geometry2.id] = programMap;
          }
          let stateMap = programMap[program.id];
          if (stateMap === void 0) {
            stateMap = {};
            programMap[program.id] = stateMap;
          }
          let state = stateMap[wireframe];
          if (state === void 0) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
          }
          return state;
        }
        function createBindingState(vao) {
          const newAttributes = [];
          const enabledAttributes = [];
          const attributeDivisors = [];
          for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
            newAttributes[i2] = 0;
            enabledAttributes[i2] = 0;
            attributeDivisors[i2] = 0;
          }
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes,
            enabledAttributes,
            attributeDivisors,
            object: vao,
            attributes: {},
            index: null
          };
        }
        function needsUpdate(geometry2, index) {
          const cachedAttributes = currentState.attributes;
          const geometryAttributes = geometry2.attributes;
          let attributesNum = 0;
          for (const key in geometryAttributes) {
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === void 0)
              return true;
            if (cachedAttribute.attribute !== geometryAttribute)
              return true;
            if (cachedAttribute.data !== geometryAttribute.data)
              return true;
            attributesNum++;
          }
          if (currentState.attributesNum !== attributesNum)
            return true;
          if (currentState.index !== index)
            return true;
          return false;
        }
        function saveCache(geometry2, index) {
          const cache = {};
          const attributes2 = geometry2.attributes;
          let attributesNum = 0;
          for (const key in attributes2) {
            const attribute = attributes2[key];
            const data = {};
            data.attribute = attribute;
            if (attribute.data) {
              data.data = attribute.data;
            }
            cache[key] = data;
            attributesNum++;
          }
          currentState.attributes = cache;
          currentState.attributesNum = attributesNum;
          currentState.index = index;
        }
        function initAttributes() {
          const newAttributes = currentState.newAttributes;
          for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
            newAttributes[i2] = 0;
          }
        }
        function enableAttribute(attribute) {
          enableAttributeAndDivisor(attribute, 0);
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          const attributeDivisors = currentState.attributeDivisors;
          newAttributes[attribute] = 1;
          if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
          }
          if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
            extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
          }
        }
        function disableUnusedAttributes() {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
            if (enabledAttributes[i2] !== newAttributes[i2]) {
              gl.disableVertexAttribArray(i2);
              enabledAttributes[i2] = 0;
            }
          }
        }
        function vertexAttribPointer(index, size, type, normalized, stride, offset) {
          if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
            gl.vertexAttribIPointer(index, size, type, stride, offset);
          } else {
            gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
          }
        }
        function setupVertexAttributes(object, material2, program, geometry2) {
          if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry2.isInstancedBufferGeometry)) {
            if (extensions.get("ANGLE_instanced_arrays") === null)
              return;
          }
          initAttributes();
          const geometryAttributes = geometry2.attributes;
          const programAttributes = program.getAttributes();
          const materialDefaultAttributeValues = material2.defaultAttributeValues;
          for (const name in programAttributes) {
            const programAttribute = programAttributes[name];
            if (programAttribute.location >= 0) {
              let geometryAttribute = geometryAttributes[name];
              if (geometryAttribute === void 0) {
                if (name === "instanceMatrix" && object.instanceMatrix)
                  geometryAttribute = object.instanceMatrix;
                if (name === "instanceColor" && object.instanceColor)
                  geometryAttribute = object.instanceColor;
              }
              if (geometryAttribute !== void 0) {
                const normalized = geometryAttribute.normalized;
                const size = geometryAttribute.itemSize;
                const attribute = attributes.get(geometryAttribute);
                if (attribute === void 0)
                  continue;
                const buffer = attribute.buffer;
                const type = attribute.type;
                const bytesPerElement = attribute.bytesPerElement;
                if (geometryAttribute.isInterleavedBufferAttribute) {
                  const data = geometryAttribute.data;
                  const stride = data.stride;
                  const offset = geometryAttribute.offset;
                  if (data && data.isInstancedInterleavedBuffer) {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
                    }
                    if (object.isInstancedMesh !== true && geometry2._maxInstanceCount === void 0) {
                      geometry2._maxInstanceCount = data.meshPerAttribute * data.count;
                    }
                  } else {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttribute(programAttribute.location + i2);
                    }
                  }
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i2) * bytesPerElement);
                  }
                } else {
                  if (geometryAttribute.isInstancedBufferAttribute) {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
                    }
                    if (object.isInstancedMesh !== true && geometry2._maxInstanceCount === void 0) {
                      geometry2._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                    }
                  } else {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttribute(programAttribute.location + i2);
                    }
                  }
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
                  }
                }
              } else if (materialDefaultAttributeValues !== void 0) {
                const value = materialDefaultAttributeValues[name];
                if (value !== void 0) {
                  switch (value.length) {
                    case 2:
                      gl.vertexAttrib2fv(programAttribute.location, value);
                      break;
                    case 3:
                      gl.vertexAttrib3fv(programAttribute.location, value);
                      break;
                    case 4:
                      gl.vertexAttrib4fv(programAttribute.location, value);
                      break;
                    default:
                      gl.vertexAttrib1fv(programAttribute.location, value);
                  }
                }
              }
            }
          }
          disableUnusedAttributes();
        }
        function dispose() {
          reset();
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            for (const programId in programMap) {
              const stateMap = programMap[programId];
              for (const wireframe in stateMap) {
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
              }
              delete programMap[programId];
            }
            delete bindingStates[geometryId];
          }
        }
        function releaseStatesOfGeometry(geometry2) {
          if (bindingStates[geometry2.id] === void 0)
            return;
          const programMap = bindingStates[geometry2.id];
          for (const programId in programMap) {
            const stateMap = programMap[programId];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[programId];
          }
          delete bindingStates[geometry2.id];
        }
        function releaseStatesOfProgram(program) {
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === void 0)
              continue;
            const stateMap = programMap[program.id];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[program.id];
          }
        }
        function reset() {
          resetDefaultState();
          if (currentState === defaultState)
            return;
          currentState = defaultState;
          bindVertexArrayObject(currentState.object);
        }
        function resetDefaultState() {
          defaultState.geometry = null;
          defaultState.program = null;
          defaultState.wireframe = false;
        }
        return {
          setup: setup2,
          reset,
          resetDefaultState,
          dispose,
          releaseStatesOfGeometry,
          releaseStatesOfProgram,
          initAttributes,
          enableAttribute,
          disableUnusedAttributes
        };
      }
      function WebGLBufferRenderer(gl, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        function render2(start, count) {
          gl.drawArrays(mode, start, count);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl;
            methodName = "drawArraysInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawArraysInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, start, count, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.render = render2;
        this.renderInstances = renderInstances;
      }
      function WebGLCapabilities(gl, extensions, parameters) {
        let maxAnisotropy;
        function getMaxAnisotropy() {
          if (maxAnisotropy !== void 0)
            return maxAnisotropy;
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else {
            maxAnisotropy = 0;
          }
          return maxAnisotropy;
        }
        function getMaxPrecision(precision2) {
          if (precision2 === "highp") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
              return "highp";
            }
            precision2 = "mediump";
          }
          if (precision2 === "mediump") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
              return "mediump";
            }
          }
          return "lowp";
        }
        const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
        let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
        const maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
          console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
          precision = maxPrecision;
        }
        const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
        const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        const vertexTextures = maxVertexTextures > 0;
        const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
        const floatVertexTextures = vertexTextures && floatFragmentTextures;
        const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
        return {
          isWebGL2,
          drawBuffers,
          getMaxAnisotropy,
          getMaxPrecision,
          precision,
          logarithmicDepthBuffer,
          maxTextures,
          maxVertexTextures,
          maxTextureSize,
          maxCubemapSize,
          maxAttributes,
          maxVertexUniforms,
          maxVaryings,
          maxFragmentUniforms,
          vertexTextures,
          floatFragmentTextures,
          floatVertexTextures,
          maxSamples
        };
      }
      function WebGLClipping(properties) {
        const scope = this;
        let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
        const plane = new Plane(), viewNormalMatrix = new Matrix32(), uniform = {
          value: null,
          needsUpdate: false
        };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function(planes, enableLocalClipping, camera) {
          const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
          localClippingEnabled = enableLocalClipping;
          globalState = projectPlanes(planes, camera, 0);
          numGlobalPlanes = planes.length;
          return enabled;
        };
        this.beginShadows = function() {
          renderingShadows = true;
          projectPlanes(null);
        };
        this.endShadows = function() {
          renderingShadows = false;
          resetGlobalState();
        };
        this.setState = function(material2, camera, useCache) {
          const planes = material2.clippingPlanes, clipIntersection = material2.clipIntersection, clipShadows = material2.clipShadows;
          const materialProperties = properties.get(material2);
          if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            if (renderingShadows) {
              projectPlanes(null);
            } else {
              resetGlobalState();
            }
          } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray;
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for (let i2 = 0; i2 !== lGlobal; ++i2) {
              dstArray[i2] = globalState[i2];
            }
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
          }
        };
        function resetGlobalState() {
          if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
          }
          scope.numPlanes = numGlobalPlanes;
          scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
          const nPlanes = planes !== null ? planes.length : 0;
          let dstArray = null;
          if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
              const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
              viewNormalMatrix.getNormalMatrix(viewMatrix);
              if (dstArray === null || dstArray.length < flatSize) {
                dstArray = new Float32Array(flatSize);
              }
              for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
                plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
                plane.normal.toArray(dstArray, i4);
                dstArray[i4 + 3] = plane.constant;
              }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
          }
          scope.numPlanes = nPlanes;
          scope.numIntersection = 0;
          return dstArray;
        }
      }
      function WebGLCubeMaps(renderer) {
        let cubemaps = new WeakMap();
        function mapTextureMapping(texture, mapping) {
          if (mapping === EquirectangularReflectionMapping) {
            texture.mapping = CubeReflectionMapping;
          } else if (mapping === EquirectangularRefractionMapping) {
            texture.mapping = CubeRefractionMapping;
          }
          return texture;
        }
        function get(texture) {
          if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
              if (cubemaps.has(texture)) {
                const cubemap = cubemaps.get(texture).texture;
                return mapTextureMapping(cubemap, texture.mapping);
              } else {
                const image = texture.image;
                if (image && image.height > 0) {
                  const currentRenderTarget = renderer.getRenderTarget();
                  const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                  renderTarget.fromEquirectangularTexture(renderer, texture);
                  cubemaps.set(texture, renderTarget);
                  renderer.setRenderTarget(currentRenderTarget);
                  texture.addEventListener("dispose", onTextureDispose);
                  return mapTextureMapping(renderTarget.texture, texture.mapping);
                } else {
                  return null;
                }
              }
            }
          }
          return texture;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          const cubemap = cubemaps.get(texture);
          if (cubemap !== void 0) {
            cubemaps.delete(texture);
            cubemap.dispose();
          }
        }
        function dispose() {
          cubemaps = new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      class OrthographicCamera extends Camera {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
          super();
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = left;
          this.right = right;
          this.top = top;
          this.bottom = bottom;
          this.near = near;
          this.far = far;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;
          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          return this;
        }
        setViewOffset(fullWidth, fullHeight, x2, y, width, height) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x2;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;
          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;
          if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          return data;
        }
      }
      OrthographicCamera.prototype.isOrthographicCamera = true;
      class RawShaderMaterial extends ShaderMaterial {
        constructor(parameters) {
          super(parameters);
          this.type = "RawShaderMaterial";
        }
      }
      RawShaderMaterial.prototype.isRawShaderMaterial = true;
      const LOD_MIN = 4;
      const LOD_MAX = 8;
      const SIZE_MAX = Math.pow(2, LOD_MAX);
      const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
      const MAX_SAMPLES = 20;
      const ENCODINGS = {
        [LinearEncoding]: 0,
        [sRGBEncoding]: 1,
        [RGBEEncoding]: 2,
        [RGBM7Encoding]: 3,
        [RGBM16Encoding]: 4,
        [RGBDEncoding]: 5,
        [GammaEncoding]: 6
      };
      const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
      const {
        _lodPlanes,
        _sizeLods,
        _sigmas
      } = /* @__PURE__ */ _createPlanes();
      const _clearColor = /* @__PURE__ */ new Color();
      let _oldTarget = null;
      const PHI = (1 + Math.sqrt(5)) / 2;
      const INV_PHI = 1 / PHI;
      const _axisDirections = [/* @__PURE__ */ new Vector34(1, 1, 1), /* @__PURE__ */ new Vector34(-1, 1, 1), /* @__PURE__ */ new Vector34(1, 1, -1), /* @__PURE__ */ new Vector34(-1, 1, -1), /* @__PURE__ */ new Vector34(0, PHI, INV_PHI), /* @__PURE__ */ new Vector34(0, PHI, -INV_PHI), /* @__PURE__ */ new Vector34(INV_PHI, 0, PHI), /* @__PURE__ */ new Vector34(-INV_PHI, 0, PHI), /* @__PURE__ */ new Vector34(PHI, INV_PHI, 0), /* @__PURE__ */ new Vector34(-PHI, INV_PHI, 0)];
      class PMREMGenerator {
        constructor(renderer) {
          this._renderer = renderer;
          this._pingPongRenderTarget = null;
          this._blurMaterial = _getBlurShader(MAX_SAMPLES);
          this._equirectShader = null;
          this._cubemapShader = null;
          this._compileMaterial(this._blurMaterial);
        }
        fromScene(scene, sigma = 0, near = 0.1, far = 100) {
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets();
          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {
            this._blur(cubeUVRenderTarget, 0, 0, sigma);
          }
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        fromEquirectangular(equirectangular) {
          return this._fromTexture(equirectangular);
        }
        fromCubemap(cubemap) {
          return this._fromTexture(cubemap);
        }
        compileCubemapShader() {
          if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader();
            this._compileMaterial(this._cubemapShader);
          }
        }
        compileEquirectangularShader() {
          if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader();
            this._compileMaterial(this._equirectShader);
          }
        }
        dispose() {
          this._blurMaterial.dispose();
          if (this._cubemapShader !== null)
            this._cubemapShader.dispose();
          if (this._equirectShader !== null)
            this._equirectShader.dispose();
          for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
            _lodPlanes[i2].dispose();
          }
        }
        _cleanup(outputTarget) {
          this._pingPongRenderTarget.dispose();
          this._renderer.setRenderTarget(_oldTarget);
          outputTarget.scissorTest = false;
          _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture) {
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets(texture);
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        _allocateTargets(texture) {
          const params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: UnsignedByteType,
            format: RGBEFormat,
            encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
            depthBuffer: false
          };
          const cubeUVRenderTarget = _createRenderTarget(params);
          cubeUVRenderTarget.depthBuffer = texture ? false : true;
          this._pingPongRenderTarget = _createRenderTarget(params);
          return cubeUVRenderTarget;
        }
        _compileMaterial(material2) {
          const tmpMesh = new Mesh3(_lodPlanes[0], material2);
          this._renderer.compile(tmpMesh, _flatCamera);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
          const fov2 = 90;
          const aspect2 = 1;
          const cubeCamera = new PerspectiveCamera2(fov2, aspect2, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;
          const originalAutoClear = renderer.autoClear;
          const outputEncoding = renderer.outputEncoding;
          const toneMapping = renderer.toneMapping;
          renderer.getClearColor(_clearColor);
          renderer.toneMapping = NoToneMapping2;
          renderer.outputEncoding = LinearEncoding;
          renderer.autoClear = false;
          const backgroundMaterial = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: false,
            depthTest: false
          });
          const backgroundBox = new Mesh3(new BoxGeometry(), backgroundMaterial);
          let useSolidColor = false;
          const background = scene.background;
          if (background) {
            if (background.isColor) {
              backgroundMaterial.color.copy(background);
              scene.background = null;
              useSolidColor = true;
            }
          } else {
            backgroundMaterial.color.copy(_clearColor);
            useSolidColor = true;
          }
          for (let i2 = 0; i2 < 6; i2++) {
            const col = i2 % 3;
            if (col == 0) {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(forwardSign[i2], 0, 0);
            } else if (col == 1) {
              cubeCamera.up.set(0, 0, upSign[i2]);
              cubeCamera.lookAt(0, forwardSign[i2], 0);
            } else {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(0, 0, forwardSign[i2]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i2 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) {
              renderer.render(backgroundBox, cubeCamera);
            }
            renderer.render(scene, cubeCamera);
          }
          backgroundBox.geometry.dispose();
          backgroundBox.material.dispose();
          renderer.toneMapping = toneMapping;
          renderer.outputEncoding = outputEncoding;
          renderer.autoClear = originalAutoClear;
          scene.background = background;
        }
        _setEncoding(uniform, texture) {
          uniform.value = ENCODINGS[texture.encoding];
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
          const renderer = this._renderer;
          const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
          if (isCubeTexture) {
            if (this._cubemapShader == null) {
              this._cubemapShader = _getCubemapShader();
            }
          } else {
            if (this._equirectShader == null) {
              this._equirectShader = _getEquirectShader();
            }
          }
          const material2 = isCubeTexture ? this._cubemapShader : this._equirectShader;
          const mesh = new Mesh3(_lodPlanes[0], material2);
          const uniforms = material2.uniforms;
          uniforms["envMap"].value = texture;
          if (!isCubeTexture) {
            uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
          }
          this._setEncoding(uniforms["inputEncoding"], texture);
          this._setEncoding(uniforms["outputEncoding"], cubeUVRenderTarget.texture);
          _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera);
        }
        _applyPMREM(cubeUVRenderTarget) {
          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;
          for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
            const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
            const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
          }
          renderer.autoClear = autoClear;
        }
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
          const pingPongRenderTarget = this._pingPongRenderTarget;
          this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
          this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;
          if (direction !== "latitudinal" && direction !== "longitudinal") {
            console.error("blur direction must be either latitudinal or longitudinal!");
          }
          const STANDARD_DEVIATIONS = 3;
          const blurMesh = new Mesh3(_lodPlanes[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;
          const pixels = _sizeLods[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
          if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
          }
          const weights = [];
          let sum = 0;
          for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
            const x3 = i2 / sigmaPixels;
            const weight = Math.exp(-x3 * x3 / 2);
            weights.push(weight);
            if (i2 == 0) {
              sum += weight;
            } else if (i2 < samples) {
              sum += 2 * weight;
            }
          }
          for (let i2 = 0; i2 < weights.length; i2++) {
            weights[i2] = weights[i2] / sum;
          }
          blurUniforms["envMap"].value = targetIn.texture;
          blurUniforms["samples"].value = samples;
          blurUniforms["weights"].value = weights;
          blurUniforms["latitudinal"].value = direction === "latitudinal";
          if (poleAxis) {
            blurUniforms["poleAxis"].value = poleAxis;
          }
          blurUniforms["dTheta"].value = radiansPerPixel;
          blurUniforms["mipInt"].value = LOD_MAX - lodIn;
          this._setEncoding(blurUniforms["inputEncoding"], targetIn.texture);
          this._setEncoding(blurUniforms["outputEncoding"], targetIn.texture);
          const outputSize = _sizeLods[lodOut];
          const x2 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
          const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
          _setViewport(targetOut, x2, y, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera);
        }
      }
      function _isLDR(texture) {
        if (texture === void 0 || texture.type !== UnsignedByteType)
          return false;
        return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
      }
      function _createPlanes() {
        const _lodPlanes2 = [];
        const _sizeLods2 = [];
        const _sigmas2 = [];
        let lod = LOD_MAX;
        for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
          const sizeLod = Math.pow(2, lod);
          _sizeLods2.push(sizeLod);
          let sigma = 1 / sizeLod;
          if (i2 > LOD_MAX - LOD_MIN) {
            sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
          } else if (i2 == 0) {
            sigma = 0;
          }
          _sigmas2.push(sigma);
          const texelSize = 1 / (sizeLod - 1);
          const min = -texelSize / 2;
          const max = 1 + texelSize / 2;
          const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
          const cubeFaces = 6;
          const vertices = 6;
          const positionSize = 3;
          const uvSize = 2;
          const faceIndexSize = 1;
          const position2 = new Float32Array(positionSize * vertices * cubeFaces);
          const uv = new Float32Array(uvSize * vertices * cubeFaces);
          const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
          for (let face = 0; face < cubeFaces; face++) {
            const x2 = face % 3 * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [x2, y, 0, x2 + 2 / 3, y, 0, x2 + 2 / 3, y + 1, 0, x2, y, 0, x2 + 2 / 3, y + 1, 0, x2, y + 1, 0];
            position2.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [face, face, face, face, face, face];
            faceIndex.set(fill, faceIndexSize * vertices * face);
          }
          const planes = new BufferGeometry3();
          planes.setAttribute("position", new BufferAttribute(position2, positionSize));
          planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
          planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
          _lodPlanes2.push(planes);
          if (lod > LOD_MIN) {
            lod--;
          }
        }
        return {
          _lodPlanes: _lodPlanes2,
          _sizeLods: _sizeLods2,
          _sigmas: _sigmas2
        };
      }
      function _createRenderTarget(params) {
        const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
      }
      function _setViewport(target, x2, y, width, height) {
        target.viewport.set(x2, y, width, height);
        target.scissor.set(x2, y, width, height);
      }
      function _getBlurShader(maxSamples) {
        const weights = new Float32Array(maxSamples);
        const poleAxis = new Vector34(0, 1, 0);
        const shaderMaterial = new RawShaderMaterial({
          name: "SphericalGaussianBlur",
          defines: {
            "n": maxSamples
          },
          uniforms: {
            "envMap": {
              value: null
            },
            "samples": {
              value: 1
            },
            "weights": {
              value: weights
            },
            "latitudinal": {
              value: false
            },
            "dTheta": {
              value: 0
            },
            "mipInt": {
              value: 0
            },
            "poleAxis": {
              value: poleAxis
            },
            "inputEncoding": {
              value: ENCODINGS[LinearEncoding]
            },
            "outputEncoding": {
              value: ENCODINGS[LinearEncoding]
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getEquirectShader() {
        const texelSize = new Vector2(1, 1);
        const shaderMaterial = new RawShaderMaterial({
          name: "EquirectangularToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            },
            "texelSize": {
              value: texelSize
            },
            "inputEncoding": {
              value: ENCODINGS[LinearEncoding]
            },
            "outputEncoding": {
              value: ENCODINGS[LinearEncoding]
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getCubemapShader() {
        const shaderMaterial = new RawShaderMaterial({
          name: "CubemapToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            },
            "inputEncoding": {
              value: ENCODINGS[LinearEncoding]
            },
            "outputEncoding": {
              value: ENCODINGS[LinearEncoding]
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getCommonVertexShader() {
        return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function _getEncodings() {
        return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
      }
      function WebGLCubeUVMaps(renderer) {
        let cubeUVmaps = new WeakMap();
        let pmremGenerator = null;
        function get(texture) {
          if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
            const mapping = texture.mapping;
            const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
            const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
            if (isEquirectMap || isCubeMap) {
              if (cubeUVmaps.has(texture)) {
                return cubeUVmaps.get(texture).texture;
              } else {
                const image = texture.image;
                if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                  const currentRenderTarget = renderer.getRenderTarget();
                  if (pmremGenerator === null)
                    pmremGenerator = new PMREMGenerator(renderer);
                  const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                  cubeUVmaps.set(texture, renderTarget);
                  renderer.setRenderTarget(currentRenderTarget);
                  texture.addEventListener("dispose", onTextureDispose);
                  return renderTarget.texture;
                } else {
                  return null;
                }
              }
            }
          }
          return texture;
        }
        function isCubeTextureComplete(image) {
          let count = 0;
          const length = 6;
          for (let i2 = 0; i2 < length; i2++) {
            if (image[i2] !== void 0)
              count++;
          }
          return count === length;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          const cubemapUV = cubeUVmaps.get(texture);
          if (cubemapUV !== void 0) {
            cubeUVmaps.delete(texture);
            cubemapUV.dispose();
          }
        }
        function dispose() {
          cubeUVmaps = new WeakMap();
          if (pmremGenerator !== null) {
            pmremGenerator.dispose();
            pmremGenerator = null;
          }
        }
        return {
          get,
          dispose
        };
      }
      function WebGLExtensions(gl) {
        const extensions = {};
        function getExtension(name) {
          if (extensions[name] !== void 0) {
            return extensions[name];
          }
          let extension;
          switch (name) {
            case "WEBGL_depth_texture":
              extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              extension = gl.getExtension(name);
          }
          extensions[name] = extension;
          return extension;
        }
        return {
          has: function(name) {
            return getExtension(name) !== null;
          },
          init: function(capabilities) {
            if (capabilities.isWebGL2) {
              getExtension("EXT_color_buffer_float");
            } else {
              getExtension("WEBGL_depth_texture");
              getExtension("OES_texture_float");
              getExtension("OES_texture_half_float");
              getExtension("OES_texture_half_float_linear");
              getExtension("OES_standard_derivatives");
              getExtension("OES_element_index_uint");
              getExtension("OES_vertex_array_object");
              getExtension("ANGLE_instanced_arrays");
            }
            getExtension("OES_texture_float_linear");
            getExtension("EXT_color_buffer_half_float");
            getExtension("WEBGL_multisampled_render_to_texture");
          },
          get: function(name) {
            const extension = getExtension(name);
            if (extension === null) {
              console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
            }
            return extension;
          }
        };
      }
      function WebGLGeometries(gl, attributes, info, bindingStates) {
        const geometries = {};
        const wireframeAttributes = new WeakMap();
        function onGeometryDispose(event) {
          const geometry2 = event.target;
          if (geometry2.index !== null) {
            attributes.remove(geometry2.index);
          }
          for (const name in geometry2.attributes) {
            attributes.remove(geometry2.attributes[name]);
          }
          geometry2.removeEventListener("dispose", onGeometryDispose);
          delete geometries[geometry2.id];
          const attribute = wireframeAttributes.get(geometry2);
          if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry2);
          }
          bindingStates.releaseStatesOfGeometry(geometry2);
          if (geometry2.isInstancedBufferGeometry === true) {
            delete geometry2._maxInstanceCount;
          }
          info.memory.geometries--;
        }
        function get(object, geometry2) {
          if (geometries[geometry2.id] === true)
            return geometry2;
          geometry2.addEventListener("dispose", onGeometryDispose);
          geometries[geometry2.id] = true;
          info.memory.geometries++;
          return geometry2;
        }
        function update(geometry2) {
          const geometryAttributes = geometry2.attributes;
          for (const name in geometryAttributes) {
            attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
          }
          const morphAttributes = geometry2.morphAttributes;
          for (const name in morphAttributes) {
            const array = morphAttributes[name];
            for (let i2 = 0, l = array.length; i2 < l; i2++) {
              attributes.update(array[i2], gl.ARRAY_BUFFER);
            }
          }
        }
        function updateWireframeAttribute(geometry2) {
          const indices = [];
          const geometryIndex = geometry2.index;
          const geometryPosition = geometry2.attributes.position;
          let version = 0;
          if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
              const a = array[i2 + 0];
              const b = array[i2 + 1];
              const c = array[i2 + 2];
              indices.push(a, b, b, c, c, a);
            }
          } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for (let i2 = 0, l = array.length / 3 - 1; i2 < l; i2 += 3) {
              const a = i2 + 0;
              const b = i2 + 1;
              const c = i2 + 2;
              indices.push(a, b, b, c, c, a);
            }
          }
          const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
          attribute.version = version;
          const previousAttribute = wireframeAttributes.get(geometry2);
          if (previousAttribute)
            attributes.remove(previousAttribute);
          wireframeAttributes.set(geometry2, attribute);
        }
        function getWireframeAttribute(geometry2) {
          const currentAttribute = wireframeAttributes.get(geometry2);
          if (currentAttribute) {
            const geometryIndex = geometry2.index;
            if (geometryIndex !== null) {
              if (currentAttribute.version < geometryIndex.version) {
                updateWireframeAttribute(geometry2);
              }
            }
          } else {
            updateWireframeAttribute(geometry2);
          }
          return wireframeAttributes.get(geometry2);
        }
        return {
          get,
          update,
          getWireframeAttribute
        };
      }
      function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        let type, bytesPerElement;
        function setIndex(value) {
          type = value.type;
          bytesPerElement = value.bytesPerElement;
        }
        function render2(start, count) {
          gl.drawElements(mode, count, type, start * bytesPerElement);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl;
            methodName = "drawElementsInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawElementsInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, count, type, start * bytesPerElement, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render2;
        this.renderInstances = renderInstances;
      }
      function WebGLInfo(gl) {
        const memory = {
          geometries: 0,
          textures: 0
        };
        const render2 = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function update(count, mode, instanceCount) {
          render2.calls++;
          switch (mode) {
            case gl.TRIANGLES:
              render2.triangles += instanceCount * (count / 3);
              break;
            case gl.LINES:
              render2.lines += instanceCount * (count / 2);
              break;
            case gl.LINE_STRIP:
              render2.lines += instanceCount * (count - 1);
              break;
            case gl.LINE_LOOP:
              render2.lines += instanceCount * count;
              break;
            case gl.POINTS:
              render2.points += instanceCount * count;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
              break;
          }
        }
        function reset() {
          render2.frame++;
          render2.calls = 0;
          render2.triangles = 0;
          render2.points = 0;
          render2.lines = 0;
        }
        return {
          memory,
          render: render2,
          programs: null,
          autoReset: true,
          reset,
          update
        };
      }
      class DataTexture2DArray extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.needsUpdate = true;
        }
      }
      DataTexture2DArray.prototype.isDataTexture2DArray = true;
      function numericalSort(a, b) {
        return a[0] - b[0];
      }
      function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
      }
      function denormalize(morph, attribute) {
        let denominator = 1;
        const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
        if (array instanceof Int8Array)
          denominator = 127;
        else if (array instanceof Int16Array)
          denominator = 32767;
        else if (array instanceof Int32Array)
          denominator = 2147483647;
        else
          console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
        morph.divideScalar(denominator);
      }
      function WebGLMorphtargets(gl, capabilities, textures) {
        const influencesList = {};
        const morphInfluences = new Float32Array(8);
        const morphTextures = new WeakMap();
        const morph = new Vector34();
        const workInfluences = [];
        for (let i2 = 0; i2 < 8; i2++) {
          workInfluences[i2] = [i2, 0];
        }
        function update(object, geometry2, material2, program) {
          const objectInfluences = object.morphTargetInfluences;
          if (capabilities.isWebGL2 === true) {
            const numberOfMorphTargets = geometry2.morphAttributes.position.length;
            let entry = morphTextures.get(geometry2);
            if (entry === void 0 || entry.count !== numberOfMorphTargets) {
              if (entry !== void 0)
                entry.texture.dispose();
              const hasMorphNormals = geometry2.morphAttributes.normal !== void 0;
              const morphTargets = geometry2.morphAttributes.position;
              const morphNormals = geometry2.morphAttributes.normal || [];
              const numberOfVertices = geometry2.attributes.position.count;
              const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
              let width = numberOfVertices * numberOfVertexData;
              let height = 1;
              if (width > capabilities.maxTextureSize) {
                height = Math.ceil(width / capabilities.maxTextureSize);
                width = capabilities.maxTextureSize;
              }
              const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
              const texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);
              texture.format = RGBAFormat;
              texture.type = FloatType;
              const vertexDataStride = numberOfVertexData * 4;
              for (let i2 = 0; i2 < numberOfMorphTargets; i2++) {
                const morphTarget = morphTargets[i2];
                const morphNormal = morphNormals[i2];
                const offset = width * height * 4 * i2;
                for (let j = 0; j < morphTarget.count; j++) {
                  morph.fromBufferAttribute(morphTarget, j);
                  if (morphTarget.normalized === true)
                    denormalize(morph, morphTarget);
                  const stride = j * vertexDataStride;
                  buffer[offset + stride + 0] = morph.x;
                  buffer[offset + stride + 1] = morph.y;
                  buffer[offset + stride + 2] = morph.z;
                  buffer[offset + stride + 3] = 0;
                  if (hasMorphNormals === true) {
                    morph.fromBufferAttribute(morphNormal, j);
                    if (morphNormal.normalized === true)
                      denormalize(morph, morphNormal);
                    buffer[offset + stride + 4] = morph.x;
                    buffer[offset + stride + 5] = morph.y;
                    buffer[offset + stride + 6] = morph.z;
                    buffer[offset + stride + 7] = 0;
                  }
                }
              }
              entry = {
                count: numberOfMorphTargets,
                texture,
                size: new Vector2(width, height)
              };
              morphTextures.set(geometry2, entry);
            }
            let morphInfluencesSum = 0;
            for (let i2 = 0; i2 < objectInfluences.length; i2++) {
              morphInfluencesSum += objectInfluences[i2];
            }
            const morphBaseInfluence = geometry2.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
            program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
            program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
          } else {
            const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
            let influences = influencesList[geometry2.id];
            if (influences === void 0 || influences.length !== length) {
              influences = [];
              for (let i2 = 0; i2 < length; i2++) {
                influences[i2] = [i2, 0];
              }
              influencesList[geometry2.id] = influences;
            }
            for (let i2 = 0; i2 < length; i2++) {
              const influence = influences[i2];
              influence[0] = i2;
              influence[1] = objectInfluences[i2];
            }
            influences.sort(absNumericalSort);
            for (let i2 = 0; i2 < 8; i2++) {
              if (i2 < length && influences[i2][1]) {
                workInfluences[i2][0] = influences[i2][0];
                workInfluences[i2][1] = influences[i2][1];
              } else {
                workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
                workInfluences[i2][1] = 0;
              }
            }
            workInfluences.sort(numericalSort);
            const morphTargets = geometry2.morphAttributes.position;
            const morphNormals = geometry2.morphAttributes.normal;
            let morphInfluencesSum = 0;
            for (let i2 = 0; i2 < 8; i2++) {
              const influence = workInfluences[i2];
              const index = influence[0];
              const value = influence[1];
              if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry2.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
                  geometry2.setAttribute("morphTarget" + i2, morphTargets[index]);
                }
                if (morphNormals && geometry2.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
                  geometry2.setAttribute("morphNormal" + i2, morphNormals[index]);
                }
                morphInfluences[i2] = value;
                morphInfluencesSum += value;
              } else {
                if (morphTargets && geometry2.hasAttribute("morphTarget" + i2) === true) {
                  geometry2.deleteAttribute("morphTarget" + i2);
                }
                if (morphNormals && geometry2.hasAttribute("morphNormal" + i2) === true) {
                  geometry2.deleteAttribute("morphNormal" + i2);
                }
                morphInfluences[i2] = 0;
              }
            }
            const morphBaseInfluence = geometry2.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
          }
        }
        return {
          update
        };
      }
      function WebGLObjects(gl, geometries, attributes, info) {
        let updateMap = new WeakMap();
        function update(object) {
          const frame = info.render.frame;
          const geometry2 = object.geometry;
          const buffergeometry = geometries.get(object, geometry2);
          if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
          }
          if (object.isInstancedMesh) {
            if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
              object.addEventListener("dispose", onInstancedMeshDispose);
            }
            attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
            if (object.instanceColor !== null) {
              attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
            }
          }
          return buffergeometry;
        }
        function dispose() {
          updateMap = new WeakMap();
        }
        function onInstancedMeshDispose(event) {
          const instancedMesh = event.target;
          instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
          attributes.remove(instancedMesh.instanceMatrix);
          if (instancedMesh.instanceColor !== null)
            attributes.remove(instancedMesh.instanceColor);
        }
        return {
          update,
          dispose
        };
      }
      class DataTexture3D extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.needsUpdate = true;
        }
      }
      DataTexture3D.prototype.isDataTexture3D = true;
      const emptyTexture = new Texture();
      const emptyTexture2dArray = new DataTexture2DArray();
      const emptyTexture3d = new DataTexture3D();
      const emptyCubeTexture = new CubeTexture();
      const arrayCacheF32 = [];
      const arrayCacheI32 = [];
      const mat4array = new Float32Array(16);
      const mat3array = new Float32Array(9);
      const mat2array = new Float32Array(4);
      function flatten(array, nBlocks, blockSize) {
        const firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0)
          return array;
        const n = nBlocks * blockSize;
        let r2 = arrayCacheF32[n];
        if (r2 === void 0) {
          r2 = new Float32Array(n);
          arrayCacheF32[n] = r2;
        }
        if (nBlocks !== 0) {
          firstElem.toArray(r2, 0);
          for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
            offset += blockSize;
            array[i2].toArray(r2, offset);
          }
        }
        return r2;
      }
      function arraysEqual(a, b) {
        if (a.length !== b.length)
          return false;
        for (let i2 = 0, l = a.length; i2 < l; i2++) {
          if (a[i2] !== b[i2])
            return false;
        }
        return true;
      }
      function copyArray(a, b) {
        for (let i2 = 0, l = b.length; i2 < l; i2++) {
          a[i2] = b[i2];
        }
      }
      function allocTexUnits(textures, n) {
        let r2 = arrayCacheI32[n];
        if (r2 === void 0) {
          r2 = new Int32Array(n);
          arrayCacheI32[n] = r2;
        }
        for (let i2 = 0; i2 !== n; ++i2) {
          r2[i2] = textures.allocateTextureUnit();
        }
        return r2;
      }
      function setValueV1f(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1f(this.addr, v);
        cache[0] = v;
      }
      function setValueV2f(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
          }
        } else {
          if (arraysEqual(cache, v))
            return;
          gl.uniform2fv(this.addr, v);
          copyArray(cache, v);
        }
      }
      function setValueV3f(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
          }
        } else if (v.r !== void 0) {
          if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
          }
        } else {
          if (arraysEqual(cache, v))
            return;
          gl.uniform3fv(this.addr, v);
          copyArray(cache, v);
        }
      }
      function setValueV4f(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
          }
        } else {
          if (arraysEqual(cache, v))
            return;
          gl.uniform4fv(this.addr, v);
          copyArray(cache, v);
        }
      }
      function setValueM2(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v))
            return;
          gl.uniformMatrix2fv(this.addr, false, v);
          copyArray(cache, v);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat2array.set(elements);
          gl.uniformMatrix2fv(this.addr, false, mat2array);
          copyArray(cache, elements);
        }
      }
      function setValueM3(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v))
            return;
          gl.uniformMatrix3fv(this.addr, false, v);
          copyArray(cache, v);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat3array.set(elements);
          gl.uniformMatrix3fv(this.addr, false, mat3array);
          copyArray(cache, elements);
        }
      }
      function setValueM4(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v))
            return;
          gl.uniformMatrix4fv(this.addr, false, v);
          copyArray(cache, v);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat4array.set(elements);
          gl.uniformMatrix4fv(this.addr, false, mat4array);
          copyArray(cache, elements);
        }
      }
      function setValueV1i(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1i(this.addr, v);
        cache[0] = v;
      }
      function setValueV2i(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform2iv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV3i(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform3iv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV4i(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform4iv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV1ui(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1ui(this.addr, v);
        cache[0] = v;
      }
      function setValueV2ui(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform2uiv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV3ui(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform3uiv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV4ui(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform4uiv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueT1(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.safeSetTexture2D(v || emptyTexture, unit);
      }
      function setValueT3D1(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture3D(v || emptyTexture3d, unit);
      }
      function setValueT6(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.safeSetTextureCube(v || emptyCubeTexture, unit);
      }
      function setValueT2DArray1(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture2DArray(v || emptyTexture2dArray, unit);
      }
      function getSingularSetter(type) {
        switch (type) {
          case 5126:
            return setValueV1f;
          case 35664:
            return setValueV2f;
          case 35665:
            return setValueV3f;
          case 35666:
            return setValueV4f;
          case 35674:
            return setValueM2;
          case 35675:
            return setValueM3;
          case 35676:
            return setValueM4;
          case 5124:
          case 35670:
            return setValueV1i;
          case 35667:
          case 35671:
            return setValueV2i;
          case 35668:
          case 35672:
            return setValueV3i;
          case 35669:
          case 35673:
            return setValueV4i;
          case 5125:
            return setValueV1ui;
          case 36294:
            return setValueV2ui;
          case 36295:
            return setValueV3ui;
          case 36296:
            return setValueV4ui;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT1;
          case 35679:
          case 36299:
          case 36307:
            return setValueT3D1;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT6;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return setValueT2DArray1;
        }
      }
      function setValueV1fArray(gl, v) {
        gl.uniform1fv(this.addr, v);
      }
      function setValueV2fArray(gl, v) {
        const data = flatten(v, this.size, 2);
        gl.uniform2fv(this.addr, data);
      }
      function setValueV3fArray(gl, v) {
        const data = flatten(v, this.size, 3);
        gl.uniform3fv(this.addr, data);
      }
      function setValueV4fArray(gl, v) {
        const data = flatten(v, this.size, 4);
        gl.uniform4fv(this.addr, data);
      }
      function setValueM2Array(gl, v) {
        const data = flatten(v, this.size, 4);
        gl.uniformMatrix2fv(this.addr, false, data);
      }
      function setValueM3Array(gl, v) {
        const data = flatten(v, this.size, 9);
        gl.uniformMatrix3fv(this.addr, false, data);
      }
      function setValueM4Array(gl, v) {
        const data = flatten(v, this.size, 16);
        gl.uniformMatrix4fv(this.addr, false, data);
      }
      function setValueV1iArray(gl, v) {
        gl.uniform1iv(this.addr, v);
      }
      function setValueV2iArray(gl, v) {
        gl.uniform2iv(this.addr, v);
      }
      function setValueV3iArray(gl, v) {
        gl.uniform3iv(this.addr, v);
      }
      function setValueV4iArray(gl, v) {
        gl.uniform4iv(this.addr, v);
      }
      function setValueV1uiArray(gl, v) {
        gl.uniform1uiv(this.addr, v);
      }
      function setValueV2uiArray(gl, v) {
        gl.uniform2uiv(this.addr, v);
      }
      function setValueV3uiArray(gl, v) {
        gl.uniform3uiv(this.addr, v);
      }
      function setValueV4uiArray(gl, v) {
        gl.uniform4uiv(this.addr, v);
      }
      function setValueT1Array(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.safeSetTexture2D(v[i2] || emptyTexture, units[i2]);
        }
      }
      function setValueT3DArray(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.setTexture3D(v[i2] || emptyTexture3d, units[i2]);
        }
      }
      function setValueT6Array(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.safeSetTextureCube(v[i2] || emptyCubeTexture, units[i2]);
        }
      }
      function setValueT2DArrayArray(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.setTexture2DArray(v[i2] || emptyTexture2dArray, units[i2]);
        }
      }
      function getPureArraySetter(type) {
        switch (type) {
          case 5126:
            return setValueV1fArray;
          case 35664:
            return setValueV2fArray;
          case 35665:
            return setValueV3fArray;
          case 35666:
            return setValueV4fArray;
          case 35674:
            return setValueM2Array;
          case 35675:
            return setValueM3Array;
          case 35676:
            return setValueM4Array;
          case 5124:
          case 35670:
            return setValueV1iArray;
          case 35667:
          case 35671:
            return setValueV2iArray;
          case 35668:
          case 35672:
            return setValueV3iArray;
          case 35669:
          case 35673:
            return setValueV4iArray;
          case 5125:
            return setValueV1uiArray;
          case 36294:
            return setValueV2uiArray;
          case 36295:
            return setValueV3uiArray;
          case 36296:
            return setValueV4uiArray;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT1Array;
          case 35679:
          case 36299:
          case 36307:
            return setValueT3DArray;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT6Array;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return setValueT2DArrayArray;
        }
      }
      function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter(activeInfo.type);
      }
      function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
      }
      PureArrayUniform.prototype.updateCache = function(data) {
        const cache = this.cache;
        if (data instanceof Float32Array && cache.length !== data.length) {
          this.cache = new Float32Array(data.length);
        }
        copyArray(cache, data);
      };
      function StructuredUniform(id) {
        this.id = id;
        this.seq = [];
        this.map = {};
      }
      StructuredUniform.prototype.setValue = function(gl, value, textures) {
        const seq = this.seq;
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2];
          u.setValue(gl, value[u.id], textures);
        }
      };
      const RePathPart = /(\w+)(\])?(\[|\.)?/g;
      function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
      }
      function parseUniform(activeInfo, addr, container) {
        const path = activeInfo.name, pathLength = path.length;
        RePathPart.lastIndex = 0;
        while (true) {
          const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
          let id = match[1];
          const idIsIndex = match[2] === "]", subscript = match[3];
          if (idIsIndex)
            id = id | 0;
          if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
            addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
          } else {
            const map = container.map;
            let next = map[id];
            if (next === void 0) {
              next = new StructuredUniform(id);
              addUniform(container, next);
            }
            container = next;
          }
        }
      }
      function WebGLUniforms(gl, program) {
        this.seq = [];
        this.map = {};
        const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i2 = 0; i2 < n; ++i2) {
          const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
          parseUniform(info, addr, this);
        }
      }
      WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
        const u = this.map[name];
        if (u !== void 0)
          u.setValue(gl, value, textures);
      };
      WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        const v = object[name];
        if (v !== void 0)
          this.setValue(gl, name, v);
      };
      WebGLUniforms.upload = function(gl, seq, values, textures) {
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2], v = values[u.id];
          if (v.needsUpdate !== false) {
            u.setValue(gl, v.value, textures);
          }
        }
      };
      WebGLUniforms.seqWithValue = function(seq, values) {
        const r2 = [];
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2];
          if (u.id in values)
            r2.push(u);
        }
        return r2;
      };
      function WebGLShader(gl, type, string) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        return shader;
      }
      let programIdCount = 0;
      function addLineNumbers(string) {
        const lines = string.split("\n");
        for (let i2 = 0; i2 < lines.length; i2++) {
          lines[i2] = i2 + 1 + ": " + lines[i2];
        }
        return lines.join("\n");
      }
      function getEncodingComponents(encoding) {
        switch (encoding) {
          case LinearEncoding:
            return ["Linear", "( value )"];
          case sRGBEncoding:
            return ["sRGB", "( value )"];
          case RGBEEncoding:
            return ["RGBE", "( value )"];
          case RGBM7Encoding:
            return ["RGBM", "( value, 7.0 )"];
          case RGBM16Encoding:
            return ["RGBM", "( value, 16.0 )"];
          case RGBDEncoding:
            return ["RGBD", "( value, 256.0 )"];
          case GammaEncoding:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          default:
            console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
            return ["Linear", "( value )"];
        }
      }
      function getShaderErrors(gl, shader, type) {
        const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        const errors = gl.getShaderInfoLog(shader).trim();
        if (status && errors === "")
          return "";
        return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl.getShaderSource(shader));
      }
      function getTexelDecodingFunction(functionName, encoding) {
        const components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
      }
      function getTexelEncodingFunction(functionName, encoding) {
        const components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
      }
      function getToneMappingFunction(functionName, toneMapping) {
        let toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping:
            toneMappingName = "Linear";
            break;
          case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;
          case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;
          case ACESFilmicToneMapping:
            toneMappingName = "ACESFilmic";
            break;
          case CustomToneMapping:
            toneMappingName = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
            toneMappingName = "Linear";
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
      }
      function generateExtensions(parameters) {
        const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
        return chunks.filter(filterEmptyLine).join("\n");
      }
      function generateDefines(defines) {
        const chunks = [];
        for (const name in defines) {
          const value = defines[name];
          if (value === false)
            continue;
          chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
      }
      function fetchAttributeLocations(gl, program) {
        const attributes = {};
        const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (let i2 = 0; i2 < n; i2++) {
          const info = gl.getActiveAttrib(program, i2);
          const name = info.name;
          let locationSize = 1;
          if (info.type === gl.FLOAT_MAT2)
            locationSize = 2;
          if (info.type === gl.FLOAT_MAT3)
            locationSize = 3;
          if (info.type === gl.FLOAT_MAT4)
            locationSize = 4;
          attributes[name] = {
            type: info.type,
            location: gl.getAttribLocation(program, name),
            locationSize
          };
        }
        return attributes;
      }
      function filterEmptyLine(string) {
        return string !== "";
      }
      function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
      }
      function replaceClippingPlaneNums(string, parameters) {
        return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
      }
      const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function resolveIncludes(string) {
        return string.replace(includePattern, includeReplacer);
      }
      function includeReplacer(match, include) {
        const string = ShaderChunk[include];
        if (string === void 0) {
          throw new Error("Can not resolve #include <" + include + ">");
        }
        return resolveIncludes(string);
      }
      const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
      const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function unrollLoops(string) {
        return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
      }
      function deprecatedLoopReplacer(match, start, end, snippet) {
        console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
        return loopReplacer(match, start, end, snippet);
      }
      function loopReplacer(match, start, end, snippet) {
        let string = "";
        for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
          string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
        }
        return string;
      }
      function generatePrecision(parameters) {
        let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
        if (parameters.precision === "highp") {
          precisionstring += "\n#define HIGH_PRECISION";
        } else if (parameters.precision === "mediump") {
          precisionstring += "\n#define MEDIUM_PRECISION";
        } else if (parameters.precision === "lowp") {
          precisionstring += "\n#define LOW_PRECISION";
        }
        return precisionstring;
      }
      function generateShadowMapTypeDefine(parameters) {
        let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        if (parameters.shadowMapType === PCFShadowMap2) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
        } else if (parameters.shadowMapType === PCFSoftShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
        } else if (parameters.shadowMapType === VSMShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
        }
        return shadowMapTypeDefine;
      }
      function generateEnvMapTypeDefine(parameters) {
        let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeReflectionMapping:
            case CubeRefractionMapping:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE";
              break;
            case CubeUVReflectionMapping:
            case CubeUVRefractionMapping:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        }
        return envMapTypeDefine;
      }
      function generateEnvMapModeDefine(parameters) {
        let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeRefractionMapping:
            case CubeUVRefractionMapping:
              envMapModeDefine = "ENVMAP_MODE_REFRACTION";
              break;
          }
        }
        return envMapModeDefine;
      }
      function generateEnvMapBlendingDefine(parameters) {
        let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
        if (parameters.envMap) {
          switch (parameters.combine) {
            case MultiplyOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case MixOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
              break;
            case AddOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
              break;
          }
        }
        return envMapBlendingDefine;
      }
      function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
        const gl = renderer.getContext();
        const defines = parameters.defines;
        let vertexShader = parameters.vertexShader;
        let fragmentShader = parameters.fragmentShader;
        const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
        const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
        const envMapModeDefine = generateEnvMapModeDefine(parameters);
        const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
        const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
        const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
        const customDefines = generateDefines(defines);
        const program = gl.createProgram();
        let prefixVertex, prefixFragment;
        let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
        if (parameters.isRawShaderMaterial) {
          prefixVertex = [customDefines].filter(filterEmptyLine).join("\n");
          if (prefixVertex.length > 0) {
            prefixVertex += "\n";
          }
          prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join("\n");
          if (prefixFragment.length > 0) {
            prefixFragment += "\n";
          }
        } else {
          prefixVertex = [generatePrecision(parameters), "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.instancing ? "#define USE_INSTANCING" : "", parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "", parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.transmission ? "#define USE_TRANSMISSION" : "", parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "", parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n");
          prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            "#define GAMMA_FACTOR " + gammaFactorDefine,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.matcap ? "#define USE_MATCAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapTypeDefine : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.envMap ? "#define " + envMapBlendingDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.alphaTest ? "#define USE_ALPHATEST" : "",
            parameters.sheen ? "#define USE_SHEEN" : "",
            parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            parameters.transmission ? "#define USE_TRANSMISSION" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
            parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            parameters.toneMapping !== NoToneMapping2 ? "#define TONE_MAPPING" : "",
            parameters.toneMapping !== NoToneMapping2 ? ShaderChunk["tonemapping_pars_fragment"] : "",
            parameters.toneMapping !== NoToneMapping2 ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
            parameters.dithering ? "#define DITHERING" : "",
            parameters.format === RGBFormat ? "#define OPAQUE" : "",
            ShaderChunk["encodings_pars_fragment"],
            parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
            parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
            parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
            parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
            parameters.specularColorMap ? getTexelDecodingFunction("specularColorMapTexelToLinear", parameters.specularColorMapEncoding) : "",
            parameters.sheenColorMap ? getTexelDecodingFunction("sheenColorMapTexelToLinear", parameters.sheenColorMapEncoding) : "",
            parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
            getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
            parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
            "\n"
          ].filter(filterEmptyLine).join("\n");
        }
        vertexShader = resolveIncludes(vertexShader);
        vertexShader = replaceLightNums(vertexShader, parameters);
        vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
        fragmentShader = resolveIncludes(fragmentShader);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
        vertexShader = unrollLoops(vertexShader);
        fragmentShader = unrollLoops(fragmentShader);
        if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
          versionString = "#version 300 es\n";
          prefixVertex = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex;
          prefixFragment = ["#define varying in", parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;", parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment;
        }
        const vertexGlsl = versionString + prefixVertex + vertexShader;
        const fragmentGlsl = versionString + prefixFragment + fragmentShader;
        const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (parameters.index0AttributeName !== void 0) {
          gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
        } else if (parameters.morphTargets === true) {
          gl.bindAttribLocation(program, 0, "position");
        }
        gl.linkProgram(program);
        if (renderer.debug.checkShaderErrors) {
          const programLog = gl.getProgramInfoLog(program).trim();
          const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
          const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
          let runnable = true;
          let haveDiagnostics = true;
          if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
          } else if (programLog !== "") {
            console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
          } else if (vertexLog === "" || fragmentLog === "") {
            haveDiagnostics = false;
          }
          if (haveDiagnostics) {
            this.diagnostics = {
              runnable,
              programLog,
              vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
              },
              fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
              }
            };
          }
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        let cachedUniforms;
        this.getUniforms = function() {
          if (cachedUniforms === void 0) {
            cachedUniforms = new WebGLUniforms(gl, program);
          }
          return cachedUniforms;
        };
        let cachedAttributes;
        this.getAttributes = function() {
          if (cachedAttributes === void 0) {
            cachedAttributes = fetchAttributeLocations(gl, program);
          }
          return cachedAttributes;
        };
        this.destroy = function() {
          bindingStates.releaseStatesOfProgram(this);
          gl.deleteProgram(program);
          this.program = void 0;
        };
        this.name = parameters.shaderName;
        this.id = programIdCount++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      }
      function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
        const programs = [];
        const isWebGL2 = capabilities.isWebGL2;
        const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        const floatVertexTextures = capabilities.floatVertexTextures;
        const maxVertexUniforms = capabilities.maxVertexUniforms;
        const vertexTextures = capabilities.vertexTextures;
        let precision = capabilities.precision;
        const shaderIDs = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        const parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", , "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "specularIntensityMap", "specularColorMap", "specularColorMapEncoding", "transmission", "transmissionMap", "thicknessMap", "sheen", "sheenColorMap", "sheenColorMapEncoding", "sheenRoughnessMap"];
        function getMaxBones(object) {
          const skeleton = object.skeleton;
          const bones = skeleton.bones;
          if (floatVertexTextures) {
            return 1024;
          } else {
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
              console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
              return 0;
            }
            return maxBones;
          }
        }
        function getTextureEncodingFromMap(map) {
          let encoding;
          if (map && map.isTexture) {
            encoding = map.encoding;
          } else if (map && map.isWebGLRenderTarget) {
            console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
            encoding = map.texture.encoding;
          } else {
            encoding = LinearEncoding;
          }
          return encoding;
        }
        function getParameters(material2, lights, shadows, scene, object) {
          const fog = scene.fog;
          const environment = material2.isMeshStandardMaterial ? scene.environment : null;
          const envMap = (material2.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material2.envMap || environment);
          const shaderID = shaderIDs[material2.type];
          const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
          if (material2.precision !== null) {
            precision = capabilities.getMaxPrecision(material2.precision);
            if (precision !== material2.precision) {
              console.warn("THREE.WebGLProgram.getParameters:", material2.precision, "not supported, using", precision, "instead.");
            }
          }
          let vertexShader, fragmentShader;
          if (shaderID) {
            const shader = ShaderLib[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
          } else {
            vertexShader = material2.vertexShader;
            fragmentShader = material2.fragmentShader;
          }
          const currentRenderTarget = renderer.getRenderTarget();
          const useAlphaTest = material2.alphaTest > 0;
          const useClearcoat = material2.clearcoat > 0;
          const parameters = {
            isWebGL2,
            shaderID,
            shaderName: material2.type,
            vertexShader,
            fragmentShader,
            defines: material2.defines,
            isRawShaderMaterial: material2.isRawShaderMaterial === true,
            glslVersion: material2.glslVersion,
            precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material2.map,
            mapEncoding: getTextureEncodingFromMap(material2.map),
            matcap: !!material2.matcap,
            matcapEncoding: getTextureEncodingFromMap(material2.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material2.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material2.lightMap),
            aoMap: !!material2.aoMap,
            emissiveMap: !!material2.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material2.emissiveMap),
            bumpMap: !!material2.bumpMap,
            normalMap: !!material2.normalMap,
            objectSpaceNormalMap: material2.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material2.normalMapType === TangentSpaceNormalMap,
            clearcoat: useClearcoat,
            clearcoatMap: useClearcoat && !!material2.clearcoatMap,
            clearcoatRoughnessMap: useClearcoat && !!material2.clearcoatRoughnessMap,
            clearcoatNormalMap: useClearcoat && !!material2.clearcoatNormalMap,
            displacementMap: !!material2.displacementMap,
            roughnessMap: !!material2.roughnessMap,
            metalnessMap: !!material2.metalnessMap,
            specularMap: !!material2.specularMap,
            specularIntensityMap: !!material2.specularIntensityMap,
            specularColorMap: !!material2.specularColorMap,
            specularColorMapEncoding: getTextureEncodingFromMap(material2.specularColorMap),
            alphaMap: !!material2.alphaMap,
            alphaTest: useAlphaTest,
            gradientMap: !!material2.gradientMap,
            sheen: material2.sheen > 0,
            sheenColorMap: !!material2.sheenColorMap,
            sheenColorMapEncoding: getTextureEncodingFromMap(material2.sheenColorMap),
            sheenRoughnessMap: !!material2.sheenRoughnessMap,
            transmission: material2.transmission > 0,
            transmissionMap: !!material2.transmissionMap,
            thicknessMap: !!material2.thicknessMap,
            combine: material2.combine,
            vertexTangents: !!material2.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
            vertexColors: material2.vertexColors,
            vertexAlphas: material2.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
            vertexUvs: !!material2.map || !!material2.bumpMap || !!material2.normalMap || !!material2.specularMap || !!material2.alphaMap || !!material2.emissiveMap || !!material2.roughnessMap || !!material2.metalnessMap || !!material2.clearcoatMap || !!material2.clearcoatRoughnessMap || !!material2.clearcoatNormalMap || !!material2.displacementMap || !!material2.transmissionMap || !!material2.thicknessMap || !!material2.specularIntensityMap || !!material2.specularColorMap || !!material2.sheenColorMap || material2.sheenRoughnessMap,
            uvsVertexOnly: !(!!material2.map || !!material2.bumpMap || !!material2.normalMap || !!material2.specularMap || !!material2.alphaMap || !!material2.emissiveMap || !!material2.roughnessMap || !!material2.metalnessMap || !!material2.clearcoatNormalMap || material2.transmission > 0 || !!material2.transmissionMap || !!material2.thicknessMap || !!material2.specularIntensityMap || !!material2.specularColorMap || material2.sheen > 0 || !!material2.sheenColorMap || !!material2.sheenRoughnessMap) && !!material2.displacementMap,
            fog: !!fog,
            useFog: material2.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: !!material2.flatShading,
            sizeAttenuation: material2.sizeAttenuation,
            logarithmicDepthBuffer,
            skinning: object.isSkinnedMesh === true && maxBones > 0,
            maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
            morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
            morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            format: material2.format,
            dithering: material2.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material2.toneMapped ? renderer.toneMapping : NoToneMapping2,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material2.premultipliedAlpha,
            doubleSided: material2.side === DoubleSide,
            flipSided: material2.side === BackSide,
            depthPacking: material2.depthPacking !== void 0 ? material2.depthPacking : false,
            index0AttributeName: material2.index0AttributeName,
            extensionDerivatives: material2.extensions && material2.extensions.derivatives,
            extensionFragDepth: material2.extensions && material2.extensions.fragDepth,
            extensionDrawBuffers: material2.extensions && material2.extensions.drawBuffers,
            extensionShaderTextureLOD: material2.extensions && material2.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
            customProgramCacheKey: material2.customProgramCacheKey()
          };
          return parameters;
        }
        function getProgramCacheKey(parameters) {
          const array = [];
          if (parameters.shaderID) {
            array.push(parameters.shaderID);
          } else {
            array.push(hashString(parameters.fragmentShader));
            array.push(hashString(parameters.vertexShader));
          }
          if (parameters.defines !== void 0) {
            for (const name in parameters.defines) {
              array.push(name);
              array.push(parameters.defines[name]);
            }
          }
          if (parameters.isRawShaderMaterial === false) {
            for (let i2 = 0; i2 < parameterNames.length; i2++) {
              array.push(parameters[parameterNames[i2]]);
            }
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
          }
          array.push(parameters.customProgramCacheKey);
          return array.join();
        }
        function getUniforms(material2) {
          const shaderID = shaderIDs[material2.type];
          let uniforms;
          if (shaderID) {
            const shader = ShaderLib[shaderID];
            uniforms = UniformsUtils.clone(shader.uniforms);
          } else {
            uniforms = material2.uniforms;
          }
          return uniforms;
        }
        function acquireProgram(parameters, cacheKey) {
          let program;
          for (let p = 0, pl = programs.length; p < pl; p++) {
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
              program = preexistingProgram;
              ++program.usedTimes;
              break;
            }
          }
          if (program === void 0) {
            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
          }
          return program;
        }
        function releaseProgram(program) {
          if (--program.usedTimes === 0) {
            const i2 = programs.indexOf(program);
            programs[i2] = programs[programs.length - 1];
            programs.pop();
            program.destroy();
          }
        }
        return {
          getParameters,
          getProgramCacheKey,
          getUniforms,
          acquireProgram,
          releaseProgram,
          programs
        };
      }
      function WebGLProperties() {
        let properties = new WeakMap();
        function get(object) {
          let map = properties.get(object);
          if (map === void 0) {
            map = {};
            properties.set(object, map);
          }
          return map;
        }
        function remove(object) {
          properties.delete(object);
        }
        function update(object, key, value) {
          properties.get(object)[key] = value;
        }
        function dispose() {
          properties = new WeakMap();
        }
        return {
          get,
          remove,
          update,
          dispose
        };
      }
      function painterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
          return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
          return a.renderOrder - b.renderOrder;
        } else if (a.program !== b.program) {
          return a.program.id - b.program.id;
        } else if (a.material.id !== b.material.id) {
          return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
          return a.z - b.z;
        } else {
          return a.id - b.id;
        }
      }
      function reversePainterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
          return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
          return a.renderOrder - b.renderOrder;
        } else if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return a.id - b.id;
        }
      }
      function WebGLRenderList(properties) {
        const renderItems = [];
        let renderItemsIndex = 0;
        const opaque = [];
        const transmissive = [];
        const transparent = [];
        const defaultProgram = {
          id: -1
        };
        function init2() {
          renderItemsIndex = 0;
          opaque.length = 0;
          transmissive.length = 0;
          transparent.length = 0;
        }
        function getNextRenderItem(object, geometry2, material2, groupOrder, z, group) {
          let renderItem = renderItems[renderItemsIndex];
          const materialProperties = properties.get(material2);
          if (renderItem === void 0) {
            renderItem = {
              id: object.id,
              object,
              geometry: geometry2,
              material: material2,
              program: materialProperties.program || defaultProgram,
              groupOrder,
              renderOrder: object.renderOrder,
              z,
              group
            };
            renderItems[renderItemsIndex] = renderItem;
          } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry2;
            renderItem.material = material2;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z;
            renderItem.group = group;
          }
          renderItemsIndex++;
          return renderItem;
        }
        function push(object, geometry2, material2, groupOrder, z, group) {
          const renderItem = getNextRenderItem(object, geometry2, material2, groupOrder, z, group);
          if (material2.transmission > 0) {
            transmissive.push(renderItem);
          } else if (material2.transparent === true) {
            transparent.push(renderItem);
          } else {
            opaque.push(renderItem);
          }
        }
        function unshift(object, geometry2, material2, groupOrder, z, group) {
          const renderItem = getNextRenderItem(object, geometry2, material2, groupOrder, z, group);
          if (material2.transmission > 0) {
            transmissive.unshift(renderItem);
          } else if (material2.transparent === true) {
            transparent.unshift(renderItem);
          } else {
            opaque.unshift(renderItem);
          }
        }
        function sort(customOpaqueSort, customTransparentSort) {
          if (opaque.length > 1)
            opaque.sort(customOpaqueSort || painterSortStable);
          if (transmissive.length > 1)
            transmissive.sort(customTransparentSort || reversePainterSortStable);
          if (transparent.length > 1)
            transparent.sort(customTransparentSort || reversePainterSortStable);
        }
        function finish() {
          for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
            const renderItem = renderItems[i2];
            if (renderItem.id === null)
              break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
          }
        }
        return {
          opaque,
          transmissive,
          transparent,
          init: init2,
          push,
          unshift,
          finish,
          sort
        };
      }
      function WebGLRenderLists(properties) {
        let lists = new WeakMap();
        function get(scene, renderCallDepth) {
          let list;
          if (lists.has(scene) === false) {
            list = new WebGLRenderList(properties);
            lists.set(scene, [list]);
          } else {
            if (renderCallDepth >= lists.get(scene).length) {
              list = new WebGLRenderList(properties);
              lists.get(scene).push(list);
            } else {
              list = lists.get(scene)[renderCallDepth];
            }
          }
          return list;
        }
        function dispose() {
          lists = new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      function UniformsCache() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  direction: new Vector34(),
                  color: new Color()
                };
                break;
              case "SpotLight":
                uniforms = {
                  position: new Vector34(),
                  direction: new Vector34(),
                  color: new Color(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                uniforms = {
                  position: new Vector34(),
                  color: new Color(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                uniforms = {
                  direction: new Vector34(),
                  skyColor: new Color(),
                  groundColor: new Color()
                };
                break;
              case "RectAreaLight":
                uniforms = {
                  color: new Color(),
                  position: new Vector34(),
                  halfWidth: new Vector34(),
                  halfHeight: new Vector34()
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      function ShadowUniformsCache() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector2()
                };
                break;
              case "SpotLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector2()
                };
                break;
              case "PointLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector2(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      let nextVersion = 0;
      function shadowCastingLightsFirst(lightA, lightB) {
        return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
      }
      function WebGLLights(extensions, capabilities) {
        const cache = new UniformsCache();
        const shadowCache = ShadowUniformsCache();
        const state = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: []
        };
        for (let i2 = 0; i2 < 9; i2++)
          state.probe.push(new Vector34());
        const vector3 = new Vector34();
        const matrix4 = new Matrix4();
        const matrix42 = new Matrix4();
        function setup2(lights, physicallyCorrectLights) {
          let r2 = 0, g = 0, b = 0;
          for (let i2 = 0; i2 < 9; i2++)
            state.probe[i2].set(0, 0, 0);
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          let numDirectionalShadows = 0;
          let numPointShadows = 0;
          let numSpotShadows = 0;
          lights.sort(shadowCastingLightsFirst);
          const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
          for (let i2 = 0, l = lights.length; i2 < l; i2++) {
            const light = lights[i2];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
              r2 += color.r * intensity * scaleFactor;
              g += color.g * intensity * scaleFactor;
              b += color.b * intensity * scaleFactor;
            } else if (light.isLightProbe) {
              for (let j = 0; j < 9; j++) {
                state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
              }
            } else if (light.isDirectionalLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state.directionalShadow[directionalLength] = shadowUniforms;
                state.directionalShadowMap[directionalLength] = shadowMap;
                state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                numDirectionalShadows++;
              }
              state.directional[directionalLength] = uniforms;
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = cache.get(light);
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
              uniforms.distance = distance;
              uniforms.coneCos = Math.cos(light.angle);
              uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state.spotShadow[spotLength] = shadowUniforms;
                state.spotShadowMap[spotLength] = shadowMap;
                state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                numSpotShadows++;
              }
              state.spot[spotLength] = uniforms;
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(color).multiplyScalar(intensity);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              state.rectArea[rectAreaLength] = uniforms;
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
              uniforms.distance = light.distance;
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                shadowUniforms.shadowCameraNear = shadow.camera.near;
                shadowUniforms.shadowCameraFar = shadow.camera.far;
                state.pointShadow[pointLength] = shadowUniforms;
                state.pointShadowMap[pointLength] = shadowMap;
                state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                numPointShadows++;
              }
              state.point[pointLength] = uniforms;
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = cache.get(light);
              uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
              uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
              state.hemi[hemiLength] = uniforms;
              hemiLength++;
            }
          }
          if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
              state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
              state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
            } else {
              if (extensions.has("OES_texture_float_linear") === true) {
                state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
              } else if (extensions.has("OES_texture_half_float_linear") === true) {
                state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
              } else {
                console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
              }
            }
          }
          state.ambient[0] = r2;
          state.ambient[1] = g;
          state.ambient[2] = b;
          const hash2 = state.hash;
          if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash2.directionalLength = directionalLength;
            hash2.pointLength = pointLength;
            hash2.spotLength = spotLength;
            hash2.rectAreaLength = rectAreaLength;
            hash2.hemiLength = hemiLength;
            hash2.numDirectionalShadows = numDirectionalShadows;
            hash2.numPointShadows = numPointShadows;
            hash2.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
          }
        }
        function setupView(lights, camera) {
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          const viewMatrix = camera.matrixWorldInverse;
          for (let i2 = 0, l = lights.length; i2 < l; i2++) {
            const light = lights[i2];
            if (light.isDirectionalLight) {
              const uniforms = state.directional[directionalLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = state.spot[spotLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = state.rectArea[rectAreaLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              matrix42.identity();
              matrix4.copy(light.matrixWorld);
              matrix4.premultiply(viewMatrix);
              matrix42.extractRotation(matrix4);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              uniforms.halfWidth.applyMatrix4(matrix42);
              uniforms.halfHeight.applyMatrix4(matrix42);
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = state.point[pointLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = state.hemi[hemiLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              uniforms.direction.transformDirection(viewMatrix);
              uniforms.direction.normalize();
              hemiLength++;
            }
          }
        }
        return {
          setup: setup2,
          setupView,
          state
        };
      }
      function WebGLRenderState(extensions, capabilities) {
        const lights = new WebGLLights(extensions, capabilities);
        const lightsArray = [];
        const shadowsArray = [];
        function init2() {
          lightsArray.length = 0;
          shadowsArray.length = 0;
        }
        function pushLight(light) {
          lightsArray.push(light);
        }
        function pushShadow(shadowLight) {
          shadowsArray.push(shadowLight);
        }
        function setupLights(physicallyCorrectLights) {
          lights.setup(lightsArray, physicallyCorrectLights);
        }
        function setupLightsView(camera) {
          lights.setupView(lightsArray, camera);
        }
        const state = {
          lightsArray,
          shadowsArray,
          lights
        };
        return {
          init: init2,
          state,
          setupLights,
          setupLightsView,
          pushLight,
          pushShadow
        };
      }
      function WebGLRenderStates(extensions, capabilities) {
        let renderStates = new WeakMap();
        function get(scene, renderCallDepth = 0) {
          let renderState;
          if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.set(scene, [renderState]);
          } else {
            if (renderCallDepth >= renderStates.get(scene).length) {
              renderState = new WebGLRenderState(extensions, capabilities);
              renderStates.get(scene).push(renderState);
            } else {
              renderState = renderStates.get(scene)[renderCallDepth];
            }
          }
          return renderState;
        }
        function dispose() {
          renderStates = new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      class MeshDepthMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDepthMaterial";
          this.depthPacking = BasicDepthPacking;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.depthPacking = source.depthPacking;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          return this;
        }
      }
      MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
      class MeshDistanceMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new Vector34();
          this.nearDistance = 1;
          this.farDistance = 1e3;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.referencePosition.copy(source.referencePosition);
          this.nearDistance = source.nearDistance;
          this.farDistance = source.farDistance;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          return this;
        }
      }
      MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
      const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
      const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      function WebGLShadowMap(_renderer, _objects, _capabilities) {
        let _frustum = new Frustum();
        const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({
          depthPacking: RGBADepthPacking
        }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
        const shadowSide = {
          0: BackSide,
          1: FrontSide,
          2: DoubleSide
        };
        const shadowMaterialVertical = new ShaderMaterial({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new Vector2()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: vertex,
          fragmentShader: fragment
        });
        const shadowMaterialHorizontal = shadowMaterialVertical.clone();
        shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
        const fullScreenTri = new BufferGeometry3();
        fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const fullScreenMesh = new Mesh3(fullScreenTri, shadowMaterialVertical);
        const scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap2;
        this.render = function(lights, scene, camera) {
          if (scope.enabled === false)
            return;
          if (scope.autoUpdate === false && scope.needsUpdate === false)
            return;
          if (lights.length === 0)
            return;
          const currentRenderTarget = _renderer.getRenderTarget();
          const activeCubeFace = _renderer.getActiveCubeFace();
          const activeMipmapLevel = _renderer.getActiveMipmapLevel();
          const _state = _renderer.state;
          _state.setBlending(NoBlending);
          _state.buffers.color.setClear(1, 1, 1, 1);
          _state.buffers.depth.setTest(true);
          _state.setScissorTest(false);
          for (let i2 = 0, il = lights.length; i2 < il; i2++) {
            const light = lights[i2];
            const shadow = light.shadow;
            if (shadow === void 0) {
              console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
              continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false)
              continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
              if (_shadowMapSize.x > _maxTextureSize) {
                _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                shadow.mapSize.x = _viewportSize.x;
              }
              if (_shadowMapSize.y > _maxTextureSize) {
                _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                shadow.mapSize.y = _viewportSize.y;
              }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
              const pars = {
                minFilter: LinearFilter,
                magFilter: LinearFilter,
                format: RGBAFormat
              };
              shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
              const pars = {
                minFilter: NearestFilter,
                magFilter: NearestFilter,
                format: RGBAFormat
              };
              shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for (let vp = 0; vp < viewportCount; vp++) {
              const viewport = shadow.getViewport(vp);
              _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
              _state.viewport(_viewport);
              shadow.updateMatrices(light, vp);
              _frustum = shadow.getFrustum();
              renderObject(scene, camera, shadow.camera, light, this.type);
            }
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
              VSMPass(shadow, camera);
            }
            shadow.needsUpdate = false;
          }
          scope.needsUpdate = false;
          _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
        };
        function VSMPass(shadow, camera) {
          const geometry2 = _objects.update(fullScreenMesh);
          if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
            shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialVertical.needsUpdate = true;
            shadowMaterialHorizontal.needsUpdate = true;
          }
          shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
          shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialVertical.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.mapPass);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry2, shadowMaterialVertical, fullScreenMesh, null);
          shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
          shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.map);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry2, shadowMaterialHorizontal, fullScreenMesh, null);
        }
        function getDepthMaterial(object, geometry2, material2, light, shadowCameraNear, shadowCameraFar, type) {
          let result = null;
          const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
          if (customMaterial !== void 0) {
            result = customMaterial;
          } else {
            result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
          }
          if (_renderer.localClippingEnabled && material2.clipShadows === true && material2.clippingPlanes.length !== 0 || material2.displacementMap && material2.displacementScale !== 0 || material2.alphaMap && material2.alphaTest > 0) {
            const keyA = result.uuid, keyB = material2.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === void 0) {
              materialsForVariant = {};
              _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === void 0) {
              cachedMaterial = result.clone();
              materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
          }
          result.visible = material2.visible;
          result.wireframe = material2.wireframe;
          if (type === VSMShadowMap) {
            result.side = material2.shadowSide !== null ? material2.shadowSide : material2.side;
          } else {
            result.side = material2.shadowSide !== null ? material2.shadowSide : shadowSide[material2.side];
          }
          result.alphaMap = material2.alphaMap;
          result.alphaTest = material2.alphaTest;
          result.clipShadows = material2.clipShadows;
          result.clippingPlanes = material2.clippingPlanes;
          result.clipIntersection = material2.clipIntersection;
          result.displacementMap = material2.displacementMap;
          result.displacementScale = material2.displacementScale;
          result.displacementBias = material2.displacementBias;
          result.wireframeLinewidth = material2.wireframeLinewidth;
          result.linewidth = material2.linewidth;
          if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
          }
          return result;
        }
        function renderObject(object, camera, shadowCamera, light, type) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
              object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              const geometry2 = _objects.update(object);
              const material2 = object.material;
              if (Array.isArray(material2)) {
                const groups = geometry2.groups;
                for (let k = 0, kl = groups.length; k < kl; k++) {
                  const group = groups[k];
                  const groupMaterial = material2[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry2, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial, object, group);
                  }
                }
              } else if (material2.visible) {
                const depthMaterial = getDepthMaterial(object, geometry2, material2, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial, object, null);
              }
            }
          }
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            renderObject(children[i2], camera, shadowCamera, light, type);
          }
        }
      }
      function WebGLState(gl, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function ColorBuffer() {
          let locked = false;
          const color = new Vector4();
          let currentColorMask = null;
          const currentColorClear = new Vector4(0, 0, 0, 0);
          return {
            setMask: function(colorMask) {
              if (currentColorMask !== colorMask && !locked) {
                gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                currentColorMask = colorMask;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(r2, g, b, a, premultipliedAlpha) {
              if (premultipliedAlpha === true) {
                r2 *= a;
                g *= a;
                b *= a;
              }
              color.set(r2, g, b, a);
              if (currentColorClear.equals(color) === false) {
                gl.clearColor(r2, g, b, a);
                currentColorClear.copy(color);
              }
            },
            reset: function() {
              locked = false;
              currentColorMask = null;
              currentColorClear.set(-1, 0, 0, 0);
            }
          };
        }
        function DepthBuffer() {
          let locked = false;
          let currentDepthMask = null;
          let currentDepthFunc = null;
          let currentDepthClear = null;
          return {
            setTest: function(depthTest) {
              if (depthTest) {
                enable(gl.DEPTH_TEST);
              } else {
                disable(gl.DEPTH_TEST);
              }
            },
            setMask: function(depthMask) {
              if (currentDepthMask !== depthMask && !locked) {
                gl.depthMask(depthMask);
                currentDepthMask = depthMask;
              }
            },
            setFunc: function(depthFunc) {
              if (currentDepthFunc !== depthFunc) {
                if (depthFunc) {
                  switch (depthFunc) {
                    case NeverDepth:
                      gl.depthFunc(gl.NEVER);
                      break;
                    case AlwaysDepth:
                      gl.depthFunc(gl.ALWAYS);
                      break;
                    case LessDepth:
                      gl.depthFunc(gl.LESS);
                      break;
                    case LessEqualDepth:
                      gl.depthFunc(gl.LEQUAL);
                      break;
                    case EqualDepth:
                      gl.depthFunc(gl.EQUAL);
                      break;
                    case GreaterEqualDepth:
                      gl.depthFunc(gl.GEQUAL);
                      break;
                    case GreaterDepth:
                      gl.depthFunc(gl.GREATER);
                      break;
                    case NotEqualDepth:
                      gl.depthFunc(gl.NOTEQUAL);
                      break;
                    default:
                      gl.depthFunc(gl.LEQUAL);
                  }
                } else {
                  gl.depthFunc(gl.LEQUAL);
                }
                currentDepthFunc = depthFunc;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(depth) {
              if (currentDepthClear !== depth) {
                gl.clearDepth(depth);
                currentDepthClear = depth;
              }
            },
            reset: function() {
              locked = false;
              currentDepthMask = null;
              currentDepthFunc = null;
              currentDepthClear = null;
            }
          };
        }
        function StencilBuffer() {
          let locked = false;
          let currentStencilMask = null;
          let currentStencilFunc = null;
          let currentStencilRef = null;
          let currentStencilFuncMask = null;
          let currentStencilFail = null;
          let currentStencilZFail = null;
          let currentStencilZPass = null;
          let currentStencilClear = null;
          return {
            setTest: function(stencilTest) {
              if (!locked) {
                if (stencilTest) {
                  enable(gl.STENCIL_TEST);
                } else {
                  disable(gl.STENCIL_TEST);
                }
              }
            },
            setMask: function(stencilMask) {
              if (currentStencilMask !== stencilMask && !locked) {
                gl.stencilMask(stencilMask);
                currentStencilMask = stencilMask;
              }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
              if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                currentStencilFunc = stencilFunc;
                currentStencilRef = stencilRef;
                currentStencilFuncMask = stencilMask;
              }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
              if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                currentStencilFail = stencilFail;
                currentStencilZFail = stencilZFail;
                currentStencilZPass = stencilZPass;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(stencil) {
              if (currentStencilClear !== stencil) {
                gl.clearStencil(stencil);
                currentStencilClear = stencil;
              }
            },
            reset: function() {
              locked = false;
              currentStencilMask = null;
              currentStencilFunc = null;
              currentStencilRef = null;
              currentStencilFuncMask = null;
              currentStencilFail = null;
              currentStencilZFail = null;
              currentStencilZPass = null;
              currentStencilClear = null;
            }
          };
        }
        const colorBuffer = new ColorBuffer();
        const depthBuffer = new DepthBuffer();
        const stencilBuffer = new StencilBuffer();
        let enabledCapabilities = {};
        let currentBoundFramebuffers = {};
        let currentProgram = null;
        let currentBlendingEnabled = false;
        let currentBlending = null;
        let currentBlendEquation = null;
        let currentBlendSrc = null;
        let currentBlendDst = null;
        let currentBlendEquationAlpha = null;
        let currentBlendSrcAlpha = null;
        let currentBlendDstAlpha = null;
        let currentPremultipledAlpha = false;
        let currentFlipSided = null;
        let currentCullFace = null;
        let currentLineWidth = null;
        let currentPolygonOffsetFactor = null;
        let currentPolygonOffsetUnits = null;
        const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let lineWidthAvailable = false;
        let version = 0;
        const glVersion = gl.getParameter(gl.VERSION);
        if (glVersion.indexOf("WebGL") !== -1) {
          version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 1;
        } else if (glVersion.indexOf("OpenGL ES") !== -1) {
          version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 2;
        }
        let currentTextureSlot = null;
        let currentBoundTextures = {};
        const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
        const viewportParam = gl.getParameter(gl.VIEWPORT);
        const currentScissor = new Vector4().fromArray(scissorParam);
        const currentViewport = new Vector4().fromArray(viewportParam);
        function createTexture(type, target, count) {
          const data = new Uint8Array(4);
          const texture = gl.createTexture();
          gl.bindTexture(type, texture);
          gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          for (let i2 = 0; i2 < count; i2++) {
            gl.texImage2D(target + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
          }
          return texture;
        }
        const emptyTextures = {};
        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(gl.DEPTH_TEST);
        depthBuffer.setFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(gl.CULL_FACE);
        setBlending(NoBlending);
        function enable(id) {
          if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
          }
        }
        function disable(id) {
          if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
          }
        }
        function bindFramebuffer(target, framebuffer) {
          if (currentBoundFramebuffers[target] !== framebuffer) {
            gl.bindFramebuffer(target, framebuffer);
            currentBoundFramebuffers[target] = framebuffer;
            if (isWebGL2) {
              if (target === gl.DRAW_FRAMEBUFFER) {
                currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
              }
              if (target === gl.FRAMEBUFFER) {
                currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
              }
            }
            return true;
          }
          return false;
        }
        function useProgram(program) {
          if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
          }
          return false;
        }
        const equationToGL = {
          [AddEquation]: gl.FUNC_ADD,
          [SubtractEquation]: gl.FUNC_SUBTRACT,
          [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
        };
        if (isWebGL2) {
          equationToGL[MinEquation] = gl.MIN;
          equationToGL[MaxEquation] = gl.MAX;
        } else {
          const extension = extensions.get("EXT_blend_minmax");
          if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
          }
        }
        const factorToGL = {
          [ZeroFactor]: gl.ZERO,
          [OneFactor]: gl.ONE,
          [SrcColorFactor]: gl.SRC_COLOR,
          [SrcAlphaFactor]: gl.SRC_ALPHA,
          [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
          [DstColorFactor]: gl.DST_COLOR,
          [DstAlphaFactor]: gl.DST_ALPHA,
          [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
          [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
          [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
          [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
        };
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
          if (blending === NoBlending) {
            if (currentBlendingEnabled === true) {
              disable(gl.BLEND);
              currentBlendingEnabled = false;
            }
            return;
          }
          if (currentBlendingEnabled === false) {
            enable(gl.BLEND);
            currentBlendingEnabled = true;
          }
          if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
              if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                gl.blendEquation(gl.FUNC_ADD);
                currentBlendEquation = AddEquation;
                currentBlendEquationAlpha = AddEquation;
              }
              if (premultipliedAlpha) {
                switch (blending) {
                  case NormalBlending:
                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending:
                    gl.blendFunc(gl.ONE, gl.ONE);
                    break;
                  case SubtractiveBlending:
                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case MultiplyBlending:
                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              } else {
                switch (blending) {
                  case NormalBlending:
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending:
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                    break;
                  case SubtractiveBlending:
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                    break;
                  case MultiplyBlending:
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              }
              currentBlendSrc = null;
              currentBlendDst = null;
              currentBlendSrcAlpha = null;
              currentBlendDstAlpha = null;
              currentBlending = blending;
              currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
          }
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
          currentBlending = blending;
          currentPremultipledAlpha = null;
        }
        function setMaterial(material2, frontFaceCW) {
          material2.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
          let flipSided = material2.side === BackSide;
          if (frontFaceCW)
            flipSided = !flipSided;
          setFlipSided(flipSided);
          material2.blending === NormalBlending && material2.transparent === false ? setBlending(NoBlending) : setBlending(material2.blending, material2.blendEquation, material2.blendSrc, material2.blendDst, material2.blendEquationAlpha, material2.blendSrcAlpha, material2.blendDstAlpha, material2.premultipliedAlpha);
          depthBuffer.setFunc(material2.depthFunc);
          depthBuffer.setTest(material2.depthTest);
          depthBuffer.setMask(material2.depthWrite);
          colorBuffer.setMask(material2.colorWrite);
          const stencilWrite = material2.stencilWrite;
          stencilBuffer.setTest(stencilWrite);
          if (stencilWrite) {
            stencilBuffer.setMask(material2.stencilWriteMask);
            stencilBuffer.setFunc(material2.stencilFunc, material2.stencilRef, material2.stencilFuncMask);
            stencilBuffer.setOp(material2.stencilFail, material2.stencilZFail, material2.stencilZPass);
          }
          setPolygonOffset(material2.polygonOffset, material2.polygonOffsetFactor, material2.polygonOffsetUnits);
          material2.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function setFlipSided(flipSided) {
          if (currentFlipSided !== flipSided) {
            if (flipSided) {
              gl.frontFace(gl.CW);
            } else {
              gl.frontFace(gl.CCW);
            }
            currentFlipSided = flipSided;
          }
        }
        function setCullFace(cullFace) {
          if (cullFace !== CullFaceNone) {
            enable(gl.CULL_FACE);
            if (cullFace !== currentCullFace) {
              if (cullFace === CullFaceBack) {
                gl.cullFace(gl.BACK);
              } else if (cullFace === CullFaceFront) {
                gl.cullFace(gl.FRONT);
              } else {
                gl.cullFace(gl.FRONT_AND_BACK);
              }
            }
          } else {
            disable(gl.CULL_FACE);
          }
          currentCullFace = cullFace;
        }
        function setLineWidth(width) {
          if (width !== currentLineWidth) {
            if (lineWidthAvailable)
              gl.lineWidth(width);
            currentLineWidth = width;
          }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
          if (polygonOffset) {
            enable(gl.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
              gl.polygonOffset(factor, units);
              currentPolygonOffsetFactor = factor;
              currentPolygonOffsetUnits = units;
            }
          } else {
            disable(gl.POLYGON_OFFSET_FILL);
          }
        }
        function setScissorTest(scissorTest) {
          if (scissorTest) {
            enable(gl.SCISSOR_TEST);
          } else {
            disable(gl.SCISSOR_TEST);
          }
        }
        function activeTexture(webglSlot) {
          if (webglSlot === void 0)
            webglSlot = gl.TEXTURE0 + maxTextures - 1;
          if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
          }
        }
        function bindTexture(webglType, webglTexture) {
          if (currentTextureSlot === null) {
            activeTexture();
          }
          let boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture === void 0) {
            boundTexture = {
              type: void 0,
              texture: void 0
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
          }
          if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
          }
        }
        function unbindTexture() {
          const boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture !== void 0 && boundTexture.type !== void 0) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = void 0;
            boundTexture.texture = void 0;
          }
        }
        function compressedTexImage2D() {
          try {
            gl.compressedTexImage2D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function texSubImage2D() {
          try {
            gl.texSubImage2D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function texStorage2D() {
          try {
            gl.texStorage2D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function texImage2D() {
          try {
            gl.texImage2D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function texImage3D() {
          try {
            gl.texImage3D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function scissor(scissor2) {
          if (currentScissor.equals(scissor2) === false) {
            gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
            currentScissor.copy(scissor2);
          }
        }
        function viewport(viewport2) {
          if (currentViewport.equals(viewport2) === false) {
            gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
            currentViewport.copy(viewport2);
          }
        }
        function reset() {
          gl.disable(gl.BLEND);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.POLYGON_OFFSET_FILL);
          gl.disable(gl.SCISSOR_TEST);
          gl.disable(gl.STENCIL_TEST);
          gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ONE, gl.ZERO);
          gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
          gl.colorMask(true, true, true, true);
          gl.clearColor(0, 0, 0, 0);
          gl.depthMask(true);
          gl.depthFunc(gl.LESS);
          gl.clearDepth(1);
          gl.stencilMask(4294967295);
          gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.clearStencil(0);
          gl.cullFace(gl.BACK);
          gl.frontFace(gl.CCW);
          gl.polygonOffset(0, 0);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          if (isWebGL2 === true) {
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
          }
          gl.useProgram(null);
          gl.lineWidth(1);
          gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          enabledCapabilities = {};
          currentTextureSlot = null;
          currentBoundTextures = {};
          currentBoundFramebuffers = {};
          currentProgram = null;
          currentBlendingEnabled = false;
          currentBlending = null;
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentPremultipledAlpha = false;
          currentFlipSided = null;
          currentCullFace = null;
          currentLineWidth = null;
          currentPolygonOffsetFactor = null;
          currentPolygonOffsetUnits = null;
          currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
          currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
          colorBuffer.reset();
          depthBuffer.reset();
          stencilBuffer.reset();
        }
        return {
          buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
          },
          enable,
          disable,
          bindFramebuffer,
          useProgram,
          setBlending,
          setMaterial,
          setFlipSided,
          setCullFace,
          setLineWidth,
          setPolygonOffset,
          setScissorTest,
          activeTexture,
          bindTexture,
          unbindTexture,
          compressedTexImage2D,
          texImage2D,
          texImage3D,
          texStorage2D,
          texSubImage2D,
          scissor,
          viewport,
          reset
        };
      }
      function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
        const isWebGL2 = capabilities.isWebGL2;
        const maxTextures = capabilities.maxTextures;
        const maxCubemapSize = capabilities.maxCubemapSize;
        const maxTextureSize = capabilities.maxTextureSize;
        const maxSamples = capabilities.maxSamples;
        const hasMultisampledRenderToTexture = extensions.has("WEBGL_multisampled_render_to_texture");
        const MultisampledRenderToTextureExtension = hasMultisampledRenderToTexture ? extensions.get("WEBGL_multisampled_render_to_texture") : void 0;
        const _videoTextures = new WeakMap();
        let _canvas2;
        let useOffscreenCanvas = false;
        try {
          useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch (err) {
        }
        function createCanvas(width, height) {
          return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
        }
        function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
          let scale2 = 1;
          if (image.width > maxSize || image.height > maxSize) {
            scale2 = maxSize / Math.max(image.width, image.height);
          }
          if (scale2 < 1 || needsPowerOfTwo === true) {
            if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
              const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
              const width = floor(scale2 * image.width);
              const height = floor(scale2 * image.height);
              if (_canvas2 === void 0)
                _canvas2 = createCanvas(width, height);
              const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
              canvas.width = width;
              canvas.height = height;
              const context = canvas.getContext("2d");
              context.drawImage(image, 0, 0, width, height);
              console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
              return canvas;
            } else {
              if ("data" in image) {
                console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
              }
              return image;
            }
          }
          return image;
        }
        function isPowerOfTwo$1(image) {
          return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
        }
        function textureNeedsPowerOfTwo(texture) {
          if (isWebGL2)
            return false;
          return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function textureNeedsGenerateMipmaps(texture, supportsMips) {
          return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function generateMipmap(target) {
          _gl.generateMipmap(target);
        }
        function getInternalFormat(internalFormatName, glFormat, glType) {
          if (isWebGL2 === false)
            return glFormat;
          if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== void 0)
              return _gl[internalFormatName];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
          }
          let internalFormat = glFormat;
          if (glFormat === _gl.RED) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.R32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.R16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.R8;
          }
          if (glFormat === _gl.RGB) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RGB32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RGB16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.RGB8;
          }
          if (glFormat === _gl.RGBA) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RGBA32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RGBA16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.RGBA8;
          }
          if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
            extensions.get("EXT_color_buffer_float");
          }
          return internalFormat;
        }
        function getMipLevels(texture, image, supportsMips) {
          if (textureNeedsGenerateMipmaps(texture, supportsMips) === true) {
            return Math.log2(Math.max(image.width, image.height)) + 1;
          } else if (texture.mipmaps.length > 0) {
            return texture.mipmaps.length;
          } else {
            return 1;
          }
        }
        function filterFallback(f3) {
          if (f3 === NearestFilter || f3 === NearestMipmapNearestFilter || f3 === NearestMipmapLinearFilter) {
            return _gl.NEAREST;
          }
          return _gl.LINEAR;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          deallocateTexture(texture);
          if (texture.isVideoTexture) {
            _videoTextures.delete(texture);
          }
          info.memory.textures--;
        }
        function onRenderTargetDispose(event) {
          const renderTarget = event.target;
          renderTarget.removeEventListener("dispose", onRenderTargetDispose);
          deallocateRenderTarget(renderTarget);
        }
        function deallocateTexture(texture) {
          const textureProperties = properties.get(texture);
          if (textureProperties.__webglInit === void 0)
            return;
          _gl.deleteTexture(textureProperties.__webglTexture);
          properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          if (!renderTarget)
            return;
          if (textureProperties.__webglTexture !== void 0) {
            _gl.deleteTexture(textureProperties.__webglTexture);
            info.memory.textures--;
          }
          if (renderTarget.depthTexture) {
            renderTarget.depthTexture.dispose();
          }
          if (renderTarget.isWebGLCubeRenderTarget) {
            for (let i2 = 0; i2 < 6; i2++) {
              _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
              if (renderTargetProperties.__webglDepthbuffer)
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
            }
          } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer)
              _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
          }
          if (renderTarget.isWebGLMultipleRenderTargets) {
            for (let i2 = 0, il = texture.length; i2 < il; i2++) {
              const attachmentProperties = properties.get(texture[i2]);
              if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
              }
              properties.remove(texture[i2]);
            }
          }
          properties.remove(texture);
          properties.remove(renderTarget);
        }
        let textureUnits = 0;
        function resetTextureUnits() {
          textureUnits = 0;
        }
        function allocateTextureUnit() {
          const textureUnit = textureUnits;
          if (textureUnit >= maxTextures) {
            console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
          }
          textureUnits += 1;
          return textureUnit;
        }
        function setTexture2D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.isVideoTexture)
            updateVideoTexture(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === void 0) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            } else if (image.complete === false) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            } else {
              uploadTexture(textureProperties, texture, slot);
              return;
            }
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTexture2DArray(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
        }
        function setTexture3D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        }
        const wrappingToGL = {
          [RepeatWrapping]: _gl.REPEAT,
          [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
          [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
        };
        const filterToGL = {
          [NearestFilter]: _gl.NEAREST,
          [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
          [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
          [LinearFilter]: _gl.LINEAR,
          [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
          [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
        };
        function setTextureParameters(textureType, texture, supportsMips) {
          if (supportsMips) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
          } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
            }
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
            }
          }
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
              return;
            if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false)
              return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
              _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
              properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
          }
        }
        function initTexture(textureProperties, texture) {
          if (textureProperties.__webglInit === void 0) {
            textureProperties.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
        function uploadTexture(textureProperties, texture, slot) {
          let textureType = _gl.TEXTURE_2D;
          if (texture.isDataTexture2DArray)
            textureType = _gl.TEXTURE_2D_ARRAY;
          if (texture.isDataTexture3D)
            textureType = _gl.TEXTURE_3D;
          initTexture(textureProperties, texture);
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(textureType, textureProperties.__webglTexture);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
          _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
          const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
          const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
          const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format);
          let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          setTextureParameters(textureType, texture, supportsMips);
          let mipmap;
          const mipmaps = texture.mipmaps;
          if (texture.isDepthTexture) {
            glInternalFormat = _gl.DEPTH_COMPONENT;
            if (isWebGL2) {
              if (texture.type === FloatType) {
                glInternalFormat = _gl.DEPTH_COMPONENT32F;
              } else if (texture.type === UnsignedIntType) {
                glInternalFormat = _gl.DEPTH_COMPONENT24;
              } else if (texture.type === UnsignedInt248Type) {
                glInternalFormat = _gl.DEPTH24_STENCIL8;
              } else {
                glInternalFormat = _gl.DEPTH_COMPONENT16;
              }
            } else {
              if (texture.type === FloatType) {
                console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
              }
            }
            if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
              if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                texture.type = UnsignedShortType;
                glType = utils.convert(texture.type);
              }
            }
            if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
              glInternalFormat = _gl.DEPTH_STENCIL;
              if (texture.type !== UnsignedInt248Type) {
                console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                texture.type = UnsignedInt248Type;
                glType = utils.convert(texture.type);
              }
            }
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          } else if (texture.isDataTexture) {
            if (mipmaps.length > 0 && supportsMips) {
              for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
                mipmap = mipmaps[i2];
                state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
              texture.generateMipmaps = false;
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
          } else if (texture.isCompressedTexture) {
            for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
              mipmap = mipmaps[i2];
              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (glFormat !== null) {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          } else if (texture.isDataTexture2DArray) {
            state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          } else if (texture.isDataTexture3D) {
            state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          } else {
            const levels = getMipLevels(texture, image, supportsMips);
            const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
            const allocateMemory = textureProperties.__version === void 0;
            if (mipmaps.length > 0 && supportsMips) {
              if (useTexStorage && allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
              }
              for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
                mipmap = mipmaps[i2];
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, glFormat, glType, mipmap);
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
                }
              }
              texture.generateMipmaps = false;
            } else {
              if (useTexStorage) {
                if (allocateMemory) {
                  state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                }
                state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
              }
            }
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(textureType);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        }
        function uploadCubeTexture(textureProperties, texture, slot) {
          if (texture.image.length !== 6)
            return;
          initTexture(textureProperties, texture);
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
          _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
          const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
          const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
          const cubeImage = [];
          for (let i2 = 0; i2 < 6; i2++) {
            if (!isCompressed && !isDataTexture) {
              cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
            } else {
              cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
            }
          }
          const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
          let mipmaps;
          if (isCompressed) {
            for (let i2 = 0; i2 < 6; i2++) {
              mipmaps = cubeImage[i2].mipmaps;
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                  if (glFormat !== null) {
                    state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          } else {
            mipmaps = texture.mipmaps;
            for (let i2 = 0; i2 < 6; i2++) {
              if (isDataTexture) {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
                for (let j = 0; j < mipmaps.length; j++) {
                  const mipmap = mipmaps[j];
                  const mipmapImage = mipmap.image[i2].image;
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
                for (let j = 0; j < mipmaps.length; j++) {
                  const mipmap = mipmaps[j];
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
                }
              }
            }
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(_gl.TEXTURE_CUBE_MAP);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const renderTargetProperties = properties.get(renderTarget);
          if (!renderTargetProperties.__hasExternalTextures) {
            if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
              state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
            } else {
              state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            }
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (renderTarget.useRenderToTexture) {
            MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
          } else {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = _gl.DEPTH_COMPONENT16;
            if (isMultisample || renderTarget.useRenderToTexture) {
              const depthTexture = renderTarget.depthTexture;
              if (depthTexture && depthTexture.isDepthTexture) {
                if (depthTexture.type === FloatType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (depthTexture.type === UnsignedIntType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT24;
                }
              }
              const samples = getRenderTargetSamples(renderTarget);
              if (renderTarget.useRenderToTexture) {
                MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              } else {
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              }
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            const samples = getRenderTargetSamples(renderTarget);
            if (isMultisample && renderTarget.useRenderbuffer) {
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else {
            const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
            const glFormat = utils.convert(texture.format);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
            const samples = getRenderTargetSamples(renderTarget);
            if (isMultisample && renderTarget.useRenderbuffer) {
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
          const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
          if (isCube)
            throw new Error("Depth Texture with cube render targets is not supported");
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          }
          if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
          }
          setTexture2D(renderTarget.depthTexture, 0);
          const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
          const samples = getRenderTargetSamples(renderTarget);
          if (renderTarget.depthTexture.format === DepthFormat) {
            if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
            } else {
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
          } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
            if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
            } else {
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
          } else {
            throw new Error("Unknown depthTexture format");
          }
        }
        function setupDepthRenderbuffer(renderTarget) {
          const renderTargetProperties = properties.get(renderTarget);
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
            if (isCube)
              throw new Error("target.depthTexture not supported in Cube render targets");
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
          } else {
            if (isCube) {
              renderTargetProperties.__webglDepthbuffer = [];
              for (let i2 = 0; i2 < 6; i2++) {
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i2]);
                renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
              }
            } else {
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
            }
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function rebindTextures(renderTarget, colorTexture, depthTexture) {
          const renderTargetProperties = properties.get(renderTarget);
          if (colorTexture !== void 0) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
          }
          if (depthTexture !== void 0) {
            setupDepthRenderbuffer(renderTarget);
          }
        }
        function setupRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          renderTarget.addEventListener("dispose", onRenderTargetDispose);
          if (renderTarget.isWebGLMultipleRenderTargets !== true) {
            if (textureProperties.__webglTexture === void 0) {
              textureProperties.__webglTexture = _gl.createTexture();
            }
            textureProperties.__version = texture.version;
            info.memory.textures++;
          }
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
          const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
            texture.format = RGBAFormat;
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
          }
          if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for (let i2 = 0; i2 < 6; i2++) {
              renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
            }
          } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultipleRenderTargets) {
              if (capabilities.drawBuffers) {
                const textures = renderTarget.texture;
                for (let i2 = 0, il = textures.length; i2 < il; i2++) {
                  const attachmentProperties = properties.get(textures[i2]);
                  if (attachmentProperties.__webglTexture === void 0) {
                    attachmentProperties.__webglTexture = _gl.createTexture();
                    info.memory.textures++;
                  }
                }
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
              }
            } else if (renderTarget.useRenderbuffer) {
              if (isWebGL2) {
                renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                const glFormat = utils.convert(texture.format);
                const glType = utils.convert(texture.type);
                const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                if (renderTarget.depthBuffer) {
                  renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                  setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                }
                state.bindFramebuffer(_gl.FRAMEBUFFER, null);
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
              }
            }
          }
          if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
            for (let i2 = 0; i2 < 6; i2++) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2);
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            state.unbindTexture();
          } else if (isMultipleRenderTargets) {
            const textures = renderTarget.texture;
            for (let i2 = 0, il = textures.length; i2 < il; i2++) {
              const attachment = textures[i2];
              const attachmentProperties = properties.get(attachment);
              state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
              setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D);
              if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
                generateMipmap(_gl.TEXTURE_2D);
              }
            }
            state.unbindTexture();
          } else {
            let glTextureType = _gl.TEXTURE_2D;
            if (isRenderTarget3D) {
              if (isWebGL2) {
                const isTexture3D = texture.isDataTexture3D;
                glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
              } else {
                console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
              }
            }
            state.bindTexture(glTextureType, textureProperties.__webglTexture);
            setTextureParameters(glTextureType, texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(glTextureType);
            }
            state.unbindTexture();
          }
          if (renderTarget.depthBuffer) {
            setupDepthRenderbuffer(renderTarget);
          }
        }
        function updateRenderTargetMipmap(renderTarget) {
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const texture = textures[i2];
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
              const webglTexture = properties.get(texture).__webglTexture;
              state.bindTexture(target, webglTexture);
              generateMipmap(target);
              state.unbindTexture();
            }
          }
        }
        function updateMultisampleRenderTarget(renderTarget) {
          if (renderTarget.useRenderbuffer) {
            if (isWebGL2) {
              const width = renderTarget.width;
              const height = renderTarget.height;
              let mask = _gl.COLOR_BUFFER_BIT;
              const invalidationArray = [_gl.COLOR_ATTACHMENT0];
              const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
              if (renderTarget.depthBuffer) {
                invalidationArray.push(depthStyle);
              }
              if (!renderTarget.ignoreDepthForMultisampleCopy) {
                if (renderTarget.depthBuffer)
                  mask |= _gl.DEPTH_BUFFER_BIT;
                if (renderTarget.stencilBuffer)
                  mask |= _gl.STENCIL_BUFFER_BIT;
              }
              const renderTargetProperties = properties.get(renderTarget);
              state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              if (renderTarget.ignoreDepthForMultisampleCopy) {
                _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
                _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
              }
              _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
              _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
              state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
              state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            } else {
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            }
          }
        }
        function getRenderTargetSamples(renderTarget) {
          return isWebGL2 && (renderTarget.useRenderbuffer || renderTarget.useRenderToTexture) ? Math.min(maxSamples, renderTarget.samples) : 0;
        }
        function updateVideoTexture(texture) {
          const frame = info.render.frame;
          if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
          }
        }
        let warnedTexture2D = false;
        let warnedTextureCube = false;
        function safeSetTexture2D(texture, slot) {
          if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
              console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
              warnedTexture2D = true;
            }
            texture = texture.texture;
          }
          setTexture2D(texture, slot);
        }
        function safeSetTextureCube(texture, slot) {
          if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
              console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
              warnedTextureCube = true;
            }
            texture = texture.texture;
          }
          setTextureCube(texture, slot);
        }
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.rebindTextures = rebindTextures;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
        this.setupDepthRenderbuffer = setupDepthRenderbuffer;
        this.setupFrameBufferTexture = setupFrameBufferTexture;
        this.safeSetTexture2D = safeSetTexture2D;
        this.safeSetTextureCube = safeSetTextureCube;
      }
      function WebGLUtils(gl, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function convert(p) {
          let extension;
          if (p === UnsignedByteType)
            return gl.UNSIGNED_BYTE;
          if (p === UnsignedShort4444Type)
            return gl.UNSIGNED_SHORT_4_4_4_4;
          if (p === UnsignedShort5551Type)
            return gl.UNSIGNED_SHORT_5_5_5_1;
          if (p === UnsignedShort565Type)
            return gl.UNSIGNED_SHORT_5_6_5;
          if (p === ByteType)
            return gl.BYTE;
          if (p === ShortType)
            return gl.SHORT;
          if (p === UnsignedShortType)
            return gl.UNSIGNED_SHORT;
          if (p === IntType)
            return gl.INT;
          if (p === UnsignedIntType)
            return gl.UNSIGNED_INT;
          if (p === FloatType)
            return gl.FLOAT;
          if (p === HalfFloatType) {
            if (isWebGL2)
              return gl.HALF_FLOAT;
            extension = extensions.get("OES_texture_half_float");
            if (extension !== null) {
              return extension.HALF_FLOAT_OES;
            } else {
              return null;
            }
          }
          if (p === AlphaFormat)
            return gl.ALPHA;
          if (p === RGBFormat)
            return gl.RGB;
          if (p === RGBAFormat)
            return gl.RGBA;
          if (p === LuminanceFormat)
            return gl.LUMINANCE;
          if (p === LuminanceAlphaFormat)
            return gl.LUMINANCE_ALPHA;
          if (p === DepthFormat)
            return gl.DEPTH_COMPONENT;
          if (p === DepthStencilFormat)
            return gl.DEPTH_STENCIL;
          if (p === RedFormat)
            return gl.RED;
          if (p === RedIntegerFormat)
            return gl.RED_INTEGER;
          if (p === RGFormat)
            return gl.RG;
          if (p === RGIntegerFormat)
            return gl.RG_INTEGER;
          if (p === RGBIntegerFormat)
            return gl.RGB_INTEGER;
          if (p === RGBAIntegerFormat)
            return gl.RGBA_INTEGER;
          if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get("WEBGL_compressed_texture_s3tc");
            if (extension !== null) {
              if (p === RGB_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (p === RGBA_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (p === RGBA_S3TC_DXT3_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (p === RGBA_S3TC_DXT5_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else {
              return null;
            }
          }
          if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_pvrtc");
            if (extension !== null) {
              if (p === RGB_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (p === RGB_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (p === RGBA_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (p === RGBA_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else {
              return null;
            }
          }
          if (p === RGB_ETC1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_etc1");
            if (extension !== null) {
              return extension.COMPRESSED_RGB_ETC1_WEBGL;
            } else {
              return null;
            }
          }
          if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get("WEBGL_compressed_texture_etc");
            if (extension !== null) {
              if (p === RGB_ETC2_Format)
                return extension.COMPRESSED_RGB8_ETC2;
              if (p === RGBA_ETC2_EAC_Format)
                return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
          }
          if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get("WEBGL_compressed_texture_astc");
            if (extension !== null) {
              return p;
            } else {
              return null;
            }
          }
          if (p === RGBA_BPTC_Format) {
            extension = extensions.get("EXT_texture_compression_bptc");
            if (extension !== null) {
              return p;
            } else {
              return null;
            }
          }
          if (p === UnsignedInt248Type) {
            if (isWebGL2)
              return gl.UNSIGNED_INT_24_8;
            extension = extensions.get("WEBGL_depth_texture");
            if (extension !== null) {
              return extension.UNSIGNED_INT_24_8_WEBGL;
            } else {
              return null;
            }
          }
        }
        return {
          convert
        };
      }
      class ArrayCamera extends PerspectiveCamera2 {
        constructor(array = []) {
          super();
          this.cameras = array;
        }
      }
      ArrayCamera.prototype.isArrayCamera = true;
      class Group extends Object3D2 {
        constructor() {
          super();
          this.type = "Group";
        }
      }
      Group.prototype.isGroup = true;
      const _moveEvent = {
        type: "move"
      };
      class WebXRController {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = {
              pinching: false
            };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector34();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector34();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector34();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector34();
          }
          return this._grip;
        }
        dispatchEvent(event) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(event);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(event);
          }
          return this;
        }
        disconnect(inputSource) {
          this.dispatchEvent({
            type: "disconnected",
            data: inputSource
          });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(inputSource, frame, referenceSpace) {
          let inputPose = null;
          let gripPose = null;
          let handPose = null;
          const targetRay = this._targetRay;
          const grip = this._grip;
          const hand = this._hand;
          if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                if (inputPose.linearVelocity) {
                  targetRay.hasLinearVelocity = true;
                  targetRay.linearVelocity.copy(inputPose.linearVelocity);
                } else {
                  targetRay.hasLinearVelocity = false;
                }
                if (inputPose.angularVelocity) {
                  targetRay.hasAngularVelocity = true;
                  targetRay.angularVelocity.copy(inputPose.angularVelocity);
                } else {
                  targetRay.hasAngularVelocity = false;
                }
                this.dispatchEvent(_moveEvent);
              }
            }
            if (hand && inputSource.hand) {
              handPose = true;
              for (const inputjoint of inputSource.hand.values()) {
                const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                if (hand.joints[inputjoint.jointName] === void 0) {
                  const joint2 = new Group();
                  joint2.matrixAutoUpdate = false;
                  joint2.visible = false;
                  hand.joints[inputjoint.jointName] = joint2;
                  hand.add(joint2);
                }
                const joint = hand.joints[inputjoint.jointName];
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
              }
              const indexTip = hand.joints["index-finger-tip"];
              const thumbTip = hand.joints["thumb-tip"];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            } else {
              if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                  grip.matrix.fromArray(gripPose.transform.matrix);
                  grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                  if (gripPose.linearVelocity) {
                    grip.hasLinearVelocity = true;
                    grip.linearVelocity.copy(gripPose.linearVelocity);
                  } else {
                    grip.hasLinearVelocity = false;
                  }
                  if (gripPose.angularVelocity) {
                    grip.hasAngularVelocity = true;
                    grip.angularVelocity.copy(gripPose.angularVelocity);
                  } else {
                    grip.hasAngularVelocity = false;
                  }
                }
              }
            }
          }
          if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
          }
          if (grip !== null) {
            grip.visible = gripPose !== null;
          }
          if (hand !== null) {
            hand.visible = handPose !== null;
          }
          return this;
        }
      }
      class DepthTexture extends Texture {
        constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format2) {
          format2 = format2 !== void 0 ? format2 : DepthFormat;
          if (format2 !== DepthFormat && format2 !== DepthStencilFormat) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (type === void 0 && format2 === DepthFormat)
            type = UnsignedShortType;
          if (type === void 0 && format2 === DepthStencilFormat)
            type = UnsignedInt248Type;
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
          this.image = {
            width,
            height
          };
          this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
          this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      }
      DepthTexture.prototype.isDepthTexture = true;
      class WebXRManager extends EventDispatcher {
        constructor(renderer, gl) {
          super();
          const scope = this;
          let session = null;
          let framebufferScaleFactor = 1;
          let referenceSpace = null;
          let referenceSpaceType = "local-floor";
          const hasMultisampledRenderToTexture = renderer.extensions.has("WEBGL_multisampled_render_to_texture");
          let pose = null;
          let glBinding = null;
          let glProjLayer = null;
          let glBaseLayer = null;
          let isMultisample = false;
          let xrFrame = null;
          const attributes = gl.getContextAttributes();
          let initialRenderTarget = null;
          let newRenderTarget = null;
          const controllers = [];
          const inputSourcesMap = new Map();
          const cameraL = new PerspectiveCamera2();
          cameraL.layers.enable(1);
          cameraL.viewport = new Vector4();
          const cameraR = new PerspectiveCamera2();
          cameraR.layers.enable(2);
          cameraR.viewport = new Vector4();
          const cameras = [cameraL, cameraR];
          const cameraVR = new ArrayCamera();
          cameraVR.layers.enable(1);
          cameraVR.layers.enable(2);
          let _currentDepthNear = null;
          let _currentDepthFar = null;
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
          };
          this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getGripSpace();
          };
          this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getHandSpace();
          };
          function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller) {
              controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
              });
            }
          }
          function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
              controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            renderer.setRenderTarget(initialRenderTarget);
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            newRenderTarget = null;
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function() {
            return referenceSpace;
          };
          this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
          };
          this.getBinding = function() {
            return glBinding;
          };
          this.getFrame = function() {
            return xrFrame;
          };
          this.getSession = function() {
            return session;
          };
          this.setSession = async function(value) {
            session = value;
            if (session !== null) {
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              if (attributes.xrCompatible !== true) {
                await gl.makeXRCompatible();
              }
              if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
                const layerInit = {
                  antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({
                  baseLayer: glBaseLayer
                });
                newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight);
              } else {
                isMultisample = attributes.antialias;
                let depthFormat = null;
                let depthType = null;
                let glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT16;
                  depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                  depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
                }
                const projectionlayerInit = {
                  colorFormat: attributes.alpha || isMultisample ? gl.RGBA8 : gl.RGB8,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({
                  layers: [glProjLayer]
                });
                if (isMultisample) {
                  newRenderTarget = new WebGLMultisampleRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    ignoreDepth: glProjLayer.ignoreDepthValues,
                    useRenderToTexture: hasMultisampledRenderToTexture
                  });
                } else {
                  newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                    format: attributes.alpha ? RGBAFormat : RGBFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    ignoreDepth: glProjLayer.ignoreDepthValues
                  });
                }
              }
              this.setFoveation(0);
              referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({
                type: "sessionstart"
              });
            }
          };
          function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              inputSourcesMap.set(inputSources[i2], controllers[i2]);
            }
            for (let i2 = 0; i2 < event.removed.length; i2++) {
              const inputSource = event.removed[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "disconnected",
                  data: inputSource
                });
                inputSourcesMap.delete(inputSource);
              }
            }
            for (let i2 = 0; i2 < event.added.length; i2++) {
              const inputSource = event.added[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "connected",
                  data: inputSource
                });
              }
            }
          }
          const cameraLPos = new Vector34();
          const cameraRPos = new Vector34();
          function setProjectionFromUnion(camera, cameraL2, cameraR2) {
            cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL2.projectionMatrix.elements;
            const projR = cameraR2.projectionMatrix.elements;
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          }
          function updateCamera(camera, parent) {
            if (parent === null) {
              camera.matrixWorld.copy(camera.matrix);
            } else {
              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          }
          this.updateCamera = function(camera) {
            if (session === null)
              return;
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
              session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
              });
              _currentDepthNear = cameraVR.near;
              _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras2 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for (let i2 = 0; i2 < cameras2.length; i2++) {
              updateCamera(cameras2[i2], parent);
            }
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for (let i2 = 0, l = children.length; i2 < l; i2++) {
              children[i2].updateMatrixWorld(true);
            }
            if (cameras2.length === 2) {
              setProjectionFromUnion(cameraVR, cameraL, cameraR);
            } else {
              cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
          };
          this.getCamera = function() {
            return cameraVR;
          };
          this.getFoveation = function() {
            if (glProjLayer !== null) {
              return glProjLayer.fixedFoveation;
            }
            if (glBaseLayer !== null) {
              return glBaseLayer.fixedFoveation;
            }
            return void 0;
          };
          this.setFoveation = function(foveation) {
            if (glProjLayer !== null) {
              glProjLayer.fixedFoveation = foveation;
            }
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
              glBaseLayer.fixedFoveation = foveation;
            }
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
              const views = pose.views;
              if (glBaseLayer !== null) {
                renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                renderer.setRenderTarget(newRenderTarget);
              }
              let cameraVRNeedsUpdate = false;
              if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
              }
              for (let i2 = 0; i2 < views.length; i2++) {
                const view = views[i2];
                let viewport = null;
                if (glBaseLayer !== null) {
                  viewport = glBaseLayer.getViewport(view);
                } else {
                  const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                  viewport = glSubImage.viewport;
                  if (i2 === 0) {
                    renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
                    renderer.setRenderTarget(newRenderTarget);
                  }
                }
                const camera = cameras[i2];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i2 === 0) {
                  cameraVR.matrix.copy(camera.matrix);
                }
                if (cameraVRNeedsUpdate === true) {
                  cameraVR.cameras.push(camera);
                }
              }
            }
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              const controller = controllers[i2];
              const inputSource = inputSources[i2];
              controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time, frame);
            xrFrame = null;
          }
          const animation = new WebGLAnimation();
          animation.setAnimationLoop(onAnimationFrame);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
          };
          this.dispose = function() {
          };
        }
      }
      function WebGLMaterials(properties) {
        function refreshFogUniforms(uniforms, fog) {
          uniforms.fogColor.value.copy(fog.color);
          if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
          } else if (fog.isFogExp2) {
            uniforms.fogDensity.value = fog.density;
          }
        }
        function refreshMaterialUniforms(uniforms, material2, pixelRatio, height, transmissionRenderTarget) {
          if (material2.isMeshBasicMaterial) {
            refreshUniformsCommon(uniforms, material2);
          } else if (material2.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material2);
            refreshUniformsLambert(uniforms, material2);
          } else if (material2.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material2);
            refreshUniformsToon(uniforms, material2);
          } else if (material2.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material2);
            refreshUniformsPhong(uniforms, material2);
          } else if (material2.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material2);
            if (material2.isMeshPhysicalMaterial) {
              refreshUniformsPhysical(uniforms, material2, transmissionRenderTarget);
            } else {
              refreshUniformsStandard(uniforms, material2);
            }
          } else if (material2.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material2);
            refreshUniformsMatcap(uniforms, material2);
          } else if (material2.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material2);
            refreshUniformsDepth(uniforms, material2);
          } else if (material2.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material2);
            refreshUniformsDistance(uniforms, material2);
          } else if (material2.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material2);
            refreshUniformsNormal(uniforms, material2);
          } else if (material2.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material2);
            if (material2.isLineDashedMaterial) {
              refreshUniformsDash(uniforms, material2);
            }
          } else if (material2.isPointsMaterial) {
            refreshUniformsPoints(uniforms, material2, pixelRatio, height);
          } else if (material2.isSpriteMaterial) {
            refreshUniformsSprites(uniforms, material2);
          } else if (material2.isShadowMaterial) {
            uniforms.color.value.copy(material2.color);
            uniforms.opacity.value = material2.opacity;
          } else if (material2.isShaderMaterial) {
            material2.uniformsNeedUpdate = false;
          }
        }
        function refreshUniformsCommon(uniforms, material2) {
          uniforms.opacity.value = material2.opacity;
          if (material2.color) {
            uniforms.diffuse.value.copy(material2.color);
          }
          if (material2.emissive) {
            uniforms.emissive.value.copy(material2.emissive).multiplyScalar(material2.emissiveIntensity);
          }
          if (material2.map) {
            uniforms.map.value = material2.map;
          }
          if (material2.alphaMap) {
            uniforms.alphaMap.value = material2.alphaMap;
          }
          if (material2.specularMap) {
            uniforms.specularMap.value = material2.specularMap;
          }
          if (material2.alphaTest > 0) {
            uniforms.alphaTest.value = material2.alphaTest;
          }
          const envMap = properties.get(material2).envMap;
          if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
            uniforms.reflectivity.value = material2.reflectivity;
            uniforms.ior.value = material2.ior;
            uniforms.refractionRatio.value = material2.refractionRatio;
          }
          if (material2.lightMap) {
            uniforms.lightMap.value = material2.lightMap;
            uniforms.lightMapIntensity.value = material2.lightMapIntensity;
          }
          if (material2.aoMap) {
            uniforms.aoMap.value = material2.aoMap;
            uniforms.aoMapIntensity.value = material2.aoMapIntensity;
          }
          let uvScaleMap;
          if (material2.map) {
            uvScaleMap = material2.map;
          } else if (material2.specularMap) {
            uvScaleMap = material2.specularMap;
          } else if (material2.displacementMap) {
            uvScaleMap = material2.displacementMap;
          } else if (material2.normalMap) {
            uvScaleMap = material2.normalMap;
          } else if (material2.bumpMap) {
            uvScaleMap = material2.bumpMap;
          } else if (material2.roughnessMap) {
            uvScaleMap = material2.roughnessMap;
          } else if (material2.metalnessMap) {
            uvScaleMap = material2.metalnessMap;
          } else if (material2.alphaMap) {
            uvScaleMap = material2.alphaMap;
          } else if (material2.emissiveMap) {
            uvScaleMap = material2.emissiveMap;
          } else if (material2.clearcoatMap) {
            uvScaleMap = material2.clearcoatMap;
          } else if (material2.clearcoatNormalMap) {
            uvScaleMap = material2.clearcoatNormalMap;
          } else if (material2.clearcoatRoughnessMap) {
            uvScaleMap = material2.clearcoatRoughnessMap;
          } else if (material2.specularIntensityMap) {
            uvScaleMap = material2.specularIntensityMap;
          } else if (material2.specularColorMap) {
            uvScaleMap = material2.specularColorMap;
          } else if (material2.transmissionMap) {
            uvScaleMap = material2.transmissionMap;
          } else if (material2.thicknessMap) {
            uvScaleMap = material2.thicknessMap;
          } else if (material2.sheenColorMap) {
            uvScaleMap = material2.sheenColorMap;
          } else if (material2.sheenRoughnessMap) {
            uvScaleMap = material2.sheenRoughnessMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.isWebGLRenderTarget) {
              uvScaleMap = uvScaleMap.texture;
            }
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
          let uv2ScaleMap;
          if (material2.aoMap) {
            uv2ScaleMap = material2.aoMap;
          } else if (material2.lightMap) {
            uv2ScaleMap = material2.lightMap;
          }
          if (uv2ScaleMap !== void 0) {
            if (uv2ScaleMap.isWebGLRenderTarget) {
              uv2ScaleMap = uv2ScaleMap.texture;
            }
            if (uv2ScaleMap.matrixAutoUpdate === true) {
              uv2ScaleMap.updateMatrix();
            }
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
          }
        }
        function refreshUniformsLine(uniforms, material2) {
          uniforms.diffuse.value.copy(material2.color);
          uniforms.opacity.value = material2.opacity;
        }
        function refreshUniformsDash(uniforms, material2) {
          uniforms.dashSize.value = material2.dashSize;
          uniforms.totalSize.value = material2.dashSize + material2.gapSize;
          uniforms.scale.value = material2.scale;
        }
        function refreshUniformsPoints(uniforms, material2, pixelRatio, height) {
          uniforms.diffuse.value.copy(material2.color);
          uniforms.opacity.value = material2.opacity;
          uniforms.size.value = material2.size * pixelRatio;
          uniforms.scale.value = height * 0.5;
          if (material2.map) {
            uniforms.map.value = material2.map;
          }
          if (material2.alphaMap) {
            uniforms.alphaMap.value = material2.alphaMap;
          }
          if (material2.alphaTest > 0) {
            uniforms.alphaTest.value = material2.alphaTest;
          }
          let uvScaleMap;
          if (material2.map) {
            uvScaleMap = material2.map;
          } else if (material2.alphaMap) {
            uvScaleMap = material2.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsSprites(uniforms, material2) {
          uniforms.diffuse.value.copy(material2.color);
          uniforms.opacity.value = material2.opacity;
          uniforms.rotation.value = material2.rotation;
          if (material2.map) {
            uniforms.map.value = material2.map;
          }
          if (material2.alphaMap) {
            uniforms.alphaMap.value = material2.alphaMap;
          }
          if (material2.alphaTest > 0) {
            uniforms.alphaTest.value = material2.alphaTest;
          }
          let uvScaleMap;
          if (material2.map) {
            uvScaleMap = material2.map;
          } else if (material2.alphaMap) {
            uvScaleMap = material2.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsLambert(uniforms, material2) {
          if (material2.emissiveMap) {
            uniforms.emissiveMap.value = material2.emissiveMap;
          }
        }
        function refreshUniformsPhong(uniforms, material2) {
          uniforms.specular.value.copy(material2.specular);
          uniforms.shininess.value = Math.max(material2.shininess, 1e-4);
          if (material2.emissiveMap) {
            uniforms.emissiveMap.value = material2.emissiveMap;
          }
          if (material2.bumpMap) {
            uniforms.bumpMap.value = material2.bumpMap;
            uniforms.bumpScale.value = material2.bumpScale;
            if (material2.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material2.normalMap) {
            uniforms.normalMap.value = material2.normalMap;
            uniforms.normalScale.value.copy(material2.normalScale);
            if (material2.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material2.displacementMap) {
            uniforms.displacementMap.value = material2.displacementMap;
            uniforms.displacementScale.value = material2.displacementScale;
            uniforms.displacementBias.value = material2.displacementBias;
          }
        }
        function refreshUniformsToon(uniforms, material2) {
          if (material2.gradientMap) {
            uniforms.gradientMap.value = material2.gradientMap;
          }
          if (material2.emissiveMap) {
            uniforms.emissiveMap.value = material2.emissiveMap;
          }
          if (material2.bumpMap) {
            uniforms.bumpMap.value = material2.bumpMap;
            uniforms.bumpScale.value = material2.bumpScale;
            if (material2.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material2.normalMap) {
            uniforms.normalMap.value = material2.normalMap;
            uniforms.normalScale.value.copy(material2.normalScale);
            if (material2.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material2.displacementMap) {
            uniforms.displacementMap.value = material2.displacementMap;
            uniforms.displacementScale.value = material2.displacementScale;
            uniforms.displacementBias.value = material2.displacementBias;
          }
        }
        function refreshUniformsStandard(uniforms, material2) {
          uniforms.roughness.value = material2.roughness;
          uniforms.metalness.value = material2.metalness;
          if (material2.roughnessMap) {
            uniforms.roughnessMap.value = material2.roughnessMap;
          }
          if (material2.metalnessMap) {
            uniforms.metalnessMap.value = material2.metalnessMap;
          }
          if (material2.emissiveMap) {
            uniforms.emissiveMap.value = material2.emissiveMap;
          }
          if (material2.bumpMap) {
            uniforms.bumpMap.value = material2.bumpMap;
            uniforms.bumpScale.value = material2.bumpScale;
            if (material2.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material2.normalMap) {
            uniforms.normalMap.value = material2.normalMap;
            uniforms.normalScale.value.copy(material2.normalScale);
            if (material2.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material2.displacementMap) {
            uniforms.displacementMap.value = material2.displacementMap;
            uniforms.displacementScale.value = material2.displacementScale;
            uniforms.displacementBias.value = material2.displacementBias;
          }
          const envMap = properties.get(material2).envMap;
          if (envMap) {
            uniforms.envMapIntensity.value = material2.envMapIntensity;
          }
        }
        function refreshUniformsPhysical(uniforms, material2, transmissionRenderTarget) {
          refreshUniformsStandard(uniforms, material2);
          uniforms.ior.value = material2.ior;
          if (material2.sheen > 0) {
            uniforms.sheenColor.value.copy(material2.sheenColor).multiplyScalar(material2.sheen);
            uniforms.sheenRoughness.value = material2.sheenRoughness;
            if (material2.sheenColorMap) {
              uniforms.sheenColorMap.value = material2.sheenColorMap;
            }
            if (material2.sheenRoughnessMap) {
              uniforms.sheenRoughnessMap.value = material2.sheenRoughnessMap;
            }
          }
          if (material2.clearcoat > 0) {
            uniforms.clearcoat.value = material2.clearcoat;
            uniforms.clearcoatRoughness.value = material2.clearcoatRoughness;
            if (material2.clearcoatMap) {
              uniforms.clearcoatMap.value = material2.clearcoatMap;
            }
            if (material2.clearcoatRoughnessMap) {
              uniforms.clearcoatRoughnessMap.value = material2.clearcoatRoughnessMap;
            }
            if (material2.clearcoatNormalMap) {
              uniforms.clearcoatNormalScale.value.copy(material2.clearcoatNormalScale);
              uniforms.clearcoatNormalMap.value = material2.clearcoatNormalMap;
              if (material2.side === BackSide) {
                uniforms.clearcoatNormalScale.value.negate();
              }
            }
          }
          if (material2.transmission > 0) {
            uniforms.transmission.value = material2.transmission;
            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
            if (material2.transmissionMap) {
              uniforms.transmissionMap.value = material2.transmissionMap;
            }
            uniforms.thickness.value = material2.thickness;
            if (material2.thicknessMap) {
              uniforms.thicknessMap.value = material2.thicknessMap;
            }
            uniforms.attenuationDistance.value = material2.attenuationDistance;
            uniforms.attenuationColor.value.copy(material2.attenuationColor);
          }
          uniforms.specularIntensity.value = material2.specularIntensity;
          uniforms.specularColor.value.copy(material2.specularColor);
          if (material2.specularIntensityMap) {
            uniforms.specularIntensityMap.value = material2.specularIntensityMap;
          }
          if (material2.specularColorMap) {
            uniforms.specularColorMap.value = material2.specularColorMap;
          }
        }
        function refreshUniformsMatcap(uniforms, material2) {
          if (material2.matcap) {
            uniforms.matcap.value = material2.matcap;
          }
          if (material2.bumpMap) {
            uniforms.bumpMap.value = material2.bumpMap;
            uniforms.bumpScale.value = material2.bumpScale;
            if (material2.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material2.normalMap) {
            uniforms.normalMap.value = material2.normalMap;
            uniforms.normalScale.value.copy(material2.normalScale);
            if (material2.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material2.displacementMap) {
            uniforms.displacementMap.value = material2.displacementMap;
            uniforms.displacementScale.value = material2.displacementScale;
            uniforms.displacementBias.value = material2.displacementBias;
          }
        }
        function refreshUniformsDepth(uniforms, material2) {
          if (material2.displacementMap) {
            uniforms.displacementMap.value = material2.displacementMap;
            uniforms.displacementScale.value = material2.displacementScale;
            uniforms.displacementBias.value = material2.displacementBias;
          }
        }
        function refreshUniformsDistance(uniforms, material2) {
          if (material2.displacementMap) {
            uniforms.displacementMap.value = material2.displacementMap;
            uniforms.displacementScale.value = material2.displacementScale;
            uniforms.displacementBias.value = material2.displacementBias;
          }
          uniforms.referencePosition.value.copy(material2.referencePosition);
          uniforms.nearDistance.value = material2.nearDistance;
          uniforms.farDistance.value = material2.farDistance;
        }
        function refreshUniformsNormal(uniforms, material2) {
          if (material2.bumpMap) {
            uniforms.bumpMap.value = material2.bumpMap;
            uniforms.bumpScale.value = material2.bumpScale;
            if (material2.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material2.normalMap) {
            uniforms.normalMap.value = material2.normalMap;
            uniforms.normalScale.value.copy(material2.normalScale);
            if (material2.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material2.displacementMap) {
            uniforms.displacementMap.value = material2.displacementMap;
            uniforms.displacementScale.value = material2.displacementScale;
            uniforms.displacementBias.value = material2.displacementBias;
          }
        }
        return {
          refreshFogUniforms,
          refreshMaterialUniforms
        };
      }
      function createCanvasElement() {
        const canvas = createElementNS("canvas");
        canvas.style.display = "block";
        return canvas;
      }
      function WebGLRenderer(parameters = {}) {
        const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
        let currentRenderList = null;
        let currentRenderState = null;
        const renderListStack = [];
        const renderStateStack = [];
        this.domElement = _canvas2;
        this.debug = {
          checkShaderErrors: true
        };
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.gammaFactor = 2;
        this.outputEncoding = LinearEncoding;
        this.physicallyCorrectLights = false;
        this.toneMapping = NoToneMapping2;
        this.toneMappingExposure = 1;
        const _this = this;
        let _isContextLost = false;
        let _currentActiveCubeFace = 0;
        let _currentActiveMipmapLevel = 0;
        let _currentRenderTarget = null;
        let _currentMaterialId = -1;
        let _currentCamera = null;
        const _currentViewport = new Vector4();
        const _currentScissor = new Vector4();
        let _currentScissorTest = null;
        let _width = _canvas2.width;
        let _height = _canvas2.height;
        let _pixelRatio = 1;
        let _opaqueSort = null;
        let _transparentSort = null;
        const _viewport = new Vector4(0, 0, _width, _height);
        const _scissor = new Vector4(0, 0, _width, _height);
        let _scissorTest = false;
        const _currentDrawBuffers = [];
        const _frustum = new Frustum();
        let _clippingEnabled = false;
        let _localClippingEnabled = false;
        let _transmissionRenderTarget = null;
        const _projScreenMatrix2 = new Matrix4();
        const _vector3 = new Vector34();
        const _emptyScene = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: true
        };
        function getTargetPixelRatio() {
          return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        let _gl = _context2;
        function getContext2(contextNames, contextAttributes) {
          for (let i2 = 0; i2 < contextNames.length; i2++) {
            const contextName = contextNames[i2];
            const context = _canvas2.getContext(contextName, contextAttributes);
            if (context !== null)
              return context;
          }
          return null;
        }
        try {
          const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
          };
          if ("setAttribute" in _canvas2)
            _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
          _canvas2.addEventListener("webglcontextlost", onContextLost, false);
          _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
          if (_gl === null) {
            const contextNames = ["webgl2", "webgl", "experimental-webgl"];
            if (_this.isWebGL1Renderer === true) {
              contextNames.shift();
            }
            _gl = getContext2(contextNames, contextAttributes);
            if (_gl === null) {
              if (getContext2(contextNames)) {
                throw new Error("Error creating WebGL context with your selected attributes.");
              } else {
                throw new Error("Error creating WebGL context.");
              }
            }
          }
          if (_gl.getShaderPrecisionFormat === void 0) {
            _gl.getShaderPrecisionFormat = function() {
              return {
                "rangeMin": 1,
                "rangeMax": 1,
                "precision": 1
              };
            };
          }
        } catch (error2) {
          console.error("THREE.WebGLRenderer: " + error2.message);
          throw error2;
        }
        let extensions, capabilities, state, info;
        let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
        let programCache, materials, renderLists, renderStates, clipping, shadowMap;
        let background, morphtargets, bufferRenderer, indexedBufferRenderer;
        let utils, bindingStates;
        function initGLContext() {
          extensions = new WebGLExtensions(_gl);
          capabilities = new WebGLCapabilities(_gl, extensions, parameters);
          extensions.init(capabilities);
          utils = new WebGLUtils(_gl, extensions, capabilities);
          state = new WebGLState(_gl, extensions, capabilities);
          _currentDrawBuffers[0] = _gl.BACK;
          info = new WebGLInfo(_gl);
          properties = new WebGLProperties();
          textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
          cubemaps = new WebGLCubeMaps(_this);
          cubeuvmaps = new WebGLCubeUVMaps(_this);
          attributes = new WebGLAttributes(_gl, capabilities);
          bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
          geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
          objects = new WebGLObjects(_gl, geometries, attributes, info);
          morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
          clipping = new WebGLClipping(properties);
          programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
          materials = new WebGLMaterials(properties);
          renderLists = new WebGLRenderLists(properties);
          renderStates = new WebGLRenderStates(extensions, capabilities);
          background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
          shadowMap = new WebGLShadowMap(_this, objects, capabilities);
          bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
          indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
          info.programs = programCache.programs;
          _this.capabilities = capabilities;
          _this.extensions = extensions;
          _this.properties = properties;
          _this.renderLists = renderLists;
          _this.shadowMap = shadowMap;
          _this.state = state;
          _this.info = info;
        }
        initGLContext();
        const xr = new WebXRManager(_this, _gl);
        this.xr = xr;
        this.getContext = function() {
          return _gl;
        };
        this.getContextAttributes = function() {
          return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.loseContext();
        };
        this.forceContextRestore = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.restoreContext();
        };
        this.getPixelRatio = function() {
          return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
          if (value === void 0)
            return;
          _pixelRatio = value;
          this.setSize(_width, _height, false);
        };
        this.getSize = function(target) {
          return target.set(_width, _height);
        };
        this.setSize = function(width, height, updateStyle) {
          if (xr.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
          }
          _width = width;
          _height = height;
          _canvas2.width = Math.floor(width * _pixelRatio);
          _canvas2.height = Math.floor(height * _pixelRatio);
          if (updateStyle !== false) {
            _canvas2.style.width = width + "px";
            _canvas2.style.height = height + "px";
          }
          this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function(target) {
          return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
        };
        this.setDrawingBufferSize = function(width, height, pixelRatio) {
          _width = width;
          _height = height;
          _pixelRatio = pixelRatio;
          _canvas2.width = Math.floor(width * pixelRatio);
          _canvas2.height = Math.floor(height * pixelRatio);
          this.setViewport(0, 0, width, height);
        };
        this.getCurrentViewport = function(target) {
          return target.copy(_currentViewport);
        };
        this.getViewport = function(target) {
          return target.copy(_viewport);
        };
        this.setViewport = function(x2, y, width, height) {
          if (x2.isVector4) {
            _viewport.set(x2.x, x2.y, x2.z, x2.w);
          } else {
            _viewport.set(x2, y, width, height);
          }
          state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissor = function(target) {
          return target.copy(_scissor);
        };
        this.setScissor = function(x2, y, width, height) {
          if (x2.isVector4) {
            _scissor.set(x2.x, x2.y, x2.z, x2.w);
          } else {
            _scissor.set(x2, y, width, height);
          }
          state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissorTest = function() {
          return _scissorTest;
        };
        this.setScissorTest = function(boolean) {
          state.setScissorTest(_scissorTest = boolean);
        };
        this.setOpaqueSort = function(method) {
          _opaqueSort = method;
        };
        this.setTransparentSort = function(method) {
          _transparentSort = method;
        };
        this.getClearColor = function(target) {
          return target.copy(background.getClearColor());
        };
        this.setClearColor = function() {
          background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function() {
          return background.getClearAlpha();
        };
        this.setClearAlpha = function() {
          background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function(color, depth, stencil) {
          let bits = 0;
          if (color === void 0 || color)
            bits |= _gl.COLOR_BUFFER_BIT;
          if (depth === void 0 || depth)
            bits |= _gl.DEPTH_BUFFER_BIT;
          if (stencil === void 0 || stencil)
            bits |= _gl.STENCIL_BUFFER_BIT;
          _gl.clear(bits);
        };
        this.clearColor = function() {
          this.clear(true, false, false);
        };
        this.clearDepth = function() {
          this.clear(false, true, false);
        };
        this.clearStencil = function() {
          this.clear(false, false, true);
        };
        this.dispose = function() {
          _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
          _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
          renderLists.dispose();
          renderStates.dispose();
          properties.dispose();
          cubemaps.dispose();
          cubeuvmaps.dispose();
          objects.dispose();
          bindingStates.dispose();
          xr.dispose();
          xr.removeEventListener("sessionstart", onXRSessionStart);
          xr.removeEventListener("sessionend", onXRSessionEnd);
          if (_transmissionRenderTarget) {
            _transmissionRenderTarget.dispose();
            _transmissionRenderTarget = null;
          }
          animation.stop();
        };
        function onContextLost(event) {
          event.preventDefault();
          console.log("THREE.WebGLRenderer: Context Lost.");
          _isContextLost = true;
        }
        function onContextRestore() {
          console.log("THREE.WebGLRenderer: Context Restored.");
          _isContextLost = false;
          const infoAutoReset = info.autoReset;
          const shadowMapEnabled = shadowMap.enabled;
          const shadowMapAutoUpdate = shadowMap.autoUpdate;
          const shadowMapNeedsUpdate = shadowMap.needsUpdate;
          const shadowMapType = shadowMap.type;
          initGLContext();
          info.autoReset = infoAutoReset;
          shadowMap.enabled = shadowMapEnabled;
          shadowMap.autoUpdate = shadowMapAutoUpdate;
          shadowMap.needsUpdate = shadowMapNeedsUpdate;
          shadowMap.type = shadowMapType;
        }
        function onMaterialDispose(event) {
          const material2 = event.target;
          material2.removeEventListener("dispose", onMaterialDispose);
          deallocateMaterial(material2);
        }
        function deallocateMaterial(material2) {
          releaseMaterialProgramReferences(material2);
          properties.remove(material2);
        }
        function releaseMaterialProgramReferences(material2) {
          const programs = properties.get(material2).programs;
          if (programs !== void 0) {
            programs.forEach(function(program) {
              programCache.releaseProgram(program);
            });
          }
        }
        this.renderBufferDirect = function(camera, scene, geometry2, material2, object, group) {
          if (scene === null)
            scene = _emptyScene;
          const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
          const program = setProgram(camera, scene, geometry2, material2, object);
          state.setMaterial(material2, frontFaceCW);
          let index = geometry2.index;
          const position2 = geometry2.attributes.position;
          if (index === null) {
            if (position2 === void 0 || position2.count === 0)
              return;
          } else if (index.count === 0) {
            return;
          }
          let rangeFactor = 1;
          if (material2.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry2);
            rangeFactor = 2;
          }
          bindingStates.setup(object, material2, program, geometry2, index);
          let attribute;
          let renderer = bufferRenderer;
          if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
          }
          const dataCount = index !== null ? index.count : position2.count;
          const rangeStart = geometry2.drawRange.start * rangeFactor;
          const rangeCount = geometry2.drawRange.count * rangeFactor;
          const groupStart = group !== null ? group.start * rangeFactor : 0;
          const groupCount = group !== null ? group.count * rangeFactor : Infinity;
          const drawStart = Math.max(rangeStart, groupStart);
          const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
          const drawCount = Math.max(0, drawEnd - drawStart + 1);
          if (drawCount === 0)
            return;
          if (object.isMesh) {
            if (material2.wireframe === true) {
              state.setLineWidth(material2.wireframeLinewidth * getTargetPixelRatio());
              renderer.setMode(_gl.LINES);
            } else {
              renderer.setMode(_gl.TRIANGLES);
            }
          } else if (object.isLine) {
            let lineWidth = material2.linewidth;
            if (lineWidth === void 0)
              lineWidth = 1;
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) {
              renderer.setMode(_gl.LINES);
            } else if (object.isLineLoop) {
              renderer.setMode(_gl.LINE_LOOP);
            } else {
              renderer.setMode(_gl.LINE_STRIP);
            }
          } else if (object.isPoints) {
            renderer.setMode(_gl.POINTS);
          } else if (object.isSprite) {
            renderer.setMode(_gl.TRIANGLES);
          }
          if (object.isInstancedMesh) {
            renderer.renderInstances(drawStart, drawCount, object.count);
          } else if (geometry2.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry2.instanceCount, geometry2._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
          } else {
            renderer.render(drawStart, drawCount);
          }
        };
        this.compile = function(scene, camera) {
          currentRenderState = renderStates.get(scene);
          currentRenderState.init();
          renderStateStack.push(currentRenderState);
          scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            }
          });
          currentRenderState.setupLights(_this.physicallyCorrectLights);
          scene.traverse(function(object) {
            const material2 = object.material;
            if (material2) {
              if (Array.isArray(material2)) {
                for (let i2 = 0; i2 < material2.length; i2++) {
                  const material22 = material2[i2];
                  getProgram(material22, scene, object);
                }
              } else {
                getProgram(material2, scene, object);
              }
            }
          });
          renderStateStack.pop();
          currentRenderState = null;
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time) {
          if (onAnimationFrameCallback)
            onAnimationFrameCallback(time);
        }
        function onXRSessionStart() {
          animation.stop();
        }
        function onXRSessionEnd() {
          animation.start();
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        if (typeof window !== "undefined")
          animation.setContext(window);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
          xr.setAnimationLoop(callback);
          callback === null ? animation.stop() : animation.start();
        };
        xr.addEventListener("sessionstart", onXRSessionStart);
        xr.addEventListener("sessionend", onXRSessionEnd);
        this.render = function(scene, camera) {
          if (camera !== void 0 && camera.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
          }
          if (_isContextLost === true)
            return;
          if (scene.autoUpdate === true)
            scene.updateMatrixWorld();
          if (camera.parent === null)
            camera.updateMatrixWorld();
          if (xr.enabled === true && xr.isPresenting === true) {
            if (xr.cameraAutoUpdate === true)
              xr.updateCamera(camera);
            camera = xr.getCamera();
          }
          if (scene.isScene === true)
            scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
          currentRenderState = renderStates.get(scene, renderStateStack.length);
          currentRenderState.init();
          renderStateStack.push(currentRenderState);
          _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          _frustum.setFromProjectionMatrix(_projScreenMatrix2);
          _localClippingEnabled = this.localClippingEnabled;
          _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
          currentRenderList = renderLists.get(scene, renderListStack.length);
          currentRenderList.init();
          renderListStack.push(currentRenderList);
          projectObject(scene, camera, 0, _this.sortObjects);
          currentRenderList.finish();
          if (_this.sortObjects === true) {
            currentRenderList.sort(_opaqueSort, _transparentSort);
          }
          if (_clippingEnabled === true)
            clipping.beginShadows();
          const shadowsArray = currentRenderState.state.shadowsArray;
          shadowMap.render(shadowsArray, scene, camera);
          if (_clippingEnabled === true)
            clipping.endShadows();
          if (this.info.autoReset === true)
            this.info.reset();
          background.render(currentRenderList, scene);
          currentRenderState.setupLights(_this.physicallyCorrectLights);
          if (camera.isArrayCamera) {
            const cameras = camera.cameras;
            for (let i2 = 0, l = cameras.length; i2 < l; i2++) {
              const camera2 = cameras[i2];
              renderScene(currentRenderList, scene, camera2, camera2.viewport);
            }
          } else {
            renderScene(currentRenderList, scene, camera);
          }
          if (_currentRenderTarget !== null) {
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
            textures.updateRenderTargetMipmap(_currentRenderTarget);
          }
          if (scene.isScene === true)
            scene.onAfterRender(_this, scene, camera);
          state.buffers.depth.setTest(true);
          state.buffers.depth.setMask(true);
          state.buffers.color.setMask(true);
          state.setPolygonOffset(false);
          bindingStates.resetDefaultState();
          _currentMaterialId = -1;
          _currentCamera = null;
          renderStateStack.pop();
          if (renderStateStack.length > 0) {
            currentRenderState = renderStateStack[renderStateStack.length - 1];
          } else {
            currentRenderState = null;
          }
          renderListStack.pop();
          if (renderListStack.length > 0) {
            currentRenderList = renderListStack[renderListStack.length - 1];
          } else {
            currentRenderList = null;
          }
        };
        function projectObject(object, camera, groupOrder, sortObjects) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible) {
            if (object.isGroup) {
              groupOrder = object.renderOrder;
            } else if (object.isLOD) {
              if (object.autoUpdate === true)
                object.update(camera);
            } else if (object.isLight) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            } else if (object.isSprite) {
              if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                const geometry2 = objects.update(object);
                const material2 = object.material;
                if (material2.visible) {
                  currentRenderList.push(object, geometry2, material2, groupOrder, _vector3.z, null);
                }
              }
            } else if (object.isMesh || object.isLine || object.isPoints) {
              if (object.isSkinnedMesh) {
                if (object.skeleton.frame !== info.render.frame) {
                  object.skeleton.update();
                  object.skeleton.frame = info.render.frame;
                }
              }
              if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                const geometry2 = objects.update(object);
                const material2 = object.material;
                if (Array.isArray(material2)) {
                  const groups = geometry2.groups;
                  for (let i2 = 0, l = groups.length; i2 < l; i2++) {
                    const group = groups[i2];
                    const groupMaterial = material2[group.materialIndex];
                    if (groupMaterial && groupMaterial.visible) {
                      currentRenderList.push(object, geometry2, groupMaterial, groupOrder, _vector3.z, group);
                    }
                  }
                } else if (material2.visible) {
                  currentRenderList.push(object, geometry2, material2, groupOrder, _vector3.z, null);
                }
              }
            }
          }
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            projectObject(children[i2], camera, groupOrder, sortObjects);
          }
        }
        function renderScene(currentRenderList2, scene, camera, viewport) {
          const opaqueObjects = currentRenderList2.opaque;
          const transmissiveObjects = currentRenderList2.transmissive;
          const transparentObjects = currentRenderList2.transparent;
          currentRenderState.setupLightsView(camera);
          if (transmissiveObjects.length > 0)
            renderTransmissionPass(opaqueObjects, scene, camera);
          if (viewport)
            state.viewport(_currentViewport.copy(viewport));
          if (opaqueObjects.length > 0)
            renderObjects(opaqueObjects, scene, camera);
          if (transmissiveObjects.length > 0)
            renderObjects(transmissiveObjects, scene, camera);
          if (transparentObjects.length > 0)
            renderObjects(transparentObjects, scene, camera);
        }
        function renderTransmissionPass(opaqueObjects, scene, camera) {
          if (_transmissionRenderTarget === null) {
            const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
            const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
            _transmissionRenderTarget = new renderTargetType(1024, 1024, {
              generateMipmaps: true,
              type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
              minFilter: LinearMipmapLinearFilter,
              magFilter: NearestFilter,
              wrapS: ClampToEdgeWrapping,
              wrapT: ClampToEdgeWrapping,
              useRenderToTexture: extensions.has("WEBGL_multisampled_render_to_texture")
            });
          }
          const currentRenderTarget = _this.getRenderTarget();
          _this.setRenderTarget(_transmissionRenderTarget);
          _this.clear();
          const currentToneMapping = _this.toneMapping;
          _this.toneMapping = NoToneMapping2;
          renderObjects(opaqueObjects, scene, camera);
          _this.toneMapping = currentToneMapping;
          textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
          textures.updateRenderTargetMipmap(_transmissionRenderTarget);
          _this.setRenderTarget(currentRenderTarget);
        }
        function renderObjects(renderList, scene, camera) {
          const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
          for (let i2 = 0, l = renderList.length; i2 < l; i2++) {
            const renderItem = renderList[i2];
            const object = renderItem.object;
            const geometry2 = renderItem.geometry;
            const material2 = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (object.layers.test(camera.layers)) {
              renderObject(object, scene, camera, geometry2, material2, group);
            }
          }
        }
        function renderObject(object, scene, camera, geometry2, material2, group) {
          object.onBeforeRender(_this, scene, camera, geometry2, material2, group);
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          material2.onBeforeRender(_this, scene, camera, geometry2, object, group);
          if (material2.transparent === true && material2.side === DoubleSide) {
            material2.side = BackSide;
            material2.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry2, material2, object, group);
            material2.side = FrontSide;
            material2.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry2, material2, object, group);
            material2.side = DoubleSide;
          } else {
            _this.renderBufferDirect(camera, scene, geometry2, material2, object, group);
          }
          object.onAfterRender(_this, scene, camera, geometry2, material2, group);
        }
        function getProgram(material2, scene, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          const materialProperties = properties.get(material2);
          const lights = currentRenderState.state.lights;
          const shadowsArray = currentRenderState.state.shadowsArray;
          const lightsStateVersion = lights.state.version;
          const parameters2 = programCache.getParameters(material2, lights.state, shadowsArray, scene, object);
          const programCacheKey = programCache.getProgramCacheKey(parameters2);
          let programs = materialProperties.programs;
          materialProperties.environment = material2.isMeshStandardMaterial ? scene.environment : null;
          materialProperties.fog = scene.fog;
          materialProperties.envMap = (material2.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material2.envMap || materialProperties.environment);
          if (programs === void 0) {
            material2.addEventListener("dispose", onMaterialDispose);
            programs = new Map();
            materialProperties.programs = programs;
          }
          let program = programs.get(programCacheKey);
          if (program !== void 0) {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
              updateCommonMaterialProperties(material2, parameters2);
              return program;
            }
          } else {
            parameters2.uniforms = programCache.getUniforms(material2);
            material2.onBuild(object, parameters2, _this);
            material2.onBeforeCompile(parameters2, _this);
            program = programCache.acquireProgram(parameters2, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters2.uniforms;
          }
          const uniforms = materialProperties.uniforms;
          if (!material2.isShaderMaterial && !material2.isRawShaderMaterial || material2.clipping === true) {
            uniforms.clippingPlanes = clipping.uniform;
          }
          updateCommonMaterialProperties(material2, parameters2);
          materialProperties.needsLights = materialNeedsLights(material2);
          materialProperties.lightsStateVersion = lightsStateVersion;
          if (materialProperties.needsLights) {
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
          }
          const progUniforms = program.getUniforms();
          const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
          materialProperties.currentProgram = program;
          materialProperties.uniformsList = uniformsList;
          return program;
        }
        function updateCommonMaterialProperties(material2, parameters2) {
          const materialProperties = properties.get(material2);
          materialProperties.outputEncoding = parameters2.outputEncoding;
          materialProperties.instancing = parameters2.instancing;
          materialProperties.skinning = parameters2.skinning;
          materialProperties.morphTargets = parameters2.morphTargets;
          materialProperties.morphNormals = parameters2.morphNormals;
          materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
          materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
          materialProperties.numIntersection = parameters2.numClipIntersection;
          materialProperties.vertexAlphas = parameters2.vertexAlphas;
          materialProperties.vertexTangents = parameters2.vertexTangents;
        }
        function setProgram(camera, scene, geometry2, material2, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          textures.resetTextureUnits();
          const fog = scene.fog;
          const environment = material2.isMeshStandardMaterial ? scene.environment : null;
          const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
          const envMap = (material2.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material2.envMap || environment);
          const vertexAlphas = material2.vertexColors === true && !!geometry2.attributes.color && geometry2.attributes.color.itemSize === 4;
          const vertexTangents = !!material2.normalMap && !!geometry2.attributes.tangent;
          const morphTargets = !!geometry2.morphAttributes.position;
          const morphNormals = !!geometry2.morphAttributes.normal;
          const morphTargetsCount = !!geometry2.morphAttributes.position ? geometry2.morphAttributes.position.length : 0;
          const materialProperties = properties.get(material2);
          const lights = currentRenderState.state.lights;
          if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
              const useCache = camera === _currentCamera && material2.id === _currentMaterialId;
              clipping.setState(material2, camera, useCache);
            }
          }
          let needsProgramChange = false;
          if (material2.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
              needsProgramChange = true;
            } else if (materialProperties.outputEncoding !== encoding) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancing === false) {
              needsProgramChange = true;
            } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
              needsProgramChange = true;
            } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
              needsProgramChange = true;
            } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
              needsProgramChange = true;
            } else if (materialProperties.envMap !== envMap) {
              needsProgramChange = true;
            } else if (material2.fog && materialProperties.fog !== fog) {
              needsProgramChange = true;
            } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
              needsProgramChange = true;
            } else if (materialProperties.vertexAlphas !== vertexAlphas) {
              needsProgramChange = true;
            } else if (materialProperties.vertexTangents !== vertexTangents) {
              needsProgramChange = true;
            } else if (materialProperties.morphTargets !== morphTargets) {
              needsProgramChange = true;
            } else if (materialProperties.morphNormals !== morphNormals) {
              needsProgramChange = true;
            } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
              needsProgramChange = true;
            }
          } else {
            needsProgramChange = true;
            materialProperties.__version = material2.version;
          }
          let program = materialProperties.currentProgram;
          if (needsProgramChange === true) {
            program = getProgram(material2, scene, object);
          }
          let refreshProgram = false;
          let refreshMaterial = false;
          let refreshLights = false;
          const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
          if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material2.id !== _currentMaterialId) {
            _currentMaterialId = material2.id;
            refreshMaterial = true;
          }
          if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) {
              p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
            }
            if (_currentCamera !== camera) {
              _currentCamera = camera;
              refreshMaterial = true;
              refreshLights = true;
            }
            if (material2.isShaderMaterial || material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshStandardMaterial || material2.envMap) {
              const uCamPos = p_uniforms.map.cameraPosition;
              if (uCamPos !== void 0) {
                uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
              }
            }
            if (material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshLambertMaterial || material2.isMeshBasicMaterial || material2.isMeshStandardMaterial || material2.isShaderMaterial) {
              p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
            }
            if (material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshLambertMaterial || material2.isMeshBasicMaterial || material2.isMeshStandardMaterial || material2.isShaderMaterial || material2.isShadowMaterial || object.isSkinnedMesh) {
              p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
          }
          if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            const skeleton = object.skeleton;
            if (skeleton) {
              if (capabilities.floatVertexTextures) {
                if (skeleton.boneTexture === null)
                  skeleton.computeBoneTexture();
                p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
                p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
              } else {
                p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
              }
            }
          }
          if (!!geometry2 && (geometry2.morphAttributes.position !== void 0 || geometry2.morphAttributes.normal !== void 0)) {
            morphtargets.update(object, geometry2, material2, program);
          }
          if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
          }
          if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            if (materialProperties.needsLights) {
              markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            if (fog && material2.fog) {
              materials.refreshFogUniforms(m_uniforms, fog);
            }
            materials.refreshMaterialUniforms(m_uniforms, material2, _pixelRatio, _height, _transmissionRenderTarget);
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          }
          if (material2.isShaderMaterial && material2.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material2.uniformsNeedUpdate = false;
          }
          if (material2.isSpriteMaterial) {
            p_uniforms.setValue(_gl, "center", object.center);
          }
          p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
          p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
          p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
          return program;
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
          uniforms.ambientLightColor.needsUpdate = value;
          uniforms.lightProbe.needsUpdate = value;
          uniforms.directionalLights.needsUpdate = value;
          uniforms.directionalLightShadows.needsUpdate = value;
          uniforms.pointLights.needsUpdate = value;
          uniforms.pointLightShadows.needsUpdate = value;
          uniforms.spotLights.needsUpdate = value;
          uniforms.spotLightShadows.needsUpdate = value;
          uniforms.rectAreaLights.needsUpdate = value;
          uniforms.hemisphereLights.needsUpdate = value;
        }
        function materialNeedsLights(material2) {
          return material2.isMeshLambertMaterial || material2.isMeshToonMaterial || material2.isMeshPhongMaterial || material2.isMeshStandardMaterial || material2.isShadowMaterial || material2.isShaderMaterial && material2.lights === true;
        }
        this.getActiveCubeFace = function() {
          return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function() {
          return _currentActiveMipmapLevel;
        };
        this.getRenderTarget = function() {
          return _currentRenderTarget;
        };
        this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
          properties.get(renderTarget.texture).__webglTexture = colorTexture;
          properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__hasExternalTextures = true;
          if (renderTargetProperties.__hasExternalTextures) {
            renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
            if (!renderTargetProperties.__autoAllocateDepthBuffer) {
              if (renderTarget.useRenderToTexture) {
                console.warn("render-to-texture extension was disabled because an external texture was provided");
                renderTarget.useRenderToTexture = false;
                renderTarget.useRenderbuffer = true;
              }
            }
          }
        };
        this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
          renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
        };
        this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
          _currentRenderTarget = renderTarget;
          _currentActiveCubeFace = activeCubeFace;
          _currentActiveMipmapLevel = activeMipmapLevel;
          let useDefaultFramebuffer = true;
          if (renderTarget) {
            const renderTargetProperties = properties.get(renderTarget);
            if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, null);
              useDefaultFramebuffer = false;
            } else if (renderTargetProperties.__webglFramebuffer === void 0) {
              textures.setupRenderTarget(renderTarget);
            } else if (renderTargetProperties.__hasExternalTextures) {
              textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
            }
          }
          let framebuffer = null;
          let isCube = false;
          let isRenderTarget3D = false;
          if (renderTarget) {
            const texture = renderTarget.texture;
            if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
              isRenderTarget3D = true;
            }
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
              framebuffer = __webglFramebuffer[activeCubeFace];
              isCube = true;
            } else if (renderTarget.useRenderbuffer) {
              framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            } else {
              framebuffer = __webglFramebuffer;
            }
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
          } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
          }
          const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
            let needsUpdate = false;
            if (renderTarget) {
              if (renderTarget.isWebGLMultipleRenderTargets) {
                const textures2 = renderTarget.texture;
                if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
                  for (let i2 = 0, il = textures2.length; i2 < il; i2++) {
                    _currentDrawBuffers[i2] = _gl.COLOR_ATTACHMENT0 + i2;
                  }
                  _currentDrawBuffers.length = textures2.length;
                  needsUpdate = true;
                }
              } else {
                if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
                  _currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;
                  _currentDrawBuffers.length = 1;
                  needsUpdate = true;
                }
              }
            } else {
              if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {
                _currentDrawBuffers[0] = _gl.BACK;
                _currentDrawBuffers.length = 1;
                needsUpdate = true;
              }
            }
            if (needsUpdate) {
              if (capabilities.isWebGL2) {
                _gl.drawBuffers(_currentDrawBuffers);
              } else {
                extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
              }
            }
          }
          state.viewport(_currentViewport);
          state.scissor(_currentScissor);
          state.setScissorTest(_currentScissorTest);
          if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
          } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
          }
          _currentMaterialId = -1;
        };
        this.readRenderTargetPixels = function(renderTarget, x2, y, width, height, buffer, activeCubeFaceIndex) {
          if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
          }
          let framebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
            framebuffer = framebuffer[activeCubeFaceIndex];
          }
          if (framebuffer) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            try {
              const texture = renderTarget.texture;
              const textureFormat = texture.format;
              const textureType = texture.type;
              if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                return;
              }
              const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
              if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                return;
              }
              if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                if (x2 >= 0 && x2 <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
                  _gl.readPixels(x2, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                }
              } else {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
              }
            } finally {
              const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
            }
          }
        };
        this.copyFramebufferToTexture = function(position2, texture, level = 0) {
          const levelScale = Math.pow(2, -level);
          const width = Math.floor(texture.image.width * levelScale);
          const height = Math.floor(texture.image.height * levelScale);
          let glFormat = utils.convert(texture.format);
          if (capabilities.isWebGL2) {
            if (glFormat === _gl.RGB)
              glFormat = _gl.RGB8;
            if (glFormat === _gl.RGBA)
              glFormat = _gl.RGBA8;
          }
          textures.setTexture2D(texture, 0);
          _gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position2.x, position2.y, width, height, 0);
          state.unbindTexture();
        };
        this.copyTextureToTexture = function(position2, srcTexture, dstTexture, level = 0) {
          const width = srcTexture.image.width;
          const height = srcTexture.image.height;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          textures.setTexture2D(dstTexture, 0);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, position2.x, position2.y, width, height, glFormat, glType, srcTexture.image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position2.x, position2.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
            } else {
              _gl.texSubImage2D(_gl.TEXTURE_2D, level, position2.x, position2.y, glFormat, glType, srcTexture.image);
            }
          }
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(_gl.TEXTURE_2D);
          state.unbindTexture();
        };
        this.copyTextureToTexture3D = function(sourceBox, position2, srcTexture, dstTexture, level = 0) {
          if (_this.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return;
          }
          const width = sourceBox.max.x - sourceBox.min.x + 1;
          const height = sourceBox.max.y - sourceBox.min.y + 1;
          const depth = sourceBox.max.z - sourceBox.min.z + 1;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          let glTarget;
          if (dstTexture.isDataTexture3D) {
            textures.setTexture3D(dstTexture, 0);
            glTarget = _gl.TEXTURE_3D;
          } else if (dstTexture.isDataTexture2DArray) {
            textures.setTexture2DArray(dstTexture, 0);
            glTarget = _gl.TEXTURE_2D_ARRAY;
          } else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return;
          }
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
          const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
          const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
          const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
          const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
          const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
          if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
            _gl.texSubImage3D(glTarget, level, position2.x, position2.y, position2.z, width, height, depth, glFormat, glType, image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
              _gl.compressedTexSubImage3D(glTarget, level, position2.x, position2.y, position2.z, width, height, depth, glFormat, image.data);
            } else {
              _gl.texSubImage3D(glTarget, level, position2.x, position2.y, position2.z, width, height, depth, glFormat, glType, image);
            }
          }
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(glTarget);
          state.unbindTexture();
        };
        this.initTexture = function(texture) {
          textures.setTexture2D(texture, 0);
          state.unbindTexture();
        };
        this.resetState = function() {
          _currentActiveCubeFace = 0;
          _currentActiveMipmapLevel = 0;
          _currentRenderTarget = null;
          state.reset();
          bindingStates.reset();
        };
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
      }
      WebGLRenderer.prototype.isWebGLRenderer = true;
      class WebGL1Renderer extends WebGLRenderer {
      }
      WebGL1Renderer.prototype.isWebGL1Renderer = true;
      class FogExp2 {
        constructor(color, density = 25e-5) {
          this.name = "";
          this.color = new Color(color);
          this.density = density;
        }
        clone() {
          return new FogExp2(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      }
      FogExp2.prototype.isFogExp2 = true;
      class Fog {
        constructor(color, near = 1, far = 1e3) {
          this.name = "";
          this.color = new Color(color);
          this.near = near;
          this.far = far;
        }
        clone() {
          return new Fog(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      }
      Fog.prototype.isFog = true;
      class Scene extends Object3D2 {
        constructor() {
          super();
          this.type = "Scene";
          this.background = null;
          this.environment = null;
          this.fog = null;
          this.overrideMaterial = null;
          this.autoUpdate = true;
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
              detail: this
            }));
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.background !== null)
            this.background = source.background.clone();
          if (source.environment !== null)
            this.environment = source.environment.clone();
          if (source.fog !== null)
            this.fog = source.fog.clone();
          if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
          this.autoUpdate = source.autoUpdate;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.fog !== null)
            data.object.fog = this.fog.toJSON();
          return data;
        }
      }
      Scene.prototype.isScene = true;
      class InterleavedBuffer {
        constructor(array, stride) {
          this.array = array;
          this.stride = stride;
          this.count = array !== void 0 ? array.length / stride : 0;
          this.usage = StaticDrawUsage;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
          this.uuid = generateUUID();
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.stride;
          index2 *= attribute.stride;
          for (let i2 = 0, l = this.stride; i2 < l; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        clone(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
          }
          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
          const ib = new this.constructor(array, this.stride);
          ib.setUsage(this.usage);
          return ib;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        toJSON(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
          }
          return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      InterleavedBuffer.prototype.isInterleavedBuffer = true;
      const _vector$6 = /* @__PURE__ */ new Vector34();
      class InterleavedBufferAttribute {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
          this.name = "";
          this.data = interleavedBuffer;
          this.itemSize = itemSize;
          this.offset = offset;
          this.normalized = normalized === true;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(value) {
          this.data.needsUpdate = value;
        }
        applyMatrix4(m2) {
          for (let i2 = 0, l = this.data.count; i2 < l; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.applyMatrix4(m2);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        applyNormalMatrix(m2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.applyNormalMatrix(m2);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        transformDirection(m2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.transformDirection(m2);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        setX(index, x2) {
          this.data.array[index * this.data.stride + this.offset] = x2;
          return this;
        }
        setY(index, y) {
          this.data.array[index * this.data.stride + this.offset + 1] = y;
          return this;
        }
        setZ(index, z) {
          this.data.array[index * this.data.stride + this.offset + 2] = z;
          return this;
        }
        setW(index, w) {
          this.data.array[index * this.data.stride + this.offset + 3] = w;
          return this;
        }
        getX(index) {
          return this.data.array[index * this.data.stride + this.offset];
        }
        getY(index) {
          return this.data.array[index * this.data.stride + this.offset + 1];
        }
        getZ(index) {
          return this.data.array[index * this.data.stride + this.offset + 2];
        }
        getW(index) {
          return this.data.array[index * this.data.stride + this.offset + 3];
        }
        setXY(index, x2, y) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x2;
          this.data.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x2, y, z) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x2;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x2, y, z, w) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x2;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          this.data.array[index + 3] = w;
          return this;
        }
        clone(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
          }
        }
        toJSON(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array,
              normalized: this.normalized
            };
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
              isInterleavedBufferAttribute: true,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized
            };
          }
        }
      }
      InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
      class SpriteMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "SpriteMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.rotation = 0;
          this.sizeAttenuation = true;
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.rotation = source.rotation;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      }
      SpriteMaterial.prototype.isSpriteMaterial = true;
      let _geometry;
      const _intersectPoint = /* @__PURE__ */ new Vector34();
      const _worldScale = /* @__PURE__ */ new Vector34();
      const _mvPosition = /* @__PURE__ */ new Vector34();
      const _alignedPosition = /* @__PURE__ */ new Vector2();
      const _rotatedPosition = /* @__PURE__ */ new Vector2();
      const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
      const _vA = /* @__PURE__ */ new Vector34();
      const _vB = /* @__PURE__ */ new Vector34();
      const _vC = /* @__PURE__ */ new Vector34();
      const _uvA = /* @__PURE__ */ new Vector2();
      const _uvB = /* @__PURE__ */ new Vector2();
      const _uvC = /* @__PURE__ */ new Vector2();
      class Sprite extends Object3D2 {
        constructor(material2) {
          super();
          this.type = "Sprite";
          if (_geometry === void 0) {
            _geometry = new BufferGeometry3();
            const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
            const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
            _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
          }
          this.geometry = _geometry;
          this.material = material2 !== void 0 ? material2 : new SpriteMaterial();
          this.center = new Vector2(0.5, 0.5);
        }
        raycast(raycaster, intersects2) {
          if (raycaster.camera === null) {
            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
          }
          _worldScale.setFromMatrixScale(this.matrixWorld);
          _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
          this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
          _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
          if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
            _worldScale.multiplyScalar(-_mvPosition.z);
          }
          const rotation2 = this.material.rotation;
          let sin, cos;
          if (rotation2 !== 0) {
            cos = Math.cos(rotation2);
            sin = Math.sin(rotation2);
          }
          const center = this.center;
          transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvA.set(0, 0);
          _uvB.set(1, 0);
          _uvC.set(1, 1);
          let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
          if (intersect === null) {
            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
            if (intersect === null) {
              return;
            }
          }
          const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
            face: null,
            object: this
          });
        }
        copy(source) {
          super.copy(source);
          if (source.center !== void 0)
            this.center.copy(source.center);
          this.material = source.material;
          return this;
        }
      }
      Sprite.prototype.isSprite = true;
      function transformVertex(vertexPosition, mvPosition, center, scale2, sin, cos) {
        _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale2);
        if (sin !== void 0) {
          _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
          _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
        } else {
          _rotatedPosition.copy(_alignedPosition);
        }
        vertexPosition.copy(mvPosition);
        vertexPosition.x += _rotatedPosition.x;
        vertexPosition.y += _rotatedPosition.y;
        vertexPosition.applyMatrix4(_viewWorldMatrix);
      }
      const _v1$2 = /* @__PURE__ */ new Vector34();
      const _v2$1 = /* @__PURE__ */ new Vector34();
      class LOD extends Object3D2 {
        constructor() {
          super();
          this._currentLevel = 0;
          this.type = "LOD";
          Object.defineProperties(this, {
            levels: {
              enumerable: true,
              value: []
            },
            isLOD: {
              value: true
            }
          });
          this.autoUpdate = true;
        }
        copy(source) {
          super.copy(source, false);
          const levels = source.levels;
          for (let i2 = 0, l = levels.length; i2 < l; i2++) {
            const level = levels[i2];
            this.addLevel(level.object.clone(), level.distance);
          }
          this.autoUpdate = source.autoUpdate;
          return this;
        }
        addLevel(object, distance = 0) {
          distance = Math.abs(distance);
          const levels = this.levels;
          let l;
          for (l = 0; l < levels.length; l++) {
            if (distance < levels[l].distance) {
              break;
            }
          }
          levels.splice(l, 0, {
            distance,
            object
          });
          this.add(object);
          return this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(distance) {
          const levels = this.levels;
          if (levels.length > 0) {
            let i2, l;
            for (i2 = 1, l = levels.length; i2 < l; i2++) {
              if (distance < levels[i2].distance) {
                break;
              }
            }
            return levels[i2 - 1].object;
          }
          return null;
        }
        raycast(raycaster, intersects2) {
          const levels = this.levels;
          if (levels.length > 0) {
            _v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects2);
          }
        }
        update(camera) {
          const levels = this.levels;
          if (levels.length > 1) {
            _v1$2.setFromMatrixPosition(camera.matrixWorld);
            _v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i2, l;
            for (i2 = 1, l = levels.length; i2 < l; i2++) {
              if (distance >= levels[i2].distance) {
                levels[i2 - 1].object.visible = false;
                levels[i2].object.visible = true;
              } else {
                break;
              }
            }
            this._currentLevel = i2 - 1;
            for (; i2 < l; i2++) {
              levels[i2].object.visible = false;
            }
          }
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.autoUpdate === false)
            data.object.autoUpdate = false;
          data.object.levels = [];
          const levels = this.levels;
          for (let i2 = 0, l = levels.length; i2 < l; i2++) {
            const level = levels[i2];
            data.object.levels.push({
              object: level.object.uuid,
              distance: level.distance
            });
          }
          return data;
        }
      }
      const _basePosition = /* @__PURE__ */ new Vector34();
      const _skinIndex = /* @__PURE__ */ new Vector4();
      const _skinWeight = /* @__PURE__ */ new Vector4();
      const _vector$5 = /* @__PURE__ */ new Vector34();
      const _matrix = /* @__PURE__ */ new Matrix4();
      class SkinnedMesh extends Mesh3 {
        constructor(geometry2, material2) {
          super(geometry2, material2);
          this.type = "SkinnedMesh";
          this.bindMode = "attached";
          this.bindMatrix = new Matrix4();
          this.bindMatrixInverse = new Matrix4();
        }
        copy(source) {
          super.copy(source);
          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);
          this.skeleton = source.skeleton;
          return this;
        }
        bind(skeleton, bindMatrix) {
          this.skeleton = skeleton;
          if (bindMatrix === void 0) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
          }
          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const vector = new Vector4();
          const skinWeight = this.geometry.attributes.skinWeight;
          for (let i2 = 0, l = skinWeight.count; i2 < l; i2++) {
            vector.x = skinWeight.getX(i2);
            vector.y = skinWeight.getY(i2);
            vector.z = skinWeight.getZ(i2);
            vector.w = skinWeight.getW(i2);
            const scale2 = 1 / vector.manhattanLength();
            if (scale2 !== Infinity) {
              vector.multiplyScalar(scale2);
            } else {
              vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
          }
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.bindMode === "attached") {
            this.bindMatrixInverse.copy(this.matrixWorld).invert();
          } else if (this.bindMode === "detached") {
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
          } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
        }
        boneTransform(index, target) {
          const skeleton = this.skeleton;
          const geometry2 = this.geometry;
          _skinIndex.fromBufferAttribute(geometry2.attributes.skinIndex, index);
          _skinWeight.fromBufferAttribute(geometry2.attributes.skinWeight, index);
          _basePosition.copy(target).applyMatrix4(this.bindMatrix);
          target.set(0, 0, 0);
          for (let i2 = 0; i2 < 4; i2++) {
            const weight = _skinWeight.getComponent(i2);
            if (weight !== 0) {
              const boneIndex = _skinIndex.getComponent(i2);
              _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
            }
          }
          return target.applyMatrix4(this.bindMatrixInverse);
        }
      }
      SkinnedMesh.prototype.isSkinnedMesh = true;
      class Bone extends Object3D2 {
        constructor() {
          super();
          this.type = "Bone";
        }
      }
      Bone.prototype.isBone = true;
      class DataTexture extends Texture {
        constructor(data = null, width = 1, height = 1, format2, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
          this.image = {
            data,
            width,
            height
          };
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.needsUpdate = true;
        }
      }
      DataTexture.prototype.isDataTexture = true;
      const _offsetMatrix = /* @__PURE__ */ new Matrix4();
      const _identityMatrix = /* @__PURE__ */ new Matrix4();
      class Skeleton {
        constructor(bones = [], boneInverses = []) {
          this.uuid = generateUUID();
          this.bones = bones.slice(0);
          this.boneInverses = boneInverses;
          this.boneMatrices = null;
          this.boneTexture = null;
          this.boneTextureSize = 0;
          this.frame = -1;
          this.init();
        }
        init() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          this.boneMatrices = new Float32Array(bones.length * 16);
          if (boneInverses.length === 0) {
            this.calculateInverses();
          } else {
            if (bones.length !== boneInverses.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
              this.boneInverses = [];
              for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
                this.boneInverses.push(new Matrix4());
              }
            }
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const inverse = new Matrix4();
            if (this.bones[i2]) {
              inverse.copy(this.bones[i2].matrixWorld).invert();
            }
            this.boneInverses.push(inverse);
          }
        }
        pose() {
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              bone.matrixWorld.copy(this.boneInverses[i2]).invert();
            }
          }
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              if (bone.parent && bone.parent.isBone) {
                bone.matrix.copy(bone.parent.matrixWorld).invert();
                bone.matrix.multiply(bone.matrixWorld);
              } else {
                bone.matrix.copy(bone.matrixWorld);
              }
              bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
          }
        }
        update() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;
          for (let i2 = 0, il = bones.length; i2 < il; i2++) {
            const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
            _offsetMatrix.toArray(boneMatrices, i2 * 16);
          }
          if (boneTexture !== null) {
            boneTexture.needsUpdate = true;
          }
        }
        clone() {
          return new Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let size = Math.sqrt(this.bones.length * 4);
          size = ceilPowerOfTwo(size);
          size = Math.max(size, 4);
          const boneMatrices = new Float32Array(size * size * 4);
          boneMatrices.set(this.boneMatrices);
          const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
          this.boneMatrices = boneMatrices;
          this.boneTexture = boneTexture;
          this.boneTextureSize = size;
          return this;
        }
        getBoneByName(name) {
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone.name === name) {
              return bone;
            }
          }
          return void 0;
        }
        dispose() {
          if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
          }
        }
        fromJSON(json, bones) {
          this.uuid = json.uuid;
          for (let i2 = 0, l = json.bones.length; i2 < l; i2++) {
            const uuid = json.bones[i2];
            let bone = bones[uuid];
            if (bone === void 0) {
              console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
              bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
          }
          this.init();
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          data.uuid = this.uuid;
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          for (let i2 = 0, l = bones.length; i2 < l; i2++) {
            const bone = bones[i2];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i2];
            data.boneInverses.push(boneInverse.toArray());
          }
          return data;
        }
      }
      class InstancedBufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
          if (typeof normalized === "number") {
            meshPerAttribute = normalized;
            normalized = false;
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
          }
          super(array, itemSize, normalized);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.meshPerAttribute = this.meshPerAttribute;
          data.isInstancedBufferAttribute = true;
          return data;
        }
      }
      InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
      const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
      const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
      const _instanceIntersects = [];
      const _mesh = /* @__PURE__ */ new Mesh3();
      class InstancedMesh extends Mesh3 {
        constructor(geometry2, material2, count) {
          super(geometry2, material2);
          this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
          this.instanceColor = null;
          this.count = count;
          this.frustumCulled = false;
        }
        copy(source) {
          super.copy(source);
          this.instanceMatrix.copy(source.instanceMatrix);
          if (source.instanceColor !== null)
            this.instanceColor = source.instanceColor.clone();
          this.count = source.count;
          return this;
        }
        getColorAt(index, color) {
          color.fromArray(this.instanceColor.array, index * 3);
        }
        getMatrixAt(index, matrix) {
          matrix.fromArray(this.instanceMatrix.array, index * 16);
        }
        raycast(raycaster, intersects2) {
          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;
          _mesh.geometry = this.geometry;
          _mesh.material = this.material;
          if (_mesh.material === void 0)
            return;
          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for (let i2 = 0, l = _instanceIntersects.length; i2 < l; i2++) {
              const intersect = _instanceIntersects[i2];
              intersect.instanceId = instanceId;
              intersect.object = this;
              intersects2.push(intersect);
            }
            _instanceIntersects.length = 0;
          }
        }
        setColorAt(index, color) {
          if (this.instanceColor === null) {
            this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
          }
          color.toArray(this.instanceColor.array, index * 3);
        }
        setMatrixAt(index, matrix) {
          matrix.toArray(this.instanceMatrix.array, index * 16);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      InstancedMesh.prototype.isInstancedMesh = true;
      class LineBasicMaterial3 extends Material {
        constructor(parameters) {
          super();
          this.type = "LineBasicMaterial";
          this.color = new Color(16777215);
          this.linewidth = 1;
          this.linecap = "round";
          this.linejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.linewidth = source.linewidth;
          this.linecap = source.linecap;
          this.linejoin = source.linejoin;
          return this;
        }
      }
      LineBasicMaterial3.prototype.isLineBasicMaterial = true;
      const _start$1 = /* @__PURE__ */ new Vector34();
      const _end$1 = /* @__PURE__ */ new Vector34();
      const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
      const _ray$1 = /* @__PURE__ */ new Ray();
      const _sphere$1 = /* @__PURE__ */ new Sphere();
      class Line2 extends Object3D2 {
        constructor(geometry2 = new BufferGeometry3(), material2 = new LineBasicMaterial3()) {
          super();
          this.type = "Line";
          this.geometry = geometry2;
          this.material = material2;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        computeLineDistances() {
          const geometry2 = this.geometry;
          if (geometry2.isBufferGeometry) {
            if (geometry2.index === null) {
              const positionAttribute = geometry2.attributes.position;
              const lineDistances = [0];
              for (let i2 = 1, l = positionAttribute.count; i2 < l; i2++) {
                _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
                _end$1.fromBufferAttribute(positionAttribute, i2);
                lineDistances[i2] = lineDistances[i2 - 1];
                lineDistances[i2] += _start$1.distanceTo(_end$1);
              }
              geometry2.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
            } else {
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry2.isGeometry) {
            console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry2 = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;
          const drawRange = geometry2.drawRange;
          if (geometry2.boundingSphere === null)
            geometry2.computeBoundingSphere();
          _sphere$1.copy(geometry2.boundingSphere);
          _sphere$1.applyMatrix4(matrixWorld);
          _sphere$1.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere$1) === false)
            return;
          _inverseMatrix$1.copy(matrixWorld).invert();
          _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const vStart = new Vector34();
          const vEnd = new Vector34();
          const interSegment = new Vector34();
          const interRay = new Vector34();
          const step = this.isLineSegments ? 2 : 1;
          if (geometry2.isBufferGeometry) {
            const index = geometry2.index;
            const attributes = geometry2.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
                const a = index.getX(i2);
                const b = index.getX(i2 + 1);
                vStart.fromBufferAttribute(positionAttribute, a);
                vEnd.fromBufferAttribute(positionAttribute, b);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
                vStart.fromBufferAttribute(positionAttribute, i2);
                vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else if (geometry2.isGeometry) {
            console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry2 = this.geometry;
          if (geometry2.isBufferGeometry) {
            const morphAttributes = geometry2.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                  const name = morphAttribute[m2].name || String(m2);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m2;
                }
              }
            }
          } else {
            const morphTargets = geometry2.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      }
      Line2.prototype.isLine = true;
      const _start = /* @__PURE__ */ new Vector34();
      const _end = /* @__PURE__ */ new Vector34();
      class LineSegments2 extends Line2 {
        constructor(geometry2, material2) {
          super(geometry2, material2);
          this.type = "LineSegments";
        }
        computeLineDistances() {
          const geometry2 = this.geometry;
          if (geometry2.isBufferGeometry) {
            if (geometry2.index === null) {
              const positionAttribute = geometry2.attributes.position;
              const lineDistances = [];
              for (let i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2) {
                _start.fromBufferAttribute(positionAttribute, i2);
                _end.fromBufferAttribute(positionAttribute, i2 + 1);
                lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
                lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
              }
              geometry2.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
            } else {
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry2.isGeometry) {
            console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
      }
      LineSegments2.prototype.isLineSegments = true;
      class LineLoop extends Line2 {
        constructor(geometry2, material2) {
          super(geometry2, material2);
          this.type = "LineLoop";
        }
      }
      LineLoop.prototype.isLineLoop = true;
      class PointsMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "PointsMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.size = 1;
          this.sizeAttenuation = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.size = source.size;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      }
      PointsMaterial.prototype.isPointsMaterial = true;
      const _inverseMatrix = /* @__PURE__ */ new Matrix4();
      const _ray = /* @__PURE__ */ new Ray();
      const _sphere = /* @__PURE__ */ new Sphere();
      const _position$2 = /* @__PURE__ */ new Vector34();
      class Points extends Object3D2 {
        constructor(geometry2 = new BufferGeometry3(), material2 = new PointsMaterial()) {
          super();
          this.type = "Points";
          this.geometry = geometry2;
          this.material = material2;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry2 = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;
          const drawRange = geometry2.drawRange;
          if (geometry2.boundingSphere === null)
            geometry2.computeBoundingSphere();
          _sphere.copy(geometry2.boundingSphere);
          _sphere.applyMatrix4(matrixWorld);
          _sphere.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere) === false)
            return;
          _inverseMatrix.copy(matrixWorld).invert();
          _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          if (geometry2.isBufferGeometry) {
            const index = geometry2.index;
            const attributes = geometry2.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2++) {
                const a = index.getX(i2);
                _position$2.fromBufferAttribute(positionAttribute, a);
                testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end; i2 < l; i2++) {
                _position$2.fromBufferAttribute(positionAttribute, i2);
                testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            }
          } else {
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry2 = this.geometry;
          if (geometry2.isBufferGeometry) {
            const morphAttributes = geometry2.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
                  const name = morphAttribute[m2].name || String(m2);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m2;
                }
              }
            }
          } else {
            const morphTargets = geometry2.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      }
      Points.prototype.isPoints = true;
      function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
        const rayPointDistanceSq = _ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          const intersectPoint = new Vector34();
          _ray.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index,
            face: null,
            object
          });
        }
      }
      class VideoTexture extends Texture {
        constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
          super(video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
          this.format = format2 !== void 0 ? format2 : RGBFormat;
          this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
          this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
          this.generateMipmaps = false;
          const scope = this;
          function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
          }
          if ("requestVideoFrameCallback" in video) {
            video.requestVideoFrameCallback(updateVideo);
          }
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const video = this.image;
          const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
          if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
            this.needsUpdate = true;
          }
        }
      }
      VideoTexture.prototype.isVideoTexture = true;
      class CompressedTexture extends Texture {
        constructor(mipmaps, width, height, format2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
          this.image = {
            width,
            height
          };
          this.mipmaps = mipmaps;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      }
      CompressedTexture.prototype.isCompressedTexture = true;
      class CanvasTexture extends Texture {
        constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
          super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
          this.needsUpdate = true;
        }
      }
      CanvasTexture.prototype.isCanvasTexture = true;
      class CircleGeometry extends BufferGeometry3 {
        constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CircleGeometry";
          this.parameters = {
            radius,
            segments,
            thetaStart,
            thetaLength
          };
          segments = Math.max(3, segments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex2 = new Vector34();
          const uv = new Vector2();
          vertices.push(0, 0, 0);
          normals.push(0, 0, 1);
          uvs.push(0.5, 0.5);
          for (let s3 = 0, i2 = 3; s3 <= segments; s3++, i2 += 3) {
            const segment = thetaStart + s3 / segments * thetaLength;
            vertex2.x = radius * Math.cos(segment);
            vertex2.y = radius * Math.sin(segment);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i2] / radius + 1) / 2;
            uv.y = (vertices[i2 + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          for (let i2 = 1; i2 <= segments; i2++) {
            indices.push(i2, i2 + 1, 0);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
        }
      }
      class CylinderGeometry extends BufferGeometry3 {
        constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CylinderGeometry";
          this.parameters = {
            radiusTop,
            radiusBottom,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
          const scope = this;
          radialSegments = Math.floor(radialSegments);
          heightSegments = Math.floor(heightSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let index = 0;
          const indexArray = [];
          const halfHeight = height / 2;
          let groupStart = 0;
          generateTorso();
          if (openEnded === false) {
            if (radiusTop > 0)
              generateCap(true);
            if (radiusBottom > 0)
              generateCap(false);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function generateTorso() {
            const normal = new Vector34();
            const vertex2 = new Vector34();
            let groupCount = 0;
            const slope = (radiusBottom - radiusTop) / height;
            for (let y = 0; y <= heightSegments; y++) {
              const indexRow = [];
              const v = y / heightSegments;
              const radius = v * (radiusBottom - radiusTop) + radiusTop;
              for (let x2 = 0; x2 <= radialSegments; x2++) {
                const u = x2 / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                vertex2.x = radius * sinTheta;
                vertex2.y = -v * height + halfHeight;
                vertex2.z = radius * cosTheta;
                vertices.push(vertex2.x, vertex2.y, vertex2.z);
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, 1 - v);
                indexRow.push(index++);
              }
              indexArray.push(indexRow);
            }
            for (let x2 = 0; x2 < radialSegments; x2++) {
              for (let y = 0; y < heightSegments; y++) {
                const a = indexArray[y][x2];
                const b = indexArray[y + 1][x2];
                const c = indexArray[y + 1][x2 + 1];
                const d = indexArray[y][x2 + 1];
                indices.push(a, b, d);
                indices.push(b, c, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
          }
          function generateCap(top) {
            const centerIndexStart = index;
            const uv = new Vector2();
            const vertex2 = new Vector34();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign2 = top === true ? 1 : -1;
            for (let x2 = 1; x2 <= radialSegments; x2++) {
              vertices.push(0, halfHeight * sign2, 0);
              normals.push(0, sign2, 0);
              uvs.push(0.5, 0.5);
              index++;
            }
            const centerIndexEnd = index;
            for (let x2 = 0; x2 <= radialSegments; x2++) {
              const u = x2 / radialSegments;
              const theta = u * thetaLength + thetaStart;
              const cosTheta = Math.cos(theta);
              const sinTheta = Math.sin(theta);
              vertex2.x = radius * sinTheta;
              vertex2.y = halfHeight * sign2;
              vertex2.z = radius * cosTheta;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normals.push(0, sign2, 0);
              uv.x = cosTheta * 0.5 + 0.5;
              uv.y = sinTheta * 0.5 * sign2 + 0.5;
              uvs.push(uv.x, uv.y);
              index++;
            }
            for (let x2 = 0; x2 < radialSegments; x2++) {
              const c = centerIndexStart + x2;
              const i2 = centerIndexEnd + x2;
              if (top === true) {
                indices.push(i2, i2 + 1, c);
              } else {
                indices.push(i2 + 1, i2, c);
              }
              groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
          }
        }
        static fromJSON(data) {
          return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      }
      class ConeGeometry extends CylinderGeometry {
        constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
          this.type = "ConeGeometry";
          this.parameters = {
            radius,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
        }
        static fromJSON(data) {
          return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      }
      class PolyhedronGeometry extends BufferGeometry3 {
        constructor(vertices = [], indices = [], radius = 1, detail = 0) {
          super();
          this.type = "PolyhedronGeometry";
          this.parameters = {
            vertices,
            indices,
            radius,
            detail
          };
          const vertexBuffer = [];
          const uvBuffer = [];
          subdivide(detail);
          applyRadius(radius);
          generateUVs();
          this.setAttribute("position", new Float32BufferAttribute2(vertexBuffer, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(vertexBuffer.slice(), 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvBuffer, 2));
          if (detail === 0) {
            this.computeVertexNormals();
          } else {
            this.normalizeNormals();
          }
          function subdivide(detail2) {
            const a = new Vector34();
            const b = new Vector34();
            const c = new Vector34();
            for (let i2 = 0; i2 < indices.length; i2 += 3) {
              getVertexByIndex(indices[i2 + 0], a);
              getVertexByIndex(indices[i2 + 1], b);
              getVertexByIndex(indices[i2 + 2], c);
              subdivideFace(a, b, c, detail2);
            }
          }
          function subdivideFace(a, b, c, detail2) {
            const cols = detail2 + 1;
            const v = [];
            for (let i2 = 0; i2 <= cols; i2++) {
              v[i2] = [];
              const aj = a.clone().lerp(c, i2 / cols);
              const bj = b.clone().lerp(c, i2 / cols);
              const rows = cols - i2;
              for (let j = 0; j <= rows; j++) {
                if (j === 0 && i2 === cols) {
                  v[i2][j] = aj;
                } else {
                  v[i2][j] = aj.clone().lerp(bj, j / rows);
                }
              }
            }
            for (let i2 = 0; i2 < cols; i2++) {
              for (let j = 0; j < 2 * (cols - i2) - 1; j++) {
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                  pushVertex(v[i2][k + 1]);
                  pushVertex(v[i2 + 1][k]);
                  pushVertex(v[i2][k]);
                } else {
                  pushVertex(v[i2][k + 1]);
                  pushVertex(v[i2 + 1][k + 1]);
                  pushVertex(v[i2 + 1][k]);
                }
              }
            }
          }
          function applyRadius(radius2) {
            const vertex2 = new Vector34();
            for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
              vertex2.x = vertexBuffer[i2 + 0];
              vertex2.y = vertexBuffer[i2 + 1];
              vertex2.z = vertexBuffer[i2 + 2];
              vertex2.normalize().multiplyScalar(radius2);
              vertexBuffer[i2 + 0] = vertex2.x;
              vertexBuffer[i2 + 1] = vertex2.y;
              vertexBuffer[i2 + 2] = vertex2.z;
            }
          }
          function generateUVs() {
            const vertex2 = new Vector34();
            for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
              vertex2.x = vertexBuffer[i2 + 0];
              vertex2.y = vertexBuffer[i2 + 1];
              vertex2.z = vertexBuffer[i2 + 2];
              const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
              const v = inclination(vertex2) / Math.PI + 0.5;
              uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
          }
          function correctSeam() {
            for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
              const x0 = uvBuffer[i2 + 0];
              const x1 = uvBuffer[i2 + 2];
              const x2 = uvBuffer[i2 + 4];
              const max = Math.max(x0, x1, x2);
              const min = Math.min(x0, x1, x2);
              if (max > 0.9 && min < 0.1) {
                if (x0 < 0.2)
                  uvBuffer[i2 + 0] += 1;
                if (x1 < 0.2)
                  uvBuffer[i2 + 2] += 1;
                if (x2 < 0.2)
                  uvBuffer[i2 + 4] += 1;
              }
            }
          }
          function pushVertex(vertex2) {
            vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
          }
          function getVertexByIndex(index, vertex2) {
            const stride = index * 3;
            vertex2.x = vertices[stride + 0];
            vertex2.y = vertices[stride + 1];
            vertex2.z = vertices[stride + 2];
          }
          function correctUVs() {
            const a = new Vector34();
            const b = new Vector34();
            const c = new Vector34();
            const centroid = new Vector34();
            const uvA = new Vector2();
            const uvB = new Vector2();
            const uvC = new Vector2();
            for (let i2 = 0, j = 0; i2 < vertexBuffer.length; i2 += 9, j += 6) {
              a.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
              b.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
              c.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
              uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
              uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
              uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
              centroid.copy(a).add(b).add(c).divideScalar(3);
              const azi = azimuth(centroid);
              correctUV(uvA, j + 0, a, azi);
              correctUV(uvB, j + 2, b, azi);
              correctUV(uvC, j + 4, c, azi);
            }
          }
          function correctUV(uv, stride, vector, azimuth2) {
            if (azimuth2 < 0 && uv.x === 1) {
              uvBuffer[stride] = uv.x - 1;
            }
            if (vector.x === 0 && vector.z === 0) {
              uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
            }
          }
          function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
          }
          function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
          }
        }
        static fromJSON(data) {
          return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
        }
      }
      class DodecahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t2 = (1 + Math.sqrt(5)) / 2;
          const r2 = 1 / t2;
          const vertices = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -r2,
            -t2,
            0,
            -r2,
            t2,
            0,
            r2,
            -t2,
            0,
            r2,
            t2,
            -r2,
            -t2,
            0,
            -r2,
            t2,
            0,
            r2,
            -t2,
            0,
            r2,
            t2,
            0,
            -t2,
            0,
            -r2,
            t2,
            0,
            -r2,
            -t2,
            0,
            r2,
            t2,
            0,
            r2
          ];
          const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
          super(vertices, indices, radius, detail);
          this.type = "DodecahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new DodecahedronGeometry(data.radius, data.detail);
        }
      }
      const _v0 = new Vector34();
      const _v1$1 = new Vector34();
      const _normal = new Vector34();
      const _triangle = new Triangle();
      class EdgesGeometry extends BufferGeometry3 {
        constructor(geometry2 = null, thresholdAngle = 1) {
          super();
          this.type = "EdgesGeometry";
          this.parameters = {
            geometry: geometry2,
            thresholdAngle
          };
          if (geometry2 !== null) {
            const precisionPoints = 4;
            const precision = Math.pow(10, precisionPoints);
            const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
            const indexAttr = geometry2.getIndex();
            const positionAttr = geometry2.getAttribute("position");
            const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
            const indexArr = [0, 0, 0];
            const vertKeys = ["a", "b", "c"];
            const hashes = new Array(3);
            const edgeData = {};
            const vertices = [];
            for (let i2 = 0; i2 < indexCount; i2 += 3) {
              if (indexAttr) {
                indexArr[0] = indexAttr.getX(i2);
                indexArr[1] = indexAttr.getX(i2 + 1);
                indexArr[2] = indexAttr.getX(i2 + 2);
              } else {
                indexArr[0] = i2;
                indexArr[1] = i2 + 1;
                indexArr[2] = i2 + 2;
              }
              const {
                a,
                b,
                c
              } = _triangle;
              a.fromBufferAttribute(positionAttr, indexArr[0]);
              b.fromBufferAttribute(positionAttr, indexArr[1]);
              c.fromBufferAttribute(positionAttr, indexArr[2]);
              _triangle.getNormal(_normal);
              hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
              hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
              hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
              if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                continue;
              }
              for (let j = 0; j < 3; j++) {
                const jNext = (j + 1) % 3;
                const vecHash0 = hashes[j];
                const vecHash1 = hashes[jNext];
                const v0 = _triangle[vertKeys[j]];
                const v1 = _triangle[vertKeys[jNext]];
                const hash2 = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                  if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                    vertices.push(v0.x, v0.y, v0.z);
                    vertices.push(v1.x, v1.y, v1.z);
                  }
                  edgeData[reverseHash] = null;
                } else if (!(hash2 in edgeData)) {
                  edgeData[hash2] = {
                    index0: indexArr[j],
                    index1: indexArr[jNext],
                    normal: _normal.clone()
                  };
                }
              }
            }
            for (const key in edgeData) {
              if (edgeData[key]) {
                const {
                  index0,
                  index1
                } = edgeData[key];
                _v0.fromBufferAttribute(positionAttr, index0);
                _v1$1.fromBufferAttribute(positionAttr, index1);
                vertices.push(_v0.x, _v0.y, _v0.z);
                vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
              }
            }
            this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          }
        }
      }
      class Curve {
        constructor() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
          return null;
        }
        getPointAt(u, optionalTarget) {
          const t2 = this.getUtoTmapping(u);
          return this.getPoint(t2, optionalTarget);
        }
        getPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPoint(d / divisions));
          }
          return points;
        }
        getSpacedPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPointAt(d / divisions));
          }
          return points;
        }
        getLength() {
          const lengths = this.getLengths();
          return lengths[lengths.length - 1];
        }
        getLengths(divisions = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          const cache = [];
          let current, last = this.getPoint(0);
          let sum = 0;
          cache.push(0);
          for (let p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
          }
          this.cacheArcLengths = cache;
          return cache;
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.getLengths();
        }
        getUtoTmapping(u, distance) {
          const arcLengths = this.getLengths();
          let i2 = 0;
          const il = arcLengths.length;
          let targetArcLength;
          if (distance) {
            targetArcLength = distance;
          } else {
            targetArcLength = u * arcLengths[il - 1];
          }
          let low = 0, high = il - 1, comparison;
          while (low <= high) {
            i2 = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i2] - targetArcLength;
            if (comparison < 0) {
              low = i2 + 1;
            } else if (comparison > 0) {
              high = i2 - 1;
            } else {
              high = i2;
              break;
            }
          }
          i2 = high;
          if (arcLengths[i2] === targetArcLength) {
            return i2 / (il - 1);
          }
          const lengthBefore = arcLengths[i2];
          const lengthAfter = arcLengths[i2 + 1];
          const segmentLength = lengthAfter - lengthBefore;
          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          const t2 = (i2 + segmentFraction) / (il - 1);
          return t2;
        }
        getTangent(t2, optionalTarget) {
          const delta = 1e-4;
          let t1 = t2 - delta;
          let t22 = t2 + delta;
          if (t1 < 0)
            t1 = 0;
          if (t22 > 1)
            t22 = 1;
          const pt1 = this.getPoint(t1);
          const pt2 = this.getPoint(t22);
          const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector34());
          tangent.copy(pt2).sub(pt1).normalize();
          return tangent;
        }
        getTangentAt(u, optionalTarget) {
          const t2 = this.getUtoTmapping(u);
          return this.getTangent(t2, optionalTarget);
        }
        computeFrenetFrames(segments, closed) {
          const normal = new Vector34();
          const tangents = [];
          const normals = [];
          const binormals = [];
          const vec = new Vector34();
          const mat = new Matrix4();
          for (let i2 = 0; i2 <= segments; i2++) {
            const u = i2 / segments;
            tangents[i2] = this.getTangentAt(u, new Vector34());
          }
          normals[0] = new Vector34();
          binormals[0] = new Vector34();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);
          if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
          }
          if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
          }
          if (tz <= min) {
            normal.set(0, 0, 1);
          }
          vec.crossVectors(tangents[0], normal).normalize();
          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2] = normals[i2 - 1].clone();
            binormals[i2] = binormals[i2 - 1].clone();
            vec.crossVectors(tangents[i2 - 1], tangents[i2]);
            if (vec.length() > Number.EPSILON) {
              vec.normalize();
              const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
              normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
          if (closed === true) {
            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
              theta = -theta;
            }
            for (let i2 = 1; i2 <= segments; i2++) {
              normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
              binormals[i2].crossVectors(tangents[i2], normals[i2]);
            }
          }
          return {
            tangents,
            normals,
            binormals
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.arcLengthDivisions = source.arcLengthDivisions;
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;
          return data;
        }
        fromJSON(json) {
          this.arcLengthDivisions = json.arcLengthDivisions;
          return this;
        }
      }
      class EllipseCurve extends Curve {
        constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
          super();
          this.type = "EllipseCurve";
          this.aX = aX;
          this.aY = aY;
          this.xRadius = xRadius;
          this.yRadius = yRadius;
          this.aStartAngle = aStartAngle;
          this.aEndAngle = aEndAngle;
          this.aClockwise = aClockwise;
          this.aRotation = aRotation;
        }
        getPoint(t2, optionalTarget) {
          const point = optionalTarget || new Vector2();
          const twoPi = Math.PI * 2;
          let deltaAngle = this.aEndAngle - this.aStartAngle;
          const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
          while (deltaAngle < 0)
            deltaAngle += twoPi;
          while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
          if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
              deltaAngle = 0;
            } else {
              deltaAngle = twoPi;
            }
          }
          if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
              deltaAngle = -twoPi;
            } else {
              deltaAngle = deltaAngle - twoPi;
            }
          }
          const angle = this.aStartAngle + t2 * deltaAngle;
          let x2 = this.aX + this.xRadius * Math.cos(angle);
          let y = this.aY + this.yRadius * Math.sin(angle);
          if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x2 - this.aX;
            const ty = y - this.aY;
            x2 = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
          }
          return point.set(x2, y);
        }
        copy(source) {
          super.copy(source);
          this.aX = source.aX;
          this.aY = source.aY;
          this.xRadius = source.xRadius;
          this.yRadius = source.yRadius;
          this.aStartAngle = source.aStartAngle;
          this.aEndAngle = source.aEndAngle;
          this.aClockwise = source.aClockwise;
          this.aRotation = source.aRotation;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.aX = this.aX;
          data.aY = this.aY;
          data.xRadius = this.xRadius;
          data.yRadius = this.yRadius;
          data.aStartAngle = this.aStartAngle;
          data.aEndAngle = this.aEndAngle;
          data.aClockwise = this.aClockwise;
          data.aRotation = this.aRotation;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.aX = json.aX;
          this.aY = json.aY;
          this.xRadius = json.xRadius;
          this.yRadius = json.yRadius;
          this.aStartAngle = json.aStartAngle;
          this.aEndAngle = json.aEndAngle;
          this.aClockwise = json.aClockwise;
          this.aRotation = json.aRotation;
          return this;
        }
      }
      EllipseCurve.prototype.isEllipseCurve = true;
      class ArcCurve extends EllipseCurve {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          this.type = "ArcCurve";
        }
      }
      ArcCurve.prototype.isArcCurve = true;
      function CubicPoly() {
        let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        function init2(x0, x1, t0, t1) {
          c0 = x0;
          c1 = t0;
          c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
          c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
          initCatmullRom: function(x0, x1, x2, x3, tension) {
            init2(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
          },
          initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            t1 *= dt1;
            t2 *= dt1;
            init2(x1, x2, t1, t2);
          },
          calc: function(t2) {
            const t22 = t2 * t2;
            const t3 = t22 * t2;
            return c0 + c1 * t2 + c2 * t22 + c3 * t3;
          }
        };
      }
      const tmp = new Vector34();
      const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
      class CatmullRomCurve3 extends Curve {
        constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
          super();
          this.type = "CatmullRomCurve3";
          this.points = points;
          this.closed = closed;
          this.curveType = curveType;
          this.tension = tension;
        }
        getPoint(t2, optionalTarget = new Vector34()) {
          const point = optionalTarget;
          const points = this.points;
          const l = points.length;
          const p = (l - (this.closed ? 0 : 1)) * t2;
          let intPoint = Math.floor(p);
          let weight = p - intPoint;
          if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
          } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
          }
          let p0, p3;
          if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
          } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
          }
          const p1 = points[intPoint % l];
          const p2 = points[(intPoint + 1) % l];
          if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
          } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
          }
          if (this.curveType === "centripetal" || this.curveType === "chordal") {
            const pow = this.curveType === "chordal" ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 1e-4)
              dt1 = 1;
            if (dt0 < 1e-4)
              dt0 = dt1;
            if (dt2 < 1e-4)
              dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
          } else if (this.curveType === "catmullrom") {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
          }
          point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          this.closed = source.closed;
          this.curveType = source.curveType;
          this.tension = source.tension;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          data.closed = this.closed;
          data.curveType = this.curveType;
          data.tension = this.tension;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector34().fromArray(point));
          }
          this.closed = json.closed;
          this.curveType = json.curveType;
          this.tension = json.tension;
          return this;
        }
      }
      CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
      function CatmullRom(t2, p0, p1, p2, p3) {
        const v0 = (p2 - p0) * 0.5;
        const v1 = (p3 - p1) * 0.5;
        const t22 = t2 * t2;
        const t3 = t2 * t22;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
      }
      function QuadraticBezierP0(t2, p) {
        const k = 1 - t2;
        return k * k * p;
      }
      function QuadraticBezierP1(t2, p) {
        return 2 * (1 - t2) * t2 * p;
      }
      function QuadraticBezierP2(t2, p) {
        return t2 * t2 * p;
      }
      function QuadraticBezier(t2, p0, p1, p2) {
        return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
      }
      function CubicBezierP0(t2, p) {
        const k = 1 - t2;
        return k * k * k * p;
      }
      function CubicBezierP1(t2, p) {
        const k = 1 - t2;
        return 3 * k * k * t2 * p;
      }
      function CubicBezierP2(t2, p) {
        return 3 * (1 - t2) * t2 * t2 * p;
      }
      function CubicBezierP3(t2, p) {
        return t2 * t2 * t2 * p;
      }
      function CubicBezier(t2, p0, p1, p2, p3) {
        return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
      }
      class CubicBezierCurve extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
          super();
          this.type = "CubicBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      }
      CubicBezierCurve.prototype.isCubicBezierCurve = true;
      class CubicBezierCurve3 extends Curve {
        constructor(v0 = new Vector34(), v1 = new Vector34(), v2 = new Vector34(), v3 = new Vector34()) {
          super();
          this.type = "CubicBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t2, optionalTarget = new Vector34()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      }
      CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
      class LineCurve extends Curve {
        constructor(v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.type = "LineCurve";
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          if (t2 === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t2).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        getTangent(t2, optionalTarget) {
          const tangent = optionalTarget || new Vector2();
          tangent.copy(this.v2).sub(this.v1).normalize();
          return tangent;
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      LineCurve.prototype.isLineCurve = true;
      class LineCurve3 extends Curve {
        constructor(v1 = new Vector34(), v2 = new Vector34()) {
          super();
          this.type = "LineCurve3";
          this.isLineCurve3 = true;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector34()) {
          const point = optionalTarget;
          if (t2 === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t2).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      class QuadraticBezierCurve extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.type = "QuadraticBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
      class QuadraticBezierCurve3 extends Curve {
        constructor(v0 = new Vector34(), v1 = new Vector34(), v2 = new Vector34()) {
          super();
          this.type = "QuadraticBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t2, optionalTarget = new Vector34()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
      class SplineCurve extends Curve {
        constructor(points = []) {
          super();
          this.type = "SplineCurve";
          this.points = points;
        }
        getPoint(t2, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const points = this.points;
          const p = (points.length - 1) * t2;
          const intPoint = Math.floor(p);
          const weight = p - intPoint;
          const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
          const p1 = points[intPoint];
          const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
          const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
          point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector2().fromArray(point));
          }
          return this;
        }
      }
      SplineCurve.prototype.isSplineCurve = true;
      var Curves = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcCurve,
        CatmullRomCurve3,
        CubicBezierCurve,
        CubicBezierCurve3,
        EllipseCurve,
        LineCurve,
        LineCurve3,
        QuadraticBezierCurve,
        QuadraticBezierCurve3,
        SplineCurve
      });
      class CurvePath extends Curve {
        constructor() {
          super();
          this.type = "CurvePath";
          this.curves = [];
          this.autoClose = false;
        }
        add(curve) {
          this.curves.push(curve);
        }
        closePath() {
          const startPoint = this.curves[0].getPoint(0);
          const endPoint = this.curves[this.curves.length - 1].getPoint(1);
          if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
          }
        }
        getPoint(t2, optionalTarget) {
          const d = t2 * this.getLength();
          const curveLengths = this.getCurveLengths();
          let i2 = 0;
          while (i2 < curveLengths.length) {
            if (curveLengths[i2] >= d) {
              const diff = curveLengths[i2] - d;
              const curve = this.curves[i2];
              const segmentLength = curve.getLength();
              const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
              return curve.getPointAt(u, optionalTarget);
            }
            i2++;
          }
          return null;
        }
        getLength() {
          const lens = this.getCurveLengths();
          return lens[lens.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.cacheLengths = null;
          this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
          }
          const lengths = [];
          let sums = 0;
          for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
            sums += this.curves[i2].getLength();
            lengths.push(sums);
          }
          this.cacheLengths = lengths;
          return lengths;
        }
        getSpacedPoints(divisions = 40) {
          const points = [];
          for (let i2 = 0; i2 <= divisions; i2++) {
            points.push(this.getPoint(i2 / divisions));
          }
          if (this.autoClose) {
            points.push(points[0]);
          }
          return points;
        }
        getPoints(divisions = 12) {
          const points = [];
          let last;
          for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
            const curve = curves[i2];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for (let j = 0; j < pts.length; j++) {
              const point = pts[j];
              if (last && last.equals(point))
                continue;
              points.push(point);
              last = point;
            }
          }
          if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
          }
          return points;
        }
        copy(source) {
          super.copy(source);
          this.curves = [];
          for (let i2 = 0, l = source.curves.length; i2 < l; i2++) {
            const curve = source.curves[i2];
            this.curves.push(curve.clone());
          }
          this.autoClose = source.autoClose;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.autoClose = this.autoClose;
          data.curves = [];
          for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
            const curve = this.curves[i2];
            data.curves.push(curve.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.autoClose = json.autoClose;
          this.curves = [];
          for (let i2 = 0, l = json.curves.length; i2 < l; i2++) {
            const curve = json.curves[i2];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
          }
          return this;
        }
      }
      class Path extends CurvePath {
        constructor(points) {
          super();
          this.type = "Path";
          this.currentPoint = new Vector2();
          if (points) {
            this.setFromPoints(points);
          }
        }
        setFromPoints(points) {
          this.moveTo(points[0].x, points[0].y);
          for (let i2 = 1, l = points.length; i2 < l; i2++) {
            this.lineTo(points[i2].x, points[i2].y);
          }
          return this;
        }
        moveTo(x2, y) {
          this.currentPoint.set(x2, y);
          return this;
        }
        lineTo(x2, y) {
          const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y));
          this.curves.push(curve);
          this.currentPoint.set(x2, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        splineThru(pts) {
          const npts = [this.currentPoint.clone()].concat(pts);
          const curve = new SplineCurve(npts);
          this.curves.push(curve);
          this.currentPoint.copy(pts[pts.length - 1]);
          return this;
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          return this;
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
              this.lineTo(firstPoint.x, firstPoint.y);
            }
          }
          this.curves.push(curve);
          const lastPoint = curve.getPoint(1);
          this.currentPoint.copy(lastPoint);
          return this;
        }
        copy(source) {
          super.copy(source);
          this.currentPoint.copy(source.currentPoint);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.currentPoint = this.currentPoint.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.currentPoint.fromArray(json.currentPoint);
          return this;
        }
      }
      class Shape extends Path {
        constructor(points) {
          super(points);
          this.uuid = generateUUID();
          this.type = "Shape";
          this.holes = [];
        }
        getPointsHoles(divisions) {
          const holesPts = [];
          for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
            holesPts[i2] = this.holes[i2].getPoints(divisions);
          }
          return holesPts;
        }
        extractPoints(divisions) {
          return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
          };
        }
        copy(source) {
          super.copy(source);
          this.holes = [];
          for (let i2 = 0, l = source.holes.length; i2 < l; i2++) {
            const hole = source.holes[i2];
            this.holes.push(hole.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.uuid = this.uuid;
          data.holes = [];
          for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
            const hole = this.holes[i2];
            data.holes.push(hole.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.uuid = json.uuid;
          this.holes = [];
          for (let i2 = 0, l = json.holes.length; i2 < l; i2++) {
            const hole = json.holes[i2];
            this.holes.push(new Path().fromJSON(hole));
          }
          return this;
        }
      }
      const Earcut = {
        triangulate: function(data, holeIndices, dim = 2) {
          const hasHoles = holeIndices && holeIndices.length;
          const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
          let outerNode = linkedList(data, 0, outerLen, dim, true);
          const triangles = [];
          if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
          let minX, minY, maxX, maxY, x2, y, invSize;
          if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
          if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i2 = dim; i2 < outerLen; i2 += dim) {
              x2 = data[i2];
              y = data[i2 + 1];
              if (x2 < minX)
                minX = x2;
              if (y < minY)
                minY = y;
              if (x2 > maxX)
                maxX = x2;
              if (y > maxY)
                maxY = y;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
          }
          earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
          return triangles;
        }
      };
      function linkedList(data, start, end, dim, clockwise) {
        let i2, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i2 = start; i2 < end; i2 += dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        } else {
          for (i2 = end - dim; i2 >= start; i2 -= dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        let p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        let stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        const a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        let p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        const a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        let p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        let p = start;
        do {
          const a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        let a = start;
        do {
          let b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              let c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize);
              earcutLinked(c, triangles, dim, minX, minY, invSize);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        const queue = [];
        let i2, len, start, end, list;
        for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          start = holeIndices[i2] * dim;
          end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i2 = 0; i2 < queue.length; i2++) {
          eliminateHole(queue[i2], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
          const b = splitPolygon(outerNode, hole);
          filterPoints(outerNode, outerNode.next);
          filterPoints(b, b.next);
        }
      }
      function findHoleBridge(hole, outerNode) {
        let p = outerNode;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity, m2;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              if (x2 === hx) {
                if (hy === p.y)
                  return p;
                if (hy === p.next.y)
                  return p.next;
              }
              m2 = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m2)
          return null;
        if (hx === qx)
          return m2;
        const stop = m2, mx = m2.x, my = m2.y;
        let tanMin = Infinity, tan;
        p = m2;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
              m2 = p;
              tanMin = tan;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p) {
        return area(m2.prev, m2, p.prev) < 0 && area(p.next, m2, m2.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        let p = start;
        do {
          if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        let i2, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i2 = 0; i2 < inSize; i2++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e2 = p;
                p = p.nextZ;
                pSize--;
              } else {
                e2 = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e2;
              else
                list = e2;
              e2.prevZ = tail;
              tail = e2;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y, minX, minY, invSize) {
        x2 = 32767 * (x2 - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x2 | y << 1;
      }
      function getLeftmost(start) {
        let p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
        return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r2) {
        return (q.y - p.y) * (r2.x - q.x) - (q.x - p.x) * (r2.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        const o1 = sign(area(p1, q1, p2));
        const o2 = sign(area(p1, q1, q2));
        const o3 = sign(area(p2, q2, p1));
        const o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r2) {
        return q.x <= Math.max(p.x, r2.x) && q.x >= Math.min(p.x, r2.x) && q.y <= Math.max(p.y, r2.y) && q.y >= Math.min(p.y, r2.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        let p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        let p = a, inside = false;
        const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
        do {
          if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i2, x2, y, last) {
        const p = new Node(i2, x2, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i2, x2, y) {
        this.i = i2;
        this.x = x2;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      function signedArea(data, start, end, dim) {
        let sum = 0;
        for (let i2 = start, j = end - dim; i2 < end; i2 += dim) {
          sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
          j = i2;
        }
        return sum;
      }
      class ShapeUtils {
        static area(contour) {
          const n = contour.length;
          let a = 0;
          for (let p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
          }
          return a * 0.5;
        }
        static isClockWise(pts) {
          return ShapeUtils.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
          const vertices = [];
          const holeIndices = [];
          const faces = [];
          removeDupEndPts(contour);
          addContour(vertices, contour);
          let holeIndex = contour.length;
          holes.forEach(removeDupEndPts);
          for (let i2 = 0; i2 < holes.length; i2++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i2].length;
            addContour(vertices, holes[i2]);
          }
          const triangles = Earcut.triangulate(vertices, holeIndices);
          for (let i2 = 0; i2 < triangles.length; i2 += 3) {
            faces.push(triangles.slice(i2, i2 + 3));
          }
          return faces;
        }
      }
      function removeDupEndPts(points) {
        const l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) {
          points.pop();
        }
      }
      function addContour(vertices, contour) {
        for (let i2 = 0; i2 < contour.length; i2++) {
          vertices.push(contour[i2].x);
          vertices.push(contour[i2].y);
        }
      }
      class ExtrudeGeometry extends BufferGeometry3 {
        constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options2 = {}) {
          super();
          this.type = "ExtrudeGeometry";
          this.parameters = {
            shapes,
            options: options2
          };
          shapes = Array.isArray(shapes) ? shapes : [shapes];
          const scope = this;
          const verticesArray = [];
          const uvArray = [];
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            addShape(shape);
          }
          this.setAttribute("position", new Float32BufferAttribute2(verticesArray, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvArray, 2));
          this.computeVertexNormals();
          function addShape(shape) {
            const placeholder = [];
            const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
            const steps = options2.steps !== void 0 ? options2.steps : 1;
            let depth = options2.depth !== void 0 ? options2.depth : 1;
            let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
            let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 0.2;
            let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 0.1;
            let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
            let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
            const extrudePath = options2.extrudePath;
            const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
            if (options2.amount !== void 0) {
              console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
              depth = options2.amount;
            }
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
              extrudePts = extrudePath.getSpacedPoints(steps);
              extrudeByPath = true;
              bevelEnabled = false;
              splineTube = extrudePath.computeFrenetFrames(steps, false);
              binormal = new Vector34();
              normal = new Vector34();
              position2 = new Vector34();
            }
            if (!bevelEnabled) {
              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
              bevelOffset = 0;
            }
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
                const ahole = holes[h2];
                if (ShapeUtils.isClockWise(ahole)) {
                  holes[h2] = ahole.reverse();
                }
              }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            const contour = vertices;
            for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
              const ahole = holes[h2];
              vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
              if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
              return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
              let v_trans_x, v_trans_y, shrink_by;
              const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
              const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
              const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
              const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
              if (Math.abs(collinear0) > Number.EPSILON) {
                const v_prev_len = Math.sqrt(v_prev_lensq);
                const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                  return new Vector2(v_trans_x, v_trans_y);
                } else {
                  shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
              } else {
                let direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                  if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                      direction_eq = true;
                    }
                  }
                }
                if (direction_eq) {
                  v_trans_x = -v_prev_y;
                  v_trans_y = v_prev_x;
                  shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                  v_trans_x = v_prev_x;
                  v_trans_y = v_prev_y;
                  shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
              }
              return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
              const ahole = holes[h2];
              oneHoleMovements = [];
              for (let i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
                if (j === il)
                  j = 0;
                if (k === il)
                  k = 0;
                oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
              }
              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (let b = 0; b < bevelSegments; b++) {
              const t2 = b / bevelSegments;
              const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il = contour.length; i2 < il; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
                v(vert.x, vert.y, -z);
              }
              for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
                const ahole = holes[h2];
                oneHoleMovements = holesMovements[h2];
                for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                  v(vert.x, vert.y, -z);
                }
              }
            }
            const bs = bevelSize + bevelOffset;
            for (let i2 = 0; i2 < vlen; i2++) {
              const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
              if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
              } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
            for (let s3 = 1; s3 <= steps; s3++) {
              for (let i2 = 0; i2 < vlen; i2++) {
                const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
                if (!extrudeByPath) {
                  v(vert.x, vert.y, depth / steps * s3);
                } else {
                  normal.copy(splineTube.normals[s3]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[s3]).multiplyScalar(vert.y);
                  position2.copy(extrudePts[s3]).add(normal).add(binormal);
                  v(position2.x, position2.y, position2.z);
                }
              }
            }
            for (let b = bevelSegments - 1; b >= 0; b--) {
              const t2 = b / bevelSegments;
              const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il = contour.length; i2 < il; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
                v(vert.x, vert.y, depth + z);
              }
              for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
                const ahole = holes[h2];
                oneHoleMovements = holesMovements[h2];
                for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                  if (!extrudeByPath) {
                    v(vert.x, vert.y, depth + z);
                  } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                  }
                }
              }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
              const start = verticesArray.length / 3;
              if (bevelEnabled) {
                let layer = 0;
                let offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
              } else {
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2], face[1], face[0]);
                }
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            function buildSideFaces() {
              const start = verticesArray.length / 3;
              let layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;
              for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
                const ahole = holes[h2];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour2, layeroffset) {
              let i2 = contour2.length;
              while (--i2 >= 0) {
                const j = i2;
                let k = i2 - 1;
                if (k < 0)
                  k = contour2.length - 1;
                for (let s3 = 0, sl = steps + bevelSegments * 2; s3 < sl; s3++) {
                  const slen1 = vlen * s3;
                  const slen2 = vlen * (s3 + 1);
                  const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                  f4(a, b, c, d);
                }
              }
            }
            function v(x2, y, z) {
              placeholder.push(x2);
              placeholder.push(y);
              placeholder.push(z);
            }
            function f3(a, b, c) {
              addVertex(a);
              addVertex(b);
              addVertex(c);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
              addVertex(a);
              addVertex(b);
              addVertex(d);
              addVertex(b);
              addVertex(c);
              addVertex(d);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[3]);
              addUV(uvs[1]);
              addUV(uvs[2]);
              addUV(uvs[3]);
            }
            function addVertex(index) {
              verticesArray.push(placeholder[index * 3 + 0]);
              verticesArray.push(placeholder[index * 3 + 1]);
              verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
              uvArray.push(vector2.x);
              uvArray.push(vector2.y);
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          const options2 = this.parameters.options;
          return toJSON$1(shapes, options2, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          const extrudePath = data.options.extrudePath;
          if (extrudePath !== void 0) {
            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
          }
          return new ExtrudeGeometry(geometryShapes, data.options);
        }
      }
      const WorldUVGenerator = {
        generateTopUV: function(geometry2, vertices, indexA, indexB, indexC) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
        },
        generateSideWallUV: function(geometry2, vertices, indexA, indexB, indexC, indexD) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const a_z = vertices[indexA * 3 + 2];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const b_z = vertices[indexB * 3 + 2];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          const c_z = vertices[indexC * 3 + 2];
          const d_x = vertices[indexD * 3];
          const d_y = vertices[indexD * 3 + 1];
          const d_z = vertices[indexD * 3 + 2];
          if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
          } else {
            return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
          }
        }
      };
      function toJSON$1(shapes, options2, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        if (options2.extrudePath !== void 0)
          data.options.extrudePath = options2.extrudePath.toJSON();
        return data;
      }
      class IcosahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t2 = (1 + Math.sqrt(5)) / 2;
          const vertices = [-1, t2, 0, 1, t2, 0, -1, -t2, 0, 1, -t2, 0, 0, -1, t2, 0, 1, t2, 0, -1, -t2, 0, 1, -t2, t2, 0, -1, t2, 0, 1, -t2, 0, -1, -t2, 0, 1];
          const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
          super(vertices, indices, radius, detail);
          this.type = "IcosahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new IcosahedronGeometry(data.radius, data.detail);
        }
      }
      class LatheGeometry extends BufferGeometry3 {
        constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
          super();
          this.type = "LatheGeometry";
          this.parameters = {
            points,
            segments,
            phiStart,
            phiLength
          };
          segments = Math.floor(segments);
          phiLength = clamp(phiLength, 0, Math.PI * 2);
          const indices = [];
          const vertices = [];
          const uvs = [];
          const inverseSegments = 1 / segments;
          const vertex2 = new Vector34();
          const uv = new Vector2();
          for (let i2 = 0; i2 <= segments; i2++) {
            const phi = phiStart + i2 * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for (let j = 0; j <= points.length - 1; j++) {
              vertex2.x = points[j].x * sin;
              vertex2.y = points[j].y;
              vertex2.z = points[j].x * cos;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              uv.x = i2 / segments;
              uv.y = j / (points.length - 1);
              uvs.push(uv.x, uv.y);
            }
          }
          for (let i2 = 0; i2 < segments; i2++) {
            for (let j = 0; j < points.length - 1; j++) {
              const base2 = j + i2 * points.length;
              const a = base2;
              const b = base2 + points.length;
              const c = base2 + points.length + 1;
              const d = base2 + 1;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          this.computeVertexNormals();
          if (phiLength === Math.PI * 2) {
            const normals = this.attributes.normal.array;
            const n1 = new Vector34();
            const n2 = new Vector34();
            const n = new Vector34();
            const base2 = segments * points.length * 3;
            for (let i2 = 0, j = 0; i2 < points.length; i2++, j += 3) {
              n1.x = normals[j + 0];
              n1.y = normals[j + 1];
              n1.z = normals[j + 2];
              n2.x = normals[base2 + j + 0];
              n2.y = normals[base2 + j + 1];
              n2.z = normals[base2 + j + 2];
              n.addVectors(n1, n2).normalize();
              normals[j + 0] = normals[base2 + j + 0] = n.x;
              normals[j + 1] = normals[base2 + j + 1] = n.y;
              normals[j + 2] = normals[base2 + j + 2] = n.z;
            }
          }
        }
        static fromJSON(data) {
          return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
        }
      }
      class OctahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
          const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
          super(vertices, indices, radius, detail);
          this.type = "OctahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new OctahedronGeometry(data.radius, data.detail);
        }
      }
      class RingGeometry extends BufferGeometry3 {
        constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "RingGeometry";
          this.parameters = {
            innerRadius,
            outerRadius,
            thetaSegments,
            phiSegments,
            thetaStart,
            thetaLength
          };
          thetaSegments = Math.max(3, thetaSegments);
          phiSegments = Math.max(1, phiSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let radius = innerRadius;
          const radiusStep = (outerRadius - innerRadius) / phiSegments;
          const vertex2 = new Vector34();
          const uv = new Vector2();
          for (let j = 0; j <= phiSegments; j++) {
            for (let i2 = 0; i2 <= thetaSegments; i2++) {
              const segment = thetaStart + i2 / thetaSegments * thetaLength;
              vertex2.x = radius * Math.cos(segment);
              vertex2.y = radius * Math.sin(segment);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normals.push(0, 0, 1);
              uv.x = (vertex2.x / outerRadius + 1) / 2;
              uv.y = (vertex2.y / outerRadius + 1) / 2;
              uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
          }
          for (let j = 0; j < phiSegments; j++) {
            const thetaSegmentLevel = j * (thetaSegments + 1);
            for (let i2 = 0; i2 < thetaSegments; i2++) {
              const segment = i2 + thetaSegmentLevel;
              const a = segment;
              const b = segment + thetaSegments + 1;
              const c = segment + thetaSegments + 2;
              const d = segment + 1;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
        }
      }
      class ShapeGeometry extends BufferGeometry3 {
        constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
          super();
          this.type = "ShapeGeometry";
          this.parameters = {
            shapes,
            curveSegments
          };
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let groupStart = 0;
          let groupCount = 0;
          if (Array.isArray(shapes) === false) {
            addShape(shapes);
          } else {
            for (let i2 = 0; i2 < shapes.length; i2++) {
              addShape(shapes[i2]);
              this.addGroup(groupStart, groupCount, i2);
              groupStart += groupCount;
              groupCount = 0;
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
              shapeVertices = shapeVertices.reverse();
            }
            for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
              const shapeHole = shapeHoles[i2];
              if (ShapeUtils.isClockWise(shapeHole) === true) {
                shapeHoles[i2] = shapeHole.reverse();
              }
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
              const shapeHole = shapeHoles[i2];
              shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (let i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
              const vertex2 = shapeVertices[i2];
              vertices.push(vertex2.x, vertex2.y, 0);
              normals.push(0, 0, 1);
              uvs.push(vertex2.x, vertex2.y);
            }
            for (let i2 = 0, l = faces.length; i2 < l; i2++) {
              const face = faces[i2];
              const a = face[0] + indexOffset;
              const b = face[1] + indexOffset;
              const c = face[2] + indexOffset;
              indices.push(a, b, c);
              groupCount += 3;
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          return toJSON(shapes, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          return new ShapeGeometry(geometryShapes, data.curveSegments);
        }
      }
      function toJSON(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        return data;
      }
      class SphereGeometry extends BufferGeometry3 {
        constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
          super();
          this.type = "SphereGeometry";
          this.parameters = {
            radius,
            widthSegments,
            heightSegments,
            phiStart,
            phiLength,
            thetaStart,
            thetaLength
          };
          widthSegments = Math.max(3, Math.floor(widthSegments));
          heightSegments = Math.max(2, Math.floor(heightSegments));
          const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
          let index = 0;
          const grid = [];
          const vertex2 = new Vector34();
          const normal = new Vector34();
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy <= heightSegments; iy++) {
            const verticesRow = [];
            const v = iy / heightSegments;
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
              uOffset = 0.5 / widthSegments;
            } else if (iy == heightSegments && thetaEnd == Math.PI) {
              uOffset = -0.5 / widthSegments;
            }
            for (let ix = 0; ix <= widthSegments; ix++) {
              const u = ix / widthSegments;
              vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
              vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal.copy(vertex2).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u + uOffset, 1 - v);
              verticesRow.push(index++);
            }
            grid.push(verticesRow);
          }
          for (let iy = 0; iy < heightSegments; iy++) {
            for (let ix = 0; ix < widthSegments; ix++) {
              const a = grid[iy][ix + 1];
              const b = grid[iy][ix];
              const c = grid[iy + 1][ix];
              const d = grid[iy + 1][ix + 1];
              if (iy !== 0 || thetaStart > 0)
                indices.push(a, b, d);
              if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
        }
      }
      class TetrahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
          const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
          super(vertices, indices, radius, detail);
          this.type = "TetrahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new TetrahedronGeometry(data.radius, data.detail);
        }
      }
      class TorusGeometry extends BufferGeometry3 {
        constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
          super();
          this.type = "TorusGeometry";
          this.parameters = {
            radius,
            tube,
            radialSegments,
            tubularSegments,
            arc
          };
          radialSegments = Math.floor(radialSegments);
          tubularSegments = Math.floor(tubularSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const center = new Vector34();
          const vertex2 = new Vector34();
          const normal = new Vector34();
          for (let j = 0; j <= radialSegments; j++) {
            for (let i2 = 0; i2 <= tubularSegments; i2++) {
              const u = i2 / tubularSegments * arc;
              const v = j / radialSegments * Math.PI * 2;
              vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
              vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
              vertex2.z = tube * Math.sin(v);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              center.x = radius * Math.cos(u);
              center.y = radius * Math.sin(u);
              normal.subVectors(vertex2, center).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i2 / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= radialSegments; j++) {
            for (let i2 = 1; i2 <= tubularSegments; i2++) {
              const a = (tubularSegments + 1) * j + i2 - 1;
              const b = (tubularSegments + 1) * (j - 1) + i2 - 1;
              const c = (tubularSegments + 1) * (j - 1) + i2;
              const d = (tubularSegments + 1) * j + i2;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
        }
      }
      class TorusKnotGeometry extends BufferGeometry3 {
        constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
          super();
          this.type = "TorusKnotGeometry";
          this.parameters = {
            radius,
            tube,
            tubularSegments,
            radialSegments,
            p,
            q
          };
          tubularSegments = Math.floor(tubularSegments);
          radialSegments = Math.floor(radialSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex2 = new Vector34();
          const normal = new Vector34();
          const P1 = new Vector34();
          const P2 = new Vector34();
          const B = new Vector34();
          const T = new Vector34();
          const N = new Vector34();
          for (let i2 = 0; i2 <= tubularSegments; ++i2) {
            const u = i2 / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            B.normalize();
            N.normalize();
            for (let j = 0; j <= radialSegments; ++j) {
              const v = j / radialSegments * Math.PI * 2;
              const cx = -tube * Math.cos(v);
              const cy = tube * Math.sin(v);
              vertex2.x = P1.x + (cx * N.x + cy * B.x);
              vertex2.y = P1.y + (cx * N.y + cy * B.y);
              vertex2.z = P1.z + (cx * N.z + cy * B.z);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal.subVectors(vertex2, P1).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i2 / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= tubularSegments; j++) {
            for (let i2 = 1; i2 <= radialSegments; i2++) {
              const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
              const b = (radialSegments + 1) * j + (i2 - 1);
              const c = (radialSegments + 1) * j + i2;
              const d = (radialSegments + 1) * (j - 1) + i2;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function calculatePositionOnCurve(u, p2, q2, radius2, position2) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q2 / p2 * u;
            const cs = Math.cos(quOverP);
            position2.x = radius2 * (2 + cs) * 0.5 * cu;
            position2.y = radius2 * (2 + cs) * su * 0.5;
            position2.z = radius2 * Math.sin(quOverP) * 0.5;
          }
        }
        static fromJSON(data) {
          return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
        }
      }
      class TubeGeometry extends BufferGeometry3 {
        constructor(path = new QuadraticBezierCurve3(new Vector34(-1, -1, 0), new Vector34(-1, 1, 0), new Vector34(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
          super();
          this.type = "TubeGeometry";
          this.parameters = {
            path,
            tubularSegments,
            radius,
            radialSegments,
            closed
          };
          const frames = path.computeFrenetFrames(tubularSegments, closed);
          this.tangents = frames.tangents;
          this.normals = frames.normals;
          this.binormals = frames.binormals;
          const vertex2 = new Vector34();
          const normal = new Vector34();
          const uv = new Vector2();
          let P = new Vector34();
          const vertices = [];
          const normals = [];
          const uvs = [];
          const indices = [];
          generateBufferData();
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function generateBufferData() {
            for (let i2 = 0; i2 < tubularSegments; i2++) {
              generateSegment(i2);
            }
            generateSegment(closed === false ? tubularSegments : 0);
            generateUVs();
            generateIndices();
          }
          function generateSegment(i2) {
            P = path.getPointAt(i2 / tubularSegments, P);
            const N = frames.normals[i2];
            const B = frames.binormals[i2];
            for (let j = 0; j <= radialSegments; j++) {
              const v = j / radialSegments * Math.PI * 2;
              const sin = Math.sin(v);
              const cos = -Math.cos(v);
              normal.x = cos * N.x + sin * B.x;
              normal.y = cos * N.y + sin * B.y;
              normal.z = cos * N.z + sin * B.z;
              normal.normalize();
              normals.push(normal.x, normal.y, normal.z);
              vertex2.x = P.x + radius * normal.x;
              vertex2.y = P.y + radius * normal.y;
              vertex2.z = P.z + radius * normal.z;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
            }
          }
          function generateIndices() {
            for (let j = 1; j <= tubularSegments; j++) {
              for (let i2 = 1; i2 <= radialSegments; i2++) {
                const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
                const b = (radialSegments + 1) * j + (i2 - 1);
                const c = (radialSegments + 1) * j + i2;
                const d = (radialSegments + 1) * (j - 1) + i2;
                indices.push(a, b, d);
                indices.push(b, c, d);
              }
            }
          }
          function generateUVs() {
            for (let i2 = 0; i2 <= tubularSegments; i2++) {
              for (let j = 0; j <= radialSegments; j++) {
                uv.x = i2 / tubularSegments;
                uv.y = j / radialSegments;
                uvs.push(uv.x, uv.y);
              }
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          data.path = this.parameters.path.toJSON();
          return data;
        }
        static fromJSON(data) {
          return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
        }
      }
      class WireframeGeometry extends BufferGeometry3 {
        constructor(geometry2 = null) {
          super();
          this.type = "WireframeGeometry";
          this.parameters = {
            geometry: geometry2
          };
          if (geometry2 !== null) {
            const vertices = [];
            const edges = new Set();
            const start = new Vector34();
            const end = new Vector34();
            if (geometry2.index !== null) {
              const position2 = geometry2.attributes.position;
              const indices = geometry2.index;
              let groups = geometry2.groups;
              if (groups.length === 0) {
                groups = [{
                  start: 0,
                  count: indices.count,
                  materialIndex: 0
                }];
              }
              for (let o = 0, ol = groups.length; o < ol; ++o) {
                const group = groups[o];
                const groupStart = group.start;
                const groupCount = group.count;
                for (let i2 = groupStart, l = groupStart + groupCount; i2 < l; i2 += 3) {
                  for (let j = 0; j < 3; j++) {
                    const index1 = indices.getX(i2 + j);
                    const index2 = indices.getX(i2 + (j + 1) % 3);
                    start.fromBufferAttribute(position2, index1);
                    end.fromBufferAttribute(position2, index2);
                    if (isUniqueEdge(start, end, edges) === true) {
                      vertices.push(start.x, start.y, start.z);
                      vertices.push(end.x, end.y, end.z);
                    }
                  }
                }
              }
            } else {
              const position2 = geometry2.attributes.position;
              for (let i2 = 0, l = position2.count / 3; i2 < l; i2++) {
                for (let j = 0; j < 3; j++) {
                  const index1 = 3 * i2 + j;
                  const index2 = 3 * i2 + (j + 1) % 3;
                  start.fromBufferAttribute(position2, index1);
                  end.fromBufferAttribute(position2, index2);
                  if (isUniqueEdge(start, end, edges) === true) {
                    vertices.push(start.x, start.y, start.z);
                    vertices.push(end.x, end.y, end.z);
                  }
                }
              }
            }
            this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          }
        }
      }
      function isUniqueEdge(start, end, edges) {
        const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
        const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
        if (edges.has(hash1) === true || edges.has(hash2) === true) {
          return false;
        } else {
          edges.add(hash1, hash2);
          return true;
        }
      }
      var Geometries = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BoxGeometry,
        BoxBufferGeometry: BoxGeometry,
        CircleGeometry,
        CircleBufferGeometry: CircleGeometry,
        ConeGeometry,
        ConeBufferGeometry: ConeGeometry,
        CylinderGeometry,
        CylinderBufferGeometry: CylinderGeometry,
        DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronGeometry,
        EdgesGeometry,
        ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeGeometry,
        IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronGeometry,
        LatheGeometry,
        LatheBufferGeometry: LatheGeometry,
        OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronGeometry,
        PlaneGeometry: PlaneGeometry2,
        PlaneBufferGeometry: PlaneGeometry2,
        PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronGeometry,
        RingGeometry,
        RingBufferGeometry: RingGeometry,
        ShapeGeometry,
        ShapeBufferGeometry: ShapeGeometry,
        SphereGeometry,
        SphereBufferGeometry: SphereGeometry,
        TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronGeometry,
        TorusGeometry,
        TorusBufferGeometry: TorusGeometry,
        TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotGeometry,
        TubeGeometry,
        TubeBufferGeometry: TubeGeometry,
        WireframeGeometry
      });
      class ShadowMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "ShadowMaterial";
          this.color = new Color(0);
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          return this;
        }
      }
      ShadowMaterial.prototype.isShadowMaterial = true;
      class MeshStandardMaterial extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": ""
          };
          this.type = "MeshStandardMaterial";
          this.color = new Color(16777215);
          this.roughness = 1;
          this.metalness = 0;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.roughnessMap = null;
          this.metalnessMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.envMapIntensity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": ""
          };
          this.color.copy(source.color);
          this.roughness = source.roughness;
          this.metalness = source.metalness;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.roughnessMap = source.roughnessMap;
          this.metalnessMap = source.metalnessMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.envMapIntensity = source.envMapIntensity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      }
      MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
      class MeshPhysicalMaterial extends MeshStandardMaterial {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.type = "MeshPhysicalMaterial";
          this.clearcoatMap = null;
          this.clearcoatRoughness = 0;
          this.clearcoatRoughnessMap = null;
          this.clearcoatNormalScale = new Vector2(1, 1);
          this.clearcoatNormalMap = null;
          this.ior = 1.5;
          Object.defineProperty(this, "reflectivity", {
            get: function() {
              return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
              this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
          });
          this.sheenColor = new Color(0);
          this.sheenColorMap = null;
          this.sheenRoughness = 1;
          this.sheenRoughnessMap = null;
          this.transmissionMap = null;
          this.thickness = 0;
          this.thicknessMap = null;
          this.attenuationDistance = 0;
          this.attenuationColor = new Color(1, 1, 1);
          this.specularIntensity = 1;
          this.specularIntensityMap = null;
          this.specularColor = new Color(1, 1, 1);
          this.specularColorMap = null;
          this._sheen = 0;
          this._clearcoat = 0;
          this._transmission = 0;
          this.setValues(parameters);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(value) {
          if (this._sheen > 0 !== value > 0) {
            this.version++;
          }
          this._sheen = value;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(value) {
          if (this._clearcoat > 0 !== value > 0) {
            this.version++;
          }
          this._clearcoat = value;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(value) {
          if (this._transmission > 0 !== value > 0) {
            this.version++;
          }
          this._transmission = value;
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.clearcoat = source.clearcoat;
          this.clearcoatMap = source.clearcoatMap;
          this.clearcoatRoughness = source.clearcoatRoughness;
          this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
          this.clearcoatNormalMap = source.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
          this.ior = source.ior;
          this.sheen = source.sheen;
          this.sheenColor.copy(source.sheenColor);
          this.sheenColorMap = source.sheenColorMap;
          this.sheenRoughness = source.sheenRoughness;
          this.sheenRoughnessMap = source.sheenRoughnessMap;
          this.transmission = source.transmission;
          this.transmissionMap = source.transmissionMap;
          this.thickness = source.thickness;
          this.thicknessMap = source.thicknessMap;
          this.attenuationDistance = source.attenuationDistance;
          this.attenuationColor.copy(source.attenuationColor);
          this.specularIntensity = source.specularIntensity;
          this.specularIntensityMap = source.specularIntensityMap;
          this.specularColor.copy(source.specularColor);
          this.specularColorMap = source.specularColorMap;
          return this;
        }
      }
      MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
      class MeshPhongMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshPhongMaterial";
          this.color = new Color(16777215);
          this.specular = new Color(1118481);
          this.shininess = 30;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.specular.copy(source.specular);
          this.shininess = source.shininess;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      }
      MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
      class MeshToonMaterial extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "TOON": ""
          };
          this.type = "MeshToonMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.gradientMap = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.gradientMap = source.gradientMap;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      }
      MeshToonMaterial.prototype.isMeshToonMaterial = true;
      class MeshNormalMaterial2 extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshNormalMaterial";
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.flatShading = source.flatShading;
          return this;
        }
      }
      MeshNormalMaterial2.prototype.isMeshNormalMaterial = true;
      class MeshLambertMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshLambertMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      }
      MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
      class MeshMatcapMaterial extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "MATCAP": ""
          };
          this.type = "MeshMatcapMaterial";
          this.color = new Color(16777215);
          this.matcap = null;
          this.map = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "MATCAP": ""
          };
          this.color.copy(source.color);
          this.matcap = source.matcap;
          this.map = source.map;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.flatShading = source.flatShading;
          return this;
        }
      }
      MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
      class LineDashedMaterial extends LineBasicMaterial3 {
        constructor(parameters) {
          super();
          this.type = "LineDashedMaterial";
          this.scale = 1;
          this.dashSize = 3;
          this.gapSize = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.scale = source.scale;
          this.dashSize = source.dashSize;
          this.gapSize = source.gapSize;
          return this;
        }
      }
      LineDashedMaterial.prototype.isLineDashedMaterial = true;
      var Materials = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ShadowMaterial,
        SpriteMaterial,
        RawShaderMaterial,
        ShaderMaterial,
        PointsMaterial,
        MeshPhysicalMaterial,
        MeshStandardMaterial,
        MeshPhongMaterial,
        MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial2,
        MeshLambertMaterial,
        MeshDepthMaterial,
        MeshDistanceMaterial,
        MeshBasicMaterial,
        MeshMatcapMaterial,
        LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial3,
        Material
      });
      const AnimationUtils = {
        arraySlice: function(array, from, to) {
          if (AnimationUtils.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
          }
          return array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
          if (!array || !forceClone && array.constructor === type)
            return array;
          if (typeof type.BYTES_PER_ELEMENT === "number") {
            return new type(array);
          }
          return Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
          return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
          function compareTime(i2, j) {
            return times[i2] - times[j];
          }
          const n = times.length;
          const result = new Array(n);
          for (let i2 = 0; i2 !== n; ++i2)
            result[i2] = i2;
          result.sort(compareTime);
          return result;
        },
        sortedArray: function(values, stride, order) {
          const nValues = values.length;
          const result = new values.constructor(nValues);
          for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
            const srcOffset = order[i2] * stride;
            for (let j = 0; j !== stride; ++j) {
              result[dstOffset++] = values[srcOffset + j];
            }
          }
          return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
          let i2 = 1, key = jsonKeys[0];
          while (key !== void 0 && key[valuePropertyName] === void 0) {
            key = jsonKeys[i2++];
          }
          if (key === void 0)
            return;
          let value = key[valuePropertyName];
          if (value === void 0)
            return;
          if (Array.isArray(value)) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push.apply(values, value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else if (value.toArray !== void 0) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                value.toArray(values, values.length);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push(value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          }
        },
        subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
          const clip = sourceClip.clone();
          clip.name = name;
          const tracks = [];
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            const track = clip.tracks[i2];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for (let j = 0; j < track.times.length; ++j) {
              const frame = track.times[j] * fps;
              if (frame < startFrame || frame >= endFrame)
                continue;
              times.push(track.times[j]);
              for (let k = 0; k < valueSize; ++k) {
                values.push(track.values[j * valueSize + k]);
              }
            }
            if (times.length === 0)
              continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
          }
          clip.tracks = tracks;
          let minStartTime = Infinity;
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            if (minStartTime > clip.tracks[i2].times[0]) {
              minStartTime = clip.tracks[i2].times[0];
            }
          }
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            clip.tracks[i2].shift(-1 * minStartTime);
          }
          clip.resetDuration();
          return clip;
        },
        makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
          if (fps <= 0)
            fps = 30;
          const numTracks = referenceClip.tracks.length;
          const referenceTime = referenceFrame / fps;
          for (let i2 = 0; i2 < numTracks; ++i2) {
            const referenceTrack = referenceClip.tracks[i2];
            const referenceTrackType = referenceTrack.ValueTypeName;
            if (referenceTrackType === "bool" || referenceTrackType === "string")
              continue;
            const targetTrack = targetClip.tracks.find(function(track) {
              return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === void 0)
              continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              referenceOffset = referenceValueSize / 3;
            }
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              targetOffset = targetValueSize / 3;
            }
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            if (referenceTime <= referenceTrack.times[0]) {
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
              const startIndex = lastIndex * referenceValueSize + referenceOffset;
              const endIndex = startIndex + referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
              const interpolant = referenceTrack.createInterpolant();
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              interpolant.evaluate(referenceTime);
              referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            if (referenceTrackType === "quaternion") {
              const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
              referenceQuat.toArray(referenceValue);
            }
            const numTimes = targetTrack.times.length;
            for (let j = 0; j < numTimes; ++j) {
              const valueStart = j * targetValueSize + targetOffset;
              if (referenceTrackType === "quaternion") {
                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
              } else {
                const valueEnd = targetValueSize - targetOffset * 2;
                for (let k = 0; k < valueEnd; ++k) {
                  targetTrack.values[valueStart + k] -= referenceValue[k];
                }
              }
            }
          }
          targetClip.blendMode = AdditiveAnimationBlendMode;
          return targetClip;
        }
      };
      class Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          this.parameterPositions = parameterPositions;
          this._cachedIndex = 0;
          this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
          this.sampleValues = sampleValues;
          this.valueSize = sampleSize;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(t2) {
          const pp = this.parameterPositions;
          let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
          validate_interval: {
            seek: {
              let right;
              linear_scan: {
                forward_scan:
                  if (!(t2 < t1)) {
                    for (let giveUpAt = i1 + 2; ; ) {
                      if (t1 === void 0) {
                        if (t2 < t0)
                          break forward_scan;
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t2, t0);
                      }
                      if (i1 === giveUpAt)
                        break;
                      t0 = t1;
                      t1 = pp[++i1];
                      if (t2 < t1) {
                        break seek;
                      }
                    }
                    right = pp.length;
                    break linear_scan;
                  }
                if (!(t2 >= t0)) {
                  const t1global = pp[1];
                  if (t2 < t1global) {
                    i1 = 2;
                    t0 = t1global;
                  }
                  for (let giveUpAt = i1 - 2; ; ) {
                    if (t0 === void 0) {
                      this._cachedIndex = 0;
                      return this.beforeStart_(0, t2, t1);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t1 = t0;
                    t0 = pp[--i1 - 1];
                    if (t2 >= t0) {
                      break seek;
                    }
                  }
                  right = i1;
                  i1 = 0;
                  break linear_scan;
                }
                break validate_interval;
              }
              while (i1 < right) {
                const mid = i1 + right >>> 1;
                if (t2 < pp[mid]) {
                  right = mid;
                } else {
                  i1 = mid + 1;
                }
              }
              t1 = pp[i1];
              t0 = pp[i1 - 1];
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (t1 === void 0) {
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t0, t2);
              }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
          }
          return this.interpolate_(i1, t0, t2, t1);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset + i2];
          }
          return result;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
      Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
      class CubicInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
        }
        intervalChanged_(i1, t0, t1) {
          const pp = this.parameterPositions;
          let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
          if (tPrev === void 0) {
            switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
              case WrapAroundEnding:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
              default:
                iPrev = i1;
                tPrev = t1;
            }
          }
          if (tNext === void 0) {
            switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
              case WrapAroundEnding:
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
              default:
                iNext = i1 - 1;
                tNext = t0;
            }
          }
          const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t2, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t2 - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
          const sP = -wP * ppp + 2 * wP * pp - wP * p;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
          const sN = wN * ppp - wN * pp;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
          }
          return result;
        }
      }
      class LinearInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t2, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
          }
          return result;
        }
      }
      class DiscreteInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1) {
          return this.copySampleValue_(i1 - 1);
        }
      }
      class KeyframeTrack {
        constructor(name, times, values, interpolation) {
          if (name === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (times === void 0 || times.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
          this.name = name;
          this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
          this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
          this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        static toJSON(track) {
          const trackType = track.constructor;
          let json;
          if (trackType.toJSON !== this.toJSON) {
            json = trackType.toJSON(track);
          } else {
            json = {
              "name": track.name,
              "times": AnimationUtils.convertArray(track.times, Array),
              "values": AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
              json.interpolation = interpolation;
            }
          }
          json.type = track.ValueTypeName;
          return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
          return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
          return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
          return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
          let factoryMethod;
          switch (interpolation) {
            case InterpolateDiscrete:
              factoryMethod = this.InterpolantFactoryMethodDiscrete;
              break;
            case InterpolateLinear:
              factoryMethod = this.InterpolantFactoryMethodLinear;
              break;
            case InterpolateSmooth:
              factoryMethod = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (factoryMethod === void 0) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (interpolation !== this.DefaultInterpolation) {
                this.setInterpolation(this.DefaultInterpolation);
              } else {
                throw new Error(message);
              }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
          }
          this.createInterpolant = factoryMethod;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
              return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
              return InterpolateSmooth;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(timeOffset) {
          if (timeOffset !== 0) {
            const times = this.times;
            for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
              times[i2] += timeOffset;
            }
          }
          return this;
        }
        scale(timeScale) {
          if (timeScale !== 1) {
            const times = this.times;
            for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
              times[i2] *= timeScale;
            }
          }
          return this;
        }
        trim(startTime, endTime) {
          const times = this.times, nKeys = times.length;
          let from = 0, to = nKeys - 1;
          while (from !== nKeys && times[from] < startTime) {
            ++from;
          }
          while (to !== -1 && times[to] > endTime) {
            --to;
          }
          ++to;
          if (from !== 0 || to !== nKeys) {
            if (from >= to) {
              to = Math.max(to, 1);
              from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
          }
          return this;
        }
        validate() {
          let valid = true;
          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
          }
          const times = this.times, values = this.values, nKeys = times.length;
          if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
          }
          let prevTime = null;
          for (let i2 = 0; i2 !== nKeys; i2++) {
            const currTime = times[i2];
            if (typeof currTime === "number" && isNaN(currTime)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
              valid = false;
              break;
            }
            if (prevTime !== null && prevTime > currTime) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
              valid = false;
              break;
            }
            prevTime = currTime;
          }
          if (values !== void 0) {
            if (AnimationUtils.isTypedArray(values)) {
              for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
                const value = values[i2];
                if (isNaN(value)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                  valid = false;
                  break;
                }
              }
            }
          }
          return valid;
        }
        optimize() {
          const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
          let writeIndex = 1;
          for (let i2 = 1; i2 < lastIndex; ++i2) {
            let keep = false;
            const time = times[i2];
            const timeNext = times[i2 + 1];
            if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
              if (!smoothInterpolation) {
                const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (let j = 0; j !== stride; ++j) {
                  const value = values[offset + j];
                  if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                    keep = true;
                    break;
                  }
                }
              } else {
                keep = true;
              }
            }
            if (keep) {
              if (i2 !== writeIndex) {
                times[writeIndex] = times[i2];
                const readOffset = i2 * stride, writeOffset = writeIndex * stride;
                for (let j = 0; j !== stride; ++j) {
                  values[writeOffset + j] = values[readOffset + j];
                }
              }
              ++writeIndex;
            }
          }
          if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
            ++writeIndex;
          }
          if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
          } else {
            this.times = times;
            this.values = values;
          }
          return this;
        }
        clone() {
          const times = AnimationUtils.arraySlice(this.times, 0);
          const values = AnimationUtils.arraySlice(this.values, 0);
          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values);
          track.createInterpolant = this.createInterpolant;
          return track;
        }
      }
      KeyframeTrack.prototype.TimeBufferType = Float32Array;
      KeyframeTrack.prototype.ValueBufferType = Float32Array;
      KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      class BooleanKeyframeTrack extends KeyframeTrack {
      }
      BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
      BooleanKeyframeTrack.prototype.ValueBufferType = Array;
      BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      class ColorKeyframeTrack extends KeyframeTrack {
      }
      ColorKeyframeTrack.prototype.ValueTypeName = "color";
      class NumberKeyframeTrack extends KeyframeTrack {
      }
      NumberKeyframeTrack.prototype.ValueTypeName = "number";
      class QuaternionLinearInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t2, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
          let offset = i1 * stride;
          for (let end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
          }
          return result;
        }
      }
      class QuaternionKeyframeTrack extends KeyframeTrack {
        InterpolantFactoryMethodLinear(result) {
          return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
      }
      QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
      QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      class StringKeyframeTrack extends KeyframeTrack {
      }
      StringKeyframeTrack.prototype.ValueTypeName = "string";
      StringKeyframeTrack.prototype.ValueBufferType = Array;
      StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      class VectorKeyframeTrack extends KeyframeTrack {
      }
      VectorKeyframeTrack.prototype.ValueTypeName = "vector";
      class AnimationClip {
        constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
          this.name = name;
          this.tracks = tracks;
          this.duration = duration;
          this.blendMode = blendMode;
          this.uuid = generateUUID();
          if (this.duration < 0) {
            this.resetDuration();
          }
        }
        static parse(json) {
          const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
          for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
            tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
          }
          const clip = new this(json.name, json.duration, tracks, json.blendMode);
          clip.uuid = json.uuid;
          return clip;
        }
        static toJSON(clip) {
          const tracks = [], clipTracks = clip.tracks;
          const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
          };
          for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
            tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
          }
          return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];
          for (let i2 = 0; i2 < numMorphTargets; i2++) {
            let times = [];
            let values = [];
            times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
              times.push(numMorphTargets);
              values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
          }
          return new this(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
          let clipArray = objectOrClipArray;
          if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
          }
          for (let i2 = 0; i2 < clipArray.length; i2++) {
            if (clipArray[i2].name === name) {
              return clipArray[i2];
            }
          }
          return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
          const animationToMorphTargets = {};
          const pattern = /^([\w-]*?)([\d]+)$/;
          for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
            const morphTarget = morphTargets[i2];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
              const name = parts[1];
              let animationMorphTargets = animationToMorphTargets[name];
              if (!animationMorphTargets) {
                animationToMorphTargets[name] = animationMorphTargets = [];
              }
              animationMorphTargets.push(morphTarget);
            }
          }
          const clips = [];
          for (const name in animationToMorphTargets) {
            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
          }
          return clips;
        }
        static parseAnimation(animation, bones) {
          if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
          }
          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
              const times = [];
              const values = [];
              AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
              if (times.length !== 0) {
                destTracks.push(new trackType(trackName, times, values));
              }
            }
          };
          const tracks = [];
          const clipName = animation.name || "default";
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;
          let duration = animation.length || -1;
          const hierarchyTracks = animation.hierarchy || [];
          for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
            const animationKeys = hierarchyTracks[h2].keys;
            if (!animationKeys || animationKeys.length === 0)
              continue;
            if (animationKeys[0].morphTargets) {
              const morphTargetNames = {};
              let k;
              for (k = 0; k < animationKeys.length; k++) {
                if (animationKeys[k].morphTargets) {
                  for (let m2 = 0; m2 < animationKeys[k].morphTargets.length; m2++) {
                    morphTargetNames[animationKeys[k].morphTargets[m2]] = -1;
                  }
                }
              }
              for (const morphTargetName in morphTargetNames) {
                const times = [];
                const values = [];
                for (let m2 = 0; m2 !== animationKeys[k].morphTargets.length; ++m2) {
                  const animationKey = animationKeys[k];
                  times.push(animationKey.time);
                  values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                }
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
              }
              duration = morphTargetNames.length * (fps || 1);
            } else {
              const boneName = ".bones[" + bones[h2].name + "]";
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
              addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
            }
          }
          if (tracks.length === 0) {
            return null;
          }
          const clip = new this(clipName, duration, tracks, blendMode);
          return clip;
        }
        resetDuration() {
          const tracks = this.tracks;
          let duration = 0;
          for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
            const track = this.tracks[i2];
            duration = Math.max(duration, track.times[track.times.length - 1]);
          }
          this.duration = duration;
          return this;
        }
        trim() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].trim(0, this.duration);
          }
          return this;
        }
        validate() {
          let valid = true;
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            valid = valid && this.tracks[i2].validate();
          }
          return valid;
        }
        optimize() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].optimize();
          }
          return this;
        }
        clone() {
          const tracks = [];
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            tracks.push(this.tracks[i2].clone());
          }
          return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function getTrackTypeForValueTypeName(typeName) {
        switch (typeName.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return NumberKeyframeTrack;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return VectorKeyframeTrack;
          case "color":
            return ColorKeyframeTrack;
          case "quaternion":
            return QuaternionKeyframeTrack;
          case "bool":
          case "boolean":
            return BooleanKeyframeTrack;
          case "string":
            return StringKeyframeTrack;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
      }
      function parseKeyframeTrack(json) {
        if (json.type === void 0) {
          throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        }
        const trackType = getTrackTypeForValueTypeName(json.type);
        if (json.times === void 0) {
          const times = [], values = [];
          AnimationUtils.flattenJSON(json.keys, times, values, "value");
          json.times = times;
          json.values = values;
        }
        if (trackType.parse !== void 0) {
          return trackType.parse(json);
        } else {
          return new trackType(json.name, json.times, json.values, json.interpolation);
        }
      }
      const Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
          if (this.enabled === false)
            return;
          this.files[key] = file;
        },
        get: function(key) {
          if (this.enabled === false)
            return;
          return this.files[key];
        },
        remove: function(key) {
          delete this.files[key];
        },
        clear: function() {
          this.files = {};
        }
      };
      class LoadingManager {
        constructor(onLoad, onProgress, onError) {
          const scope = this;
          let isLoading = false;
          let itemsLoaded = 0;
          let itemsTotal = 0;
          let urlModifier = void 0;
          const handlers = [];
          this.onStart = void 0;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== void 0) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== void 0) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== void 0) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function(url) {
            if (scope.onError !== void 0) {
              scope.onError(url);
            }
          };
          this.resolveURL = function(url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function(transform2) {
            urlModifier = transform2;
            return this;
          };
          this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
          };
          this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) {
              handlers.splice(index, 2);
            }
            return this;
          };
          this.getHandler = function(file) {
            for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {
              const regex = handlers[i2];
              const loader = handlers[i2 + 1];
              if (regex.global)
                regex.lastIndex = 0;
              if (regex.test(file)) {
                return loader;
              }
            }
            return null;
          };
        }
      }
      const DefaultLoadingManager = new LoadingManager();
      class Loader {
        constructor(manager) {
          this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {
        }
        loadAsync(url, onProgress) {
          const scope = this;
          return new Promise(function(resolve2, reject) {
            scope.load(url, resolve2, onProgress, reject);
          });
        }
        parse() {
        }
        setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        }
        setWithCredentials(value) {
          this.withCredentials = value;
          return this;
        }
        setPath(path) {
          this.path = path;
          return this;
        }
        setResourcePath(resourcePath) {
          this.resourcePath = resourcePath;
          return this;
        }
        setRequestHeader(requestHeader) {
          this.requestHeader = requestHeader;
          return this;
        }
      }
      const loading = {};
      class FileLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const cached = Cache.get(url);
          if (cached !== void 0) {
            this.manager.itemStart(url);
            setTimeout(() => {
              if (onLoad)
                onLoad(cached);
              this.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          if (loading[url] !== void 0) {
            loading[url].push({
              onLoad,
              onProgress,
              onError
            });
            return;
          }
          loading[url] = [];
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          const req = new Request(url, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          });
          fetch(req).then((response) => {
            if (response.status === 200 || response.status === 0) {
              if (response.status === 0) {
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              }
              const callbacks = loading[url];
              const reader = response.body.getReader();
              const contentLength = response.headers.get("Content-Length");
              const total = contentLength ? parseInt(contentLength) : 0;
              const lengthComputable = total !== 0;
              let loaded = 0;
              return new ReadableStream({
                start(controller) {
                  readData();
                  function readData() {
                    reader.read().then(({
                      done,
                      value
                    }) => {
                      if (done) {
                        controller.close();
                      } else {
                        loaded += value.byteLength;
                        const event = new ProgressEvent("progress", {
                          lengthComputable,
                          loaded,
                          total
                        });
                        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                          const callback = callbacks[i2];
                          if (callback.onProgress)
                            callback.onProgress(event);
                        }
                        controller.enqueue(value);
                        readData();
                      }
                    });
                  }
                }
              });
            } else {
              throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
            }
          }).then((stream) => {
            const response = new Response(stream);
            switch (this.responseType) {
              case "arraybuffer":
                return response.arrayBuffer();
              case "blob":
                return response.blob();
              case "document":
                return response.text().then((text) => {
                  const parser = new DOMParser();
                  return parser.parseFromString(text, this.mimeType);
                });
              case "json":
                return response.json();
              default:
                return response.text();
            }
          }).then((data) => {
            Cache.add(url, data);
            const callbacks = loading[url];
            delete loading[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onLoad)
                callback.onLoad(data);
            }
            this.manager.itemEnd(url);
          }).catch((err) => {
            const callbacks = loading[url];
            delete loading[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onError)
                callback.onError(err);
            }
            this.manager.itemError(url);
            this.manager.itemEnd(url);
          });
          this.manager.itemStart(url);
        }
        setResponseType(value) {
          this.responseType = value;
          return this;
        }
        setMimeType(value) {
          this.mimeType = value;
          return this;
        }
      }
      class AnimationLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e2) {
              if (onError) {
                onError(e2);
              } else {
                console.error(e2);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const animations = [];
          for (let i2 = 0; i2 < json.length; i2++) {
            const clip = AnimationClip.parse(json[i2]);
            animations.push(clip);
          }
          return animations;
        }
      }
      class CompressedTextureLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const images = [];
          const texture = new CompressedTexture();
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          let loaded = 0;
          function loadTexture(i2) {
            loader.load(url[i2], function(buffer) {
              const texDatas = scope.parse(buffer, true);
              images[i2] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = LinearFilter;
                texture.image = images;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          }
          if (Array.isArray(url)) {
            for (let i2 = 0, il = url.length; i2 < il; ++i2) {
              loadTexture(i2);
            }
          } else {
            loader.load(url, function(buffer) {
              const texDatas = scope.parse(buffer, true);
              if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for (let f3 = 0; f3 < faces; f3++) {
                  images[f3] = {
                    mipmaps: []
                  };
                  for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                    images[f3].mipmaps.push(texDatas.mipmaps[f3 * texDatas.mipmapCount + i2]);
                    images[f3].format = texDatas.format;
                    images[f3].width = texDatas.width;
                    images[f3].height = texDatas.height;
                  }
                }
                texture.image = images;
              } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
              }
              if (texDatas.mipmapCount === 1) {
                texture.minFilter = LinearFilter;
              }
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }, onProgress, onError);
          }
          return texture;
        }
      }
      class ImageLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const image = createElementNS("img");
          function onImageLoad() {
            removeEventListeners();
            Cache.add(url, this);
            if (onLoad)
              onLoad(this);
            scope.manager.itemEnd(url);
          }
          function onImageError(event) {
            removeEventListeners();
            if (onError)
              onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
          function removeEventListeners() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
          }
          image.addEventListener("load", onImageLoad, false);
          image.addEventListener("error", onImageError, false);
          if (url.substr(0, 5) !== "data:") {
            if (this.crossOrigin !== void 0)
              image.crossOrigin = this.crossOrigin;
          }
          scope.manager.itemStart(url);
          image.src = url;
          return image;
        }
      }
      class CubeTextureLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(urls, onLoad, onProgress, onError) {
          const texture = new CubeTexture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          let loaded = 0;
          function loadTexture(i2) {
            loader.load(urls[i2], function(image) {
              texture.images[i2] = image;
              loaded++;
              if (loaded === 6) {
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, void 0, onError);
          }
          for (let i2 = 0; i2 < urls.length; ++i2) {
            loadTexture(i2);
          }
          return texture;
        }
      }
      class DataTextureLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const texture = new DataTexture();
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setPath(this.path);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData)
              return;
            if (texData.image !== void 0) {
              texture.image = texData.image;
            } else if (texData.data !== void 0) {
              texture.image.width = texData.width;
              texture.image.height = texData.height;
              texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
            if (texData.encoding !== void 0) {
              texture.encoding = texData.encoding;
            }
            if (texData.flipY !== void 0) {
              texture.flipY = texData.flipY;
            }
            if (texData.format !== void 0) {
              texture.format = texData.format;
            }
            if (texData.type !== void 0) {
              texture.type = texData.type;
            }
            if (texData.mipmaps !== void 0) {
              texture.mipmaps = texData.mipmaps;
              texture.minFilter = LinearMipmapLinearFilter;
            }
            if (texData.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            if (texData.generateMipmaps !== void 0) {
              texture.generateMipmaps = texData.generateMipmaps;
            }
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture, texData);
          }, onProgress, onError);
          return texture;
        }
      }
      class TextureLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          loader.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== void 0) {
              onLoad(texture);
            }
          }, onProgress, onError);
          return texture;
        }
      }
      class Light extends Object3D2 {
        constructor(color, intensity = 1) {
          super();
          this.type = "Light";
          this.color = new Color(color);
          this.intensity = intensity;
        }
        dispose() {
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.intensity = source.intensity;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;
          if (this.groundColor !== void 0)
            data.object.groundColor = this.groundColor.getHex();
          if (this.distance !== void 0)
            data.object.distance = this.distance;
          if (this.angle !== void 0)
            data.object.angle = this.angle;
          if (this.decay !== void 0)
            data.object.decay = this.decay;
          if (this.penumbra !== void 0)
            data.object.penumbra = this.penumbra;
          if (this.shadow !== void 0)
            data.object.shadow = this.shadow.toJSON();
          return data;
        }
      }
      Light.prototype.isLight = true;
      class HemisphereLight extends Light {
        constructor(skyColor, groundColor, intensity) {
          super(skyColor, intensity);
          this.type = "HemisphereLight";
          this.position.copy(Object3D2.DefaultUp);
          this.updateMatrix();
          this.groundColor = new Color(groundColor);
        }
        copy(source) {
          Light.prototype.copy.call(this, source);
          this.groundColor.copy(source.groundColor);
          return this;
        }
      }
      HemisphereLight.prototype.isHemisphereLight = true;
      const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
      const _lightPositionWorld$1 = /* @__PURE__ */ new Vector34();
      const _lookTarget$1 = /* @__PURE__ */ new Vector34();
      class LightShadow {
        constructor(camera) {
          this.camera = camera;
          this.bias = 0;
          this.normalBias = 0;
          this.radius = 1;
          this.blurSamples = 8;
          this.mapSize = new Vector2(512, 512);
          this.map = null;
          this.mapPass = null;
          this.matrix = new Matrix4();
          this.autoUpdate = true;
          this.needsUpdate = false;
          this._frustum = new Frustum();
          this._frameExtents = new Vector2(1, 1);
          this._viewportCount = 1;
          this._viewports = [new Vector4(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(light) {
          const shadowCamera = this.camera;
          const shadowMatrix = this.matrix;
          _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld$1);
          _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget$1);
          shadowCamera.updateMatrixWorld();
          _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
          shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        }
        getViewport(viewportIndex) {
          return this._viewports[viewportIndex];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          if (this.map) {
            this.map.dispose();
          }
          if (this.mapPass) {
            this.mapPass.dispose();
          }
        }
        copy(source) {
          this.camera = source.camera.clone();
          this.bias = source.bias;
          this.radius = source.radius;
          this.mapSize.copy(source.mapSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const object = {};
          if (this.bias !== 0)
            object.bias = this.bias;
          if (this.normalBias !== 0)
            object.normalBias = this.normalBias;
          if (this.radius !== 1)
            object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;
          return object;
        }
      }
      class SpotLightShadow extends LightShadow {
        constructor() {
          super(new PerspectiveCamera2(50, 1, 0.5, 500));
          this.focus = 1;
        }
        updateMatrices(light) {
          const camera = this.camera;
          const fov2 = RAD2DEG * 2 * light.angle * this.focus;
          const aspect2 = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;
          if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
            camera.fov = fov2;
            camera.aspect = aspect2;
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          super.updateMatrices(light);
        }
        copy(source) {
          super.copy(source);
          this.focus = source.focus;
          return this;
        }
      }
      SpotLightShadow.prototype.isSpotLightShadow = true;
      class SpotLight extends Light {
        constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
          super(color, intensity);
          this.type = "SpotLight";
          this.position.copy(Object3D2.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D2();
          this.distance = distance;
          this.angle = angle;
          this.penumbra = penumbra;
          this.decay = decay;
          this.shadow = new SpotLightShadow();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(power) {
          this.intensity = power / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      }
      SpotLight.prototype.isSpotLight = true;
      const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
      const _lightPositionWorld = /* @__PURE__ */ new Vector34();
      const _lookTarget = /* @__PURE__ */ new Vector34();
      class PointLightShadow extends LightShadow {
        constructor() {
          super(new PerspectiveCamera2(90, 1, 0.5, 500));
          this._frameExtents = new Vector2(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            new Vector4(2, 1, 1, 1),
            new Vector4(0, 1, 1, 1),
            new Vector4(3, 1, 1, 1),
            new Vector4(1, 1, 1, 1),
            new Vector4(3, 0, 1, 1),
            new Vector4(1, 0, 1, 1)
          ];
          this._cubeDirections = [new Vector34(1, 0, 0), new Vector34(-1, 0, 0), new Vector34(0, 0, 1), new Vector34(0, 0, -1), new Vector34(0, 1, 0), new Vector34(0, -1, 0)];
          this._cubeUps = [new Vector34(0, 1, 0), new Vector34(0, 1, 0), new Vector34(0, 1, 0), new Vector34(0, 1, 0), new Vector34(0, 0, 1), new Vector34(0, 0, -1)];
        }
        updateMatrices(light, viewportIndex = 0) {
          const camera = this.camera;
          const shadowMatrix = this.matrix;
          const far = light.distance || camera.far;
          if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(_lightPositionWorld);
          _lookTarget.copy(camera.position);
          _lookTarget.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(_lookTarget);
          camera.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
          _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix);
        }
      }
      PointLightShadow.prototype.isPointLightShadow = true;
      class PointLight extends Light {
        constructor(color, intensity, distance = 0, decay = 1) {
          super(color, intensity);
          this.type = "PointLight";
          this.distance = distance;
          this.decay = decay;
          this.shadow = new PointLightShadow();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(power) {
          this.intensity = power / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.decay = source.decay;
          this.shadow = source.shadow.clone();
          return this;
        }
      }
      PointLight.prototype.isPointLight = true;
      class DirectionalLightShadow extends LightShadow {
        constructor() {
          super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
        }
      }
      DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
      class DirectionalLight extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "DirectionalLight";
          this.position.copy(Object3D2.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D2();
          this.shadow = new DirectionalLightShadow();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      }
      DirectionalLight.prototype.isDirectionalLight = true;
      class AmbientLight extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "AmbientLight";
        }
      }
      AmbientLight.prototype.isAmbientLight = true;
      class RectAreaLight extends Light {
        constructor(color, intensity, width = 10, height = 10) {
          super(color, intensity);
          this.type = "RectAreaLight";
          this.width = width;
          this.height = height;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(power) {
          this.intensity = power / (this.width * this.height * Math.PI);
        }
        copy(source) {
          super.copy(source);
          this.width = source.width;
          this.height = source.height;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.width = this.width;
          data.object.height = this.height;
          return data;
        }
      }
      RectAreaLight.prototype.isRectAreaLight = true;
      class SphericalHarmonics3 {
        constructor() {
          this.coefficients = [];
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients.push(new Vector34());
          }
        }
        set(coefficients) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].copy(coefficients[i2]);
          }
          return this;
        }
        zero() {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].set(0, 0, 0);
          }
          return this;
        }
        getAt(normal, target) {
          const x2 = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.282095);
          target.addScaledVector(coeff[1], 0.488603 * y);
          target.addScaledVector(coeff[2], 0.488603 * z);
          target.addScaledVector(coeff[3], 0.488603 * x2);
          target.addScaledVector(coeff[4], 1.092548 * (x2 * y));
          target.addScaledVector(coeff[5], 1.092548 * (y * z));
          target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
          target.addScaledVector(coeff[7], 1.092548 * (x2 * z));
          target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y * y));
          return target;
        }
        getIrradianceAt(normal, target) {
          const x2 = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.886227);
          target.addScaledVector(coeff[1], 2 * 0.511664 * y);
          target.addScaledVector(coeff[2], 2 * 0.511664 * z);
          target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
          target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y);
          target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
          target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
          target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z);
          target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y * y));
          return target;
        }
        add(sh) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].add(sh.coefficients[i2]);
          }
          return this;
        }
        addScaledSH(sh, s3) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].addScaledVector(sh.coefficients[i2], s3);
          }
          return this;
        }
        scale(s3) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].multiplyScalar(s3);
          }
          return this;
        }
        lerp(sh, alpha) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
          }
          return this;
        }
        equals(sh) {
          for (let i2 = 0; i2 < 9; i2++) {
            if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
              return false;
            }
          }
          return true;
        }
        copy(sh) {
          return this.set(sh.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(array, offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].fromArray(array, offset + i2 * 3);
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].toArray(array, offset + i2 * 3);
          }
          return array;
        }
        static getBasisAt(normal, shBasis) {
          const x2 = normal.x, y = normal.y, z = normal.z;
          shBasis[0] = 0.282095;
          shBasis[1] = 0.488603 * y;
          shBasis[2] = 0.488603 * z;
          shBasis[3] = 0.488603 * x2;
          shBasis[4] = 1.092548 * x2 * y;
          shBasis[5] = 1.092548 * y * z;
          shBasis[6] = 0.315392 * (3 * z * z - 1);
          shBasis[7] = 1.092548 * x2 * z;
          shBasis[8] = 0.546274 * (x2 * x2 - y * y);
        }
      }
      SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
      class LightProbe extends Light {
        constructor(sh = new SphericalHarmonics3(), intensity = 1) {
          super(void 0, intensity);
          this.sh = sh;
        }
        copy(source) {
          super.copy(source);
          this.sh.copy(source.sh);
          return this;
        }
        fromJSON(json) {
          this.intensity = json.intensity;
          this.sh.fromArray(json.sh);
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.sh = this.sh.toArray();
          return data;
        }
      }
      LightProbe.prototype.isLightProbe = true;
      class MaterialLoader extends Loader {
        constructor(manager) {
          super(manager);
          this.textures = {};
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e2) {
              if (onError) {
                onError(e2);
              } else {
                console.error(e2);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const textures = this.textures;
          function getTexture(name) {
            if (textures[name] === void 0) {
              console.warn("THREE.MaterialLoader: Undefined texture", name);
            }
            return textures[name];
          }
          const material2 = new Materials[json.type]();
          if (json.uuid !== void 0)
            material2.uuid = json.uuid;
          if (json.name !== void 0)
            material2.name = json.name;
          if (json.color !== void 0 && material2.color !== void 0)
            material2.color.setHex(json.color);
          if (json.roughness !== void 0)
            material2.roughness = json.roughness;
          if (json.metalness !== void 0)
            material2.metalness = json.metalness;
          if (json.sheen !== void 0)
            material2.sheen = json.sheen;
          if (json.sheenColor !== void 0)
            material2.sheenColor = new Color().setHex(json.sheenColor);
          if (json.sheenRoughness !== void 0)
            material2.sheenRoughness = json.sheenRoughness;
          if (json.emissive !== void 0 && material2.emissive !== void 0)
            material2.emissive.setHex(json.emissive);
          if (json.specular !== void 0 && material2.specular !== void 0)
            material2.specular.setHex(json.specular);
          if (json.specularIntensity !== void 0)
            material2.specularIntensity = json.specularIntensity;
          if (json.specularColor !== void 0 && material2.specularColor !== void 0)
            material2.specularColor.setHex(json.specularColor);
          if (json.shininess !== void 0)
            material2.shininess = json.shininess;
          if (json.clearcoat !== void 0)
            material2.clearcoat = json.clearcoat;
          if (json.clearcoatRoughness !== void 0)
            material2.clearcoatRoughness = json.clearcoatRoughness;
          if (json.transmission !== void 0)
            material2.transmission = json.transmission;
          if (json.thickness !== void 0)
            material2.thickness = json.thickness;
          if (json.attenuationDistance !== void 0)
            material2.attenuationDistance = json.attenuationDistance;
          if (json.attenuationColor !== void 0 && material2.attenuationColor !== void 0)
            material2.attenuationColor.setHex(json.attenuationColor);
          if (json.fog !== void 0)
            material2.fog = json.fog;
          if (json.flatShading !== void 0)
            material2.flatShading = json.flatShading;
          if (json.blending !== void 0)
            material2.blending = json.blending;
          if (json.combine !== void 0)
            material2.combine = json.combine;
          if (json.side !== void 0)
            material2.side = json.side;
          if (json.shadowSide !== void 0)
            material2.shadowSide = json.shadowSide;
          if (json.opacity !== void 0)
            material2.opacity = json.opacity;
          if (json.format !== void 0)
            material2.format = json.format;
          if (json.transparent !== void 0)
            material2.transparent = json.transparent;
          if (json.alphaTest !== void 0)
            material2.alphaTest = json.alphaTest;
          if (json.depthTest !== void 0)
            material2.depthTest = json.depthTest;
          if (json.depthWrite !== void 0)
            material2.depthWrite = json.depthWrite;
          if (json.colorWrite !== void 0)
            material2.colorWrite = json.colorWrite;
          if (json.stencilWrite !== void 0)
            material2.stencilWrite = json.stencilWrite;
          if (json.stencilWriteMask !== void 0)
            material2.stencilWriteMask = json.stencilWriteMask;
          if (json.stencilFunc !== void 0)
            material2.stencilFunc = json.stencilFunc;
          if (json.stencilRef !== void 0)
            material2.stencilRef = json.stencilRef;
          if (json.stencilFuncMask !== void 0)
            material2.stencilFuncMask = json.stencilFuncMask;
          if (json.stencilFail !== void 0)
            material2.stencilFail = json.stencilFail;
          if (json.stencilZFail !== void 0)
            material2.stencilZFail = json.stencilZFail;
          if (json.stencilZPass !== void 0)
            material2.stencilZPass = json.stencilZPass;
          if (json.wireframe !== void 0)
            material2.wireframe = json.wireframe;
          if (json.wireframeLinewidth !== void 0)
            material2.wireframeLinewidth = json.wireframeLinewidth;
          if (json.wireframeLinecap !== void 0)
            material2.wireframeLinecap = json.wireframeLinecap;
          if (json.wireframeLinejoin !== void 0)
            material2.wireframeLinejoin = json.wireframeLinejoin;
          if (json.rotation !== void 0)
            material2.rotation = json.rotation;
          if (json.linewidth !== 1)
            material2.linewidth = json.linewidth;
          if (json.dashSize !== void 0)
            material2.dashSize = json.dashSize;
          if (json.gapSize !== void 0)
            material2.gapSize = json.gapSize;
          if (json.scale !== void 0)
            material2.scale = json.scale;
          if (json.polygonOffset !== void 0)
            material2.polygonOffset = json.polygonOffset;
          if (json.polygonOffsetFactor !== void 0)
            material2.polygonOffsetFactor = json.polygonOffsetFactor;
          if (json.polygonOffsetUnits !== void 0)
            material2.polygonOffsetUnits = json.polygonOffsetUnits;
          if (json.dithering !== void 0)
            material2.dithering = json.dithering;
          if (json.alphaToCoverage !== void 0)
            material2.alphaToCoverage = json.alphaToCoverage;
          if (json.premultipliedAlpha !== void 0)
            material2.premultipliedAlpha = json.premultipliedAlpha;
          if (json.visible !== void 0)
            material2.visible = json.visible;
          if (json.toneMapped !== void 0)
            material2.toneMapped = json.toneMapped;
          if (json.userData !== void 0)
            material2.userData = json.userData;
          if (json.vertexColors !== void 0) {
            if (typeof json.vertexColors === "number") {
              material2.vertexColors = json.vertexColors > 0 ? true : false;
            } else {
              material2.vertexColors = json.vertexColors;
            }
          }
          if (json.uniforms !== void 0) {
            for (const name in json.uniforms) {
              const uniform = json.uniforms[name];
              material2.uniforms[name] = {};
              switch (uniform.type) {
                case "t":
                  material2.uniforms[name].value = getTexture(uniform.value);
                  break;
                case "c":
                  material2.uniforms[name].value = new Color().setHex(uniform.value);
                  break;
                case "v2":
                  material2.uniforms[name].value = new Vector2().fromArray(uniform.value);
                  break;
                case "v3":
                  material2.uniforms[name].value = new Vector34().fromArray(uniform.value);
                  break;
                case "v4":
                  material2.uniforms[name].value = new Vector4().fromArray(uniform.value);
                  break;
                case "m3":
                  material2.uniforms[name].value = new Matrix32().fromArray(uniform.value);
                  break;
                case "m4":
                  material2.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                  break;
                default:
                  material2.uniforms[name].value = uniform.value;
              }
            }
          }
          if (json.defines !== void 0)
            material2.defines = json.defines;
          if (json.vertexShader !== void 0)
            material2.vertexShader = json.vertexShader;
          if (json.fragmentShader !== void 0)
            material2.fragmentShader = json.fragmentShader;
          if (json.extensions !== void 0) {
            for (const key in json.extensions) {
              material2.extensions[key] = json.extensions[key];
            }
          }
          if (json.shading !== void 0)
            material2.flatShading = json.shading === 1;
          if (json.size !== void 0)
            material2.size = json.size;
          if (json.sizeAttenuation !== void 0)
            material2.sizeAttenuation = json.sizeAttenuation;
          if (json.map !== void 0)
            material2.map = getTexture(json.map);
          if (json.matcap !== void 0)
            material2.matcap = getTexture(json.matcap);
          if (json.alphaMap !== void 0)
            material2.alphaMap = getTexture(json.alphaMap);
          if (json.bumpMap !== void 0)
            material2.bumpMap = getTexture(json.bumpMap);
          if (json.bumpScale !== void 0)
            material2.bumpScale = json.bumpScale;
          if (json.normalMap !== void 0)
            material2.normalMap = getTexture(json.normalMap);
          if (json.normalMapType !== void 0)
            material2.normalMapType = json.normalMapType;
          if (json.normalScale !== void 0) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
              normalScale = [normalScale, normalScale];
            }
            material2.normalScale = new Vector2().fromArray(normalScale);
          }
          if (json.displacementMap !== void 0)
            material2.displacementMap = getTexture(json.displacementMap);
          if (json.displacementScale !== void 0)
            material2.displacementScale = json.displacementScale;
          if (json.displacementBias !== void 0)
            material2.displacementBias = json.displacementBias;
          if (json.roughnessMap !== void 0)
            material2.roughnessMap = getTexture(json.roughnessMap);
          if (json.metalnessMap !== void 0)
            material2.metalnessMap = getTexture(json.metalnessMap);
          if (json.emissiveMap !== void 0)
            material2.emissiveMap = getTexture(json.emissiveMap);
          if (json.emissiveIntensity !== void 0)
            material2.emissiveIntensity = json.emissiveIntensity;
          if (json.specularMap !== void 0)
            material2.specularMap = getTexture(json.specularMap);
          if (json.specularIntensityMap !== void 0)
            material2.specularIntensityMap = getTexture(json.specularIntensityMap);
          if (json.specularColorMap !== void 0)
            material2.specularColorMap = getTexture(json.specularColorMap);
          if (json.envMap !== void 0)
            material2.envMap = getTexture(json.envMap);
          if (json.envMapIntensity !== void 0)
            material2.envMapIntensity = json.envMapIntensity;
          if (json.reflectivity !== void 0)
            material2.reflectivity = json.reflectivity;
          if (json.refractionRatio !== void 0)
            material2.refractionRatio = json.refractionRatio;
          if (json.lightMap !== void 0)
            material2.lightMap = getTexture(json.lightMap);
          if (json.lightMapIntensity !== void 0)
            material2.lightMapIntensity = json.lightMapIntensity;
          if (json.aoMap !== void 0)
            material2.aoMap = getTexture(json.aoMap);
          if (json.aoMapIntensity !== void 0)
            material2.aoMapIntensity = json.aoMapIntensity;
          if (json.gradientMap !== void 0)
            material2.gradientMap = getTexture(json.gradientMap);
          if (json.clearcoatMap !== void 0)
            material2.clearcoatMap = getTexture(json.clearcoatMap);
          if (json.clearcoatRoughnessMap !== void 0)
            material2.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
          if (json.clearcoatNormalMap !== void 0)
            material2.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
          if (json.clearcoatNormalScale !== void 0)
            material2.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
          if (json.transmissionMap !== void 0)
            material2.transmissionMap = getTexture(json.transmissionMap);
          if (json.thicknessMap !== void 0)
            material2.thicknessMap = getTexture(json.thicknessMap);
          if (json.sheenColorMap !== void 0)
            material2.sheenColorMap = getTexture(json.sheenColorMap);
          if (json.sheenRoughnessMap !== void 0)
            material2.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
          return material2;
        }
        setTextures(value) {
          this.textures = value;
          return this;
        }
      }
      class LoaderUtils {
        static decodeText(array) {
          if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
          }
          let s3 = "";
          for (let i2 = 0, il = array.length; i2 < il; i2++) {
            s3 += String.fromCharCode(array[i2]);
          }
          try {
            return decodeURIComponent(escape(s3));
          } catch (e2) {
            return s3;
          }
        }
        static extractUrlBase(url) {
          const index = url.lastIndexOf("/");
          if (index === -1)
            return "./";
          return url.substr(0, index + 1);
        }
        static resolveURL(url, path) {
          if (typeof url !== "string" || url === "")
            return "";
          if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
            path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
          }
          if (/^(https?:)?\/\//i.test(url))
            return url;
          if (/^data:.*,.*$/i.test(url))
            return url;
          if (/^blob:.*$/i.test(url))
            return url;
          return path + url;
        }
      }
      class InstancedBufferGeometry extends BufferGeometry3 {
        constructor() {
          super();
          this.type = "InstancedBufferGeometry";
          this.instanceCount = Infinity;
        }
        copy(source) {
          super.copy(source);
          this.instanceCount = source.instanceCount;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const data = super.toJSON(this);
          data.instanceCount = this.instanceCount;
          data.isInstancedBufferGeometry = true;
          return data;
        }
      }
      InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
      class BufferGeometryLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e2) {
              if (onError) {
                onError(e2);
              } else {
                console.error(e2);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const interleavedBufferMap = {};
          const arrayBufferMap = {};
          function getInterleavedBuffer(json2, uuid) {
            if (interleavedBufferMap[uuid] !== void 0)
              return interleavedBufferMap[uuid];
            const interleavedBuffers = json2.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
            const array = getTypedArray(interleavedBuffer.type, buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
          }
          function getArrayBuffer(json2, uuid) {
            if (arrayBufferMap[uuid] !== void 0)
              return arrayBufferMap[uuid];
            const arrayBuffers = json2.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
          }
          const geometry2 = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry3();
          const index = json.data.index;
          if (index !== void 0) {
            const typedArray = getTypedArray(index.type, index.array);
            geometry2.setIndex(new BufferAttribute(typedArray, 1));
          }
          const attributes = json.data.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
              const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
              bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
              const typedArray = getTypedArray(attribute.type, attribute.array);
              const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
              bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            if (attribute.usage !== void 0)
              bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== void 0) {
              bufferAttribute.updateRange.offset = attribute.updateRange.offset;
              bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry2.setAttribute(key, bufferAttribute);
          }
          const morphAttributes = json.data.morphAttributes;
          if (morphAttributes) {
            for (const key in morphAttributes) {
              const attributeArray = morphAttributes[key];
              const array = [];
              for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
                const attribute = attributeArray[i2];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                  const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                  const typedArray = getTypedArray(attribute.type, attribute.array);
                  bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== void 0)
                  bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
              }
              geometry2.morphAttributes[key] = array;
            }
          }
          const morphTargetsRelative = json.data.morphTargetsRelative;
          if (morphTargetsRelative) {
            geometry2.morphTargetsRelative = true;
          }
          const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
          if (groups !== void 0) {
            for (let i2 = 0, n = groups.length; i2 !== n; ++i2) {
              const group = groups[i2];
              geometry2.addGroup(group.start, group.count, group.materialIndex);
            }
          }
          const boundingSphere = json.data.boundingSphere;
          if (boundingSphere !== void 0) {
            const center = new Vector34();
            if (boundingSphere.center !== void 0) {
              center.fromArray(boundingSphere.center);
            }
            geometry2.boundingSphere = new Sphere(center, boundingSphere.radius);
          }
          if (json.name)
            geometry2.name = json.name;
          if (json.userData)
            geometry2.userData = json.userData;
          return geometry2;
        }
      }
      class ObjectLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            let json = null;
            try {
              json = JSON.parse(text);
            } catch (error2) {
              if (onError !== void 0)
                onError(error2);
              console.error("THREE:ObjectLoader: Can't parse " + url + ".", error2.message);
              return;
            }
            const metadata = json.metadata;
            if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
              console.error("THREE.ObjectLoader: Can't load " + url);
              return;
            }
            scope.parse(json, onLoad);
          }, onProgress, onError);
        }
        async loadAsync(url, onProgress) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          const text = await loader.loadAsync(url, onProgress);
          const json = JSON.parse(text);
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            throw new Error("THREE.ObjectLoader: Can't load " + url);
          }
          return await scope.parseAsync(json);
        }
        parse(json, onLoad) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = this.parseImages(json.images, function() {
            if (onLoad !== void 0)
              onLoad(object);
          });
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          if (onLoad !== void 0) {
            let hasImages = false;
            for (const uuid in images) {
              if (images[uuid] instanceof HTMLImageElement) {
                hasImages = true;
                break;
              }
            }
            if (hasImages === false)
              onLoad(object);
          }
          return object;
        }
        async parseAsync(json) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = await this.parseImagesAsync(json.images);
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          return object;
        }
        parseShapes(json) {
          const shapes = {};
          if (json !== void 0) {
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const shape = new Shape().fromJSON(json[i2]);
              shapes[shape.uuid] = shape;
            }
          }
          return shapes;
        }
        parseSkeletons(json, object) {
          const skeletons = {};
          const bones = {};
          object.traverse(function(child) {
            if (child.isBone)
              bones[child.uuid] = child;
          });
          if (json !== void 0) {
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const skeleton = new Skeleton().fromJSON(json[i2], bones);
              skeletons[skeleton.uuid] = skeleton;
            }
          }
          return skeletons;
        }
        parseGeometries(json, shapes) {
          const geometries = {};
          if (json !== void 0) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              let geometry2;
              const data = json[i2];
              switch (data.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  geometry2 = bufferGeometryLoader.parse(data);
                  break;
                case "Geometry":
                  console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                  break;
                default:
                  if (data.type in Geometries) {
                    geometry2 = Geometries[data.type].fromJSON(data, shapes);
                  } else {
                    console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                  }
              }
              geometry2.uuid = data.uuid;
              if (data.name !== void 0)
                geometry2.name = data.name;
              if (geometry2.isBufferGeometry === true && data.userData !== void 0)
                geometry2.userData = data.userData;
              geometries[data.uuid] = geometry2;
            }
          }
          return geometries;
        }
        parseMaterials(json, textures) {
          const cache = {};
          const materials = {};
          if (json !== void 0) {
            const loader = new MaterialLoader();
            loader.setTextures(textures);
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const data = json[i2];
              if (data.type === "MultiMaterial") {
                const array = [];
                for (let j = 0; j < data.materials.length; j++) {
                  const material2 = data.materials[j];
                  if (cache[material2.uuid] === void 0) {
                    cache[material2.uuid] = loader.parse(material2);
                  }
                  array.push(cache[material2.uuid]);
                }
                materials[data.uuid] = array;
              } else {
                if (cache[data.uuid] === void 0) {
                  cache[data.uuid] = loader.parse(data);
                }
                materials[data.uuid] = cache[data.uuid];
              }
            }
          }
          return materials;
        }
        parseAnimations(json) {
          const animations = {};
          if (json !== void 0) {
            for (let i2 = 0; i2 < json.length; i2++) {
              const data = json[i2];
              const clip = AnimationClip.parse(data);
              animations[clip.uuid] = clip;
            }
          }
          return animations;
        }
        parseImages(json, onLoad) {
          const scope = this;
          const images = {};
          let loader;
          function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
              scope.manager.itemEnd(url);
            }, void 0, function() {
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            });
          }
          function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return loadImage(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            const manager = new LoadingManager(onLoad);
            loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i2 = 0, il = json.length; i2 < il; i2++) {
              const image = json[i2];
              const url = image.url;
              if (Array.isArray(url)) {
                images[image.uuid] = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      images[image.uuid].push(deserializedImage);
                    } else {
                      images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
              } else {
                const deserializedImage = deserializeImage(image.url);
                if (deserializedImage !== null) {
                  images[image.uuid] = deserializedImage;
                }
              }
            }
          }
          return images;
        }
        async parseImagesAsync(json) {
          const scope = this;
          const images = {};
          let loader;
          async function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return await loader.loadAsync(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i2 = 0, il = json.length; i2 < il; i2++) {
              const image = json[i2];
              const url = image.url;
              if (Array.isArray(url)) {
                images[image.uuid] = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = await deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      images[image.uuid].push(deserializedImage);
                    } else {
                      images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
              } else {
                const deserializedImage = await deserializeImage(image.url);
                if (deserializedImage !== null) {
                  images[image.uuid] = deserializedImage;
                }
              }
            }
          }
          return images;
        }
        parseTextures(json, images) {
          function parseConstant(value, type) {
            if (typeof value === "number")
              return value;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
            return type[value];
          }
          const textures = {};
          if (json !== void 0) {
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const data = json[i2];
              if (data.image === void 0) {
                console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
              }
              if (images[data.image] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined image", data.image);
              }
              let texture;
              const image = images[data.image];
              if (Array.isArray(image)) {
                texture = new CubeTexture(image);
                if (image.length === 6)
                  texture.needsUpdate = true;
              } else {
                if (image && image.data) {
                  texture = new DataTexture(image.data, image.width, image.height);
                } else {
                  texture = new Texture(image);
                }
                if (image)
                  texture.needsUpdate = true;
              }
              texture.uuid = data.uuid;
              if (data.name !== void 0)
                texture.name = data.name;
              if (data.mapping !== void 0)
                texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
              if (data.offset !== void 0)
                texture.offset.fromArray(data.offset);
              if (data.repeat !== void 0)
                texture.repeat.fromArray(data.repeat);
              if (data.center !== void 0)
                texture.center.fromArray(data.center);
              if (data.rotation !== void 0)
                texture.rotation = data.rotation;
              if (data.wrap !== void 0) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
              }
              if (data.format !== void 0)
                texture.format = data.format;
              if (data.type !== void 0)
                texture.type = data.type;
              if (data.encoding !== void 0)
                texture.encoding = data.encoding;
              if (data.minFilter !== void 0)
                texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
              if (data.magFilter !== void 0)
                texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
              if (data.anisotropy !== void 0)
                texture.anisotropy = data.anisotropy;
              if (data.flipY !== void 0)
                texture.flipY = data.flipY;
              if (data.premultiplyAlpha !== void 0)
                texture.premultiplyAlpha = data.premultiplyAlpha;
              if (data.unpackAlignment !== void 0)
                texture.unpackAlignment = data.unpackAlignment;
              if (data.userData !== void 0)
                texture.userData = data.userData;
              textures[data.uuid] = texture;
            }
          }
          return textures;
        }
        parseObject(data, geometries, materials, textures, animations) {
          let object;
          function getGeometry(name) {
            if (geometries[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined geometry", name);
            }
            return geometries[name];
          }
          function getMaterial(name) {
            if (name === void 0)
              return void 0;
            if (Array.isArray(name)) {
              const array = [];
              for (let i2 = 0, l = name.length; i2 < l; i2++) {
                const uuid = name[i2];
                if (materials[uuid] === void 0) {
                  console.warn("THREE.ObjectLoader: Undefined material", uuid);
                }
                array.push(materials[uuid]);
              }
              return array;
            }
            if (materials[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", name);
            }
            return materials[name];
          }
          function getTexture(uuid) {
            if (textures[uuid] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined texture", uuid);
            }
            return textures[uuid];
          }
          let geometry2, material2;
          switch (data.type) {
            case "Scene":
              object = new Scene();
              if (data.background !== void 0) {
                if (Number.isInteger(data.background)) {
                  object.background = new Color(data.background);
                } else {
                  object.background = getTexture(data.background);
                }
              }
              if (data.environment !== void 0) {
                object.environment = getTexture(data.environment);
              }
              if (data.fog !== void 0) {
                if (data.fog.type === "Fog") {
                  object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                } else if (data.fog.type === "FogExp2") {
                  object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
              }
              break;
            case "PerspectiveCamera":
              object = new PerspectiveCamera2(data.fov, data.aspect, data.near, data.far);
              if (data.focus !== void 0)
                object.focus = data.focus;
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.filmGauge !== void 0)
                object.filmGauge = data.filmGauge;
              if (data.filmOffset !== void 0)
                object.filmOffset = data.filmOffset;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "OrthographicCamera":
              object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "AmbientLight":
              object = new AmbientLight(data.color, data.intensity);
              break;
            case "DirectionalLight":
              object = new DirectionalLight(data.color, data.intensity);
              break;
            case "PointLight":
              object = new PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case "RectAreaLight":
              object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
              break;
            case "SpotLight":
              object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
              break;
            case "HemisphereLight":
              object = new HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case "LightProbe":
              object = new LightProbe().fromJSON(data);
              break;
            case "SkinnedMesh":
              geometry2 = getGeometry(data.geometry);
              material2 = getMaterial(data.material);
              object = new SkinnedMesh(geometry2, material2);
              if (data.bindMode !== void 0)
                object.bindMode = data.bindMode;
              if (data.bindMatrix !== void 0)
                object.bindMatrix.fromArray(data.bindMatrix);
              if (data.skeleton !== void 0)
                object.skeleton = data.skeleton;
              break;
            case "Mesh":
              geometry2 = getGeometry(data.geometry);
              material2 = getMaterial(data.material);
              object = new Mesh3(geometry2, material2);
              break;
            case "InstancedMesh":
              geometry2 = getGeometry(data.geometry);
              material2 = getMaterial(data.material);
              const count = data.count;
              const instanceMatrix = data.instanceMatrix;
              const instanceColor = data.instanceColor;
              object = new InstancedMesh(geometry2, material2, count);
              object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
              if (instanceColor !== void 0)
                object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
              break;
            case "LOD":
              object = new LOD();
              break;
            case "Line":
              object = new Line2(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineLoop":
              object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineSegments":
              object = new LineSegments2(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "PointCloud":
            case "Points":
              object = new Points(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "Sprite":
              object = new Sprite(getMaterial(data.material));
              break;
            case "Group":
              object = new Group();
              break;
            case "Bone":
              object = new Bone();
              break;
            default:
              object = new Object3D2();
          }
          object.uuid = data.uuid;
          if (data.name !== void 0)
            object.name = data.name;
          if (data.matrix !== void 0) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== void 0)
              object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate)
              object.matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== void 0)
              object.position.fromArray(data.position);
            if (data.rotation !== void 0)
              object.rotation.fromArray(data.rotation);
            if (data.quaternion !== void 0)
              object.quaternion.fromArray(data.quaternion);
            if (data.scale !== void 0)
              object.scale.fromArray(data.scale);
          }
          if (data.castShadow !== void 0)
            object.castShadow = data.castShadow;
          if (data.receiveShadow !== void 0)
            object.receiveShadow = data.receiveShadow;
          if (data.shadow) {
            if (data.shadow.bias !== void 0)
              object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== void 0)
              object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== void 0)
              object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== void 0)
              object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== void 0)
              object.shadow.camera = this.parseObject(data.shadow.camera);
          }
          if (data.visible !== void 0)
            object.visible = data.visible;
          if (data.frustumCulled !== void 0)
            object.frustumCulled = data.frustumCulled;
          if (data.renderOrder !== void 0)
            object.renderOrder = data.renderOrder;
          if (data.userData !== void 0)
            object.userData = data.userData;
          if (data.layers !== void 0)
            object.layers.mask = data.layers;
          if (data.children !== void 0) {
            const children = data.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              object.add(this.parseObject(children[i2], geometries, materials, textures, animations));
            }
          }
          if (data.animations !== void 0) {
            const objectAnimations = data.animations;
            for (let i2 = 0; i2 < objectAnimations.length; i2++) {
              const uuid = objectAnimations[i2];
              object.animations.push(animations[uuid]);
            }
          }
          if (data.type === "LOD") {
            if (data.autoUpdate !== void 0)
              object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for (let l = 0; l < levels.length; l++) {
              const level = levels[l];
              const child = object.getObjectByProperty("uuid", level.object);
              if (child !== void 0) {
                object.addLevel(child, level.distance);
              }
            }
          }
          return object;
        }
        bindSkeletons(object, skeletons) {
          if (Object.keys(skeletons).length === 0)
            return;
          object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
              const skeleton = skeletons[child.skeleton];
              if (skeleton === void 0) {
                console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
              } else {
                child.bind(skeleton, child.bindMatrix);
              }
            }
          });
        }
        setTexturePath(value) {
          console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
          return this.setResourcePath(value);
        }
      }
      const TEXTURE_MAPPING = {
        UVMapping,
        CubeReflectionMapping,
        CubeRefractionMapping,
        EquirectangularReflectionMapping,
        EquirectangularRefractionMapping,
        CubeUVReflectionMapping,
        CubeUVRefractionMapping
      };
      const TEXTURE_WRAPPING = {
        RepeatWrapping,
        ClampToEdgeWrapping,
        MirroredRepeatWrapping
      };
      const TEXTURE_FILTER = {
        NearestFilter,
        NearestMipmapNearestFilter,
        NearestMipmapLinearFilter,
        LinearFilter,
        LinearMipmapNearestFilter,
        LinearMipmapLinearFilter
      };
      class ImageBitmapLoader extends Loader {
        constructor(manager) {
          super(manager);
          if (typeof createImageBitmap === "undefined") {
            console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
          }
          if (typeof fetch === "undefined") {
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          }
          this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(options2) {
          this.options = options2;
          return this;
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const fetchOptions = {};
          fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
          fetchOptions.headers = this.requestHeader;
          fetch(url, fetchOptions).then(function(res) {
            return res.blob();
          }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad)
              onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function(e2) {
            if (onError)
              onError(e2);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
          scope.manager.itemStart(url);
        }
      }
      ImageBitmapLoader.prototype.isImageBitmapLoader = true;
      let _context;
      const AudioContext = {
        getContext: function() {
          if (_context === void 0) {
            _context = new (window.AudioContext || window.webkitAudioContext)();
          }
          return _context;
        },
        setContext: function(value) {
          _context = value;
        }
      };
      class AudioLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(buffer) {
            try {
              const bufferCopy = buffer.slice(0);
              const context = AudioContext.getContext();
              context.decodeAudioData(bufferCopy, function(audioBuffer) {
                onLoad(audioBuffer);
              });
            } catch (e2) {
              if (onError) {
                onError(e2);
              } else {
                console.error(e2);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
      }
      class HemisphereLightProbe extends LightProbe {
        constructor(skyColor, groundColor, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(skyColor);
          const color2 = new Color().set(groundColor);
          const sky = new Vector34(color1.r, color1.g, color1.b);
          const ground = new Vector34(color2.r, color2.g, color2.b);
          const c0 = Math.sqrt(Math.PI);
          const c1 = c0 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
          this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
        }
      }
      HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
      class AmbientLightProbe extends LightProbe {
        constructor(color, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(color);
          this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      AmbientLightProbe.prototype.isAmbientLightProbe = true;
      const _eyeRight = /* @__PURE__ */ new Matrix4();
      const _eyeLeft = /* @__PURE__ */ new Matrix4();
      const _projectionMatrix = /* @__PURE__ */ new Matrix4();
      class StereoCamera {
        constructor() {
          this.type = "StereoCamera";
          this.aspect = 1;
          this.eyeSep = 0.064;
          this.cameraL = new PerspectiveCamera2();
          this.cameraL.layers.enable(1);
          this.cameraL.matrixAutoUpdate = false;
          this.cameraR = new PerspectiveCamera2();
          this.cameraR.layers.enable(2);
          this.cameraR.matrixAutoUpdate = false;
          this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          };
        }
        update(camera) {
          const cache = this._cache;
          const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
          if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            _projectionMatrix.copy(camera.projectionMatrix);
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(_projectionMatrix);
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(_projectionMatrix);
          }
          this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
          this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
        }
      }
      class Clock {
        constructor(autoStart = true) {
          this.autoStart = autoStart;
          this.startTime = 0;
          this.oldTime = 0;
          this.elapsedTime = 0;
          this.running = false;
        }
        start() {
          this.startTime = now2();
          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;
        }
        stop() {
          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;
        }
        getElapsedTime() {
          this.getDelta();
          return this.elapsedTime;
        }
        getDelta() {
          let diff = 0;
          if (this.autoStart && !this.running) {
            this.start();
            return 0;
          }
          if (this.running) {
            const newTime = now2();
            diff = (newTime - this.oldTime) / 1e3;
            this.oldTime = newTime;
            this.elapsedTime += diff;
          }
          return diff;
        }
      }
      function now2() {
        return (typeof performance === "undefined" ? Date : performance).now();
      }
      const _position$1 = /* @__PURE__ */ new Vector34();
      const _quaternion$1 = /* @__PURE__ */ new Quaternion();
      const _scale$1 = /* @__PURE__ */ new Vector34();
      const _orientation$1 = /* @__PURE__ */ new Vector34();
      class AudioListener extends Object3D2 {
        constructor() {
          super();
          this.type = "AudioListener";
          this.context = AudioContext.getContext();
          this.gain = this.context.createGain();
          this.gain.connect(this.context.destination);
          this.filter = null;
          this.timeDelta = 0;
          this._clock = new Clock();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
          }
          return this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(value) {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
          } else {
            this.gain.disconnect(this.context.destination);
          }
          this.filter = value;
          this.gain.connect(this.filter);
          this.filter.connect(this.context.destination);
          return this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          const listener = this.context.listener;
          const up = this.up;
          this.timeDelta = this._clock.getDelta();
          this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
          _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
          if (listener.positionX) {
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
          } else {
            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
          }
        }
      }
      class Audio extends Object3D2 {
        constructor(listener) {
          super();
          this.type = "Audio";
          this.listener = listener;
          this.context = listener.context;
          this.gain = this.context.createGain();
          this.gain.connect(listener.getInput());
          this.autoplay = false;
          this.buffer = null;
          this.detune = 0;
          this.loop = false;
          this.loopStart = 0;
          this.loopEnd = 0;
          this.offset = 0;
          this.duration = void 0;
          this.playbackRate = 1;
          this.isPlaying = false;
          this.hasPlaybackControl = true;
          this.source = null;
          this.sourceType = "empty";
          this._startedAt = 0;
          this._progress = 0;
          this._connected = false;
          this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(audioNode) {
          this.hasPlaybackControl = false;
          this.sourceType = "audioNode";
          this.source = audioNode;
          this.connect();
          return this;
        }
        setMediaElementSource(mediaElement) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaNode";
          this.source = this.context.createMediaElementSource(mediaElement);
          this.connect();
          return this;
        }
        setMediaStreamSource(mediaStream) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaStreamNode";
          this.source = this.context.createMediaStreamSource(mediaStream);
          this.connect();
          return this;
        }
        setBuffer(audioBuffer) {
          this.buffer = audioBuffer;
          this.sourceType = "buffer";
          if (this.autoplay)
            this.play();
          return this;
        }
        play(delay = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + delay;
          const source = this.context.createBufferSource();
          source.buffer = this.buffer;
          source.loop = this.loop;
          source.loopStart = this.loopStart;
          source.loopEnd = this.loopEnd;
          source.onended = this.onEnded.bind(this);
          source.start(this._startedAt, this._progress + this.offset, this.duration);
          this.isPlaying = true;
          this.source = source;
          this.setDetune(this.detune);
          this.setPlaybackRate(this.playbackRate);
          return this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) {
              this._progress = this._progress % (this.duration || this.buffer.duration);
            }
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
          }
          return this;
        }
        stop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._progress = 0;
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
          return this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
              this.filters[i2 - 1].connect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else {
            this.source.connect(this.getOutput());
          }
          this._connected = true;
          return this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
              this.filters[i2 - 1].disconnect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else {
            this.source.disconnect(this.getOutput());
          }
          this._connected = false;
          return this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(value) {
          if (!value)
            value = [];
          if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
          } else {
            this.filters = value.slice();
          }
          return this;
        }
        setDetune(value) {
          this.detune = value;
          if (this.source.detune === void 0)
            return;
          if (this.isPlaying === true) {
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
          }
          return this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(filter) {
          return this.setFilters(filter ? [filter] : []);
        }
        setPlaybackRate(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.playbackRate = value;
          if (this.isPlaying === true) {
            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
          }
          return this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
          }
          return this.loop;
        }
        setLoop(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.loop = value;
          if (this.isPlaying === true) {
            this.source.loop = this.loop;
          }
          return this;
        }
        setLoopStart(value) {
          this.loopStart = value;
          return this;
        }
        setLoopEnd(value) {
          this.loopEnd = value;
          return this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
      }
      const _position = /* @__PURE__ */ new Vector34();
      const _quaternion = /* @__PURE__ */ new Quaternion();
      const _scale = /* @__PURE__ */ new Vector34();
      const _orientation = /* @__PURE__ */ new Vector34();
      class PositionalAudio extends Audio {
        constructor(listener) {
          super(listener);
          this.panner = this.context.createPanner();
          this.panner.panningModel = "HRTF";
          this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(value) {
          this.panner.refDistance = value;
          return this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(value) {
          this.panner.rolloffFactor = value;
          return this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(value) {
          this.panner.distanceModel = value;
          return this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(value) {
          this.panner.maxDistance = value;
          return this;
        }
        setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
          this.panner.coneInnerAngle = coneInnerAngle;
          this.panner.coneOuterAngle = coneOuterAngle;
          this.panner.coneOuterGain = coneOuterGain;
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.hasPlaybackControl === true && this.isPlaying === false)
            return;
          this.matrixWorld.decompose(_position, _quaternion, _scale);
          _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
          const panner = this.panner;
          if (panner.positionX) {
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
          } else {
            panner.setPosition(_position.x, _position.y, _position.z);
            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
          }
        }
      }
      class AudioAnalyser {
        constructor(audio, fftSize = 2048) {
          this.analyser = audio.context.createAnalyser();
          this.analyser.fftSize = fftSize;
          this.data = new Uint8Array(this.analyser.frequencyBinCount);
          audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          this.analyser.getByteFrequencyData(this.data);
          return this.data;
        }
        getAverageFrequency() {
          let value = 0;
          const data = this.getFrequencyData();
          for (let i2 = 0; i2 < data.length; i2++) {
            value += data[i2];
          }
          return value / data.length;
        }
      }
      class PropertyMixer {
        constructor(binding, typeName, valueSize) {
          this.binding = binding;
          this.valueSize = valueSize;
          let mixFunction, mixFunctionAdditive, setIdentity;
          switch (typeName) {
            case "quaternion":
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;
              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;
            case "string":
            case "bool":
              mixFunction = this._select;
              mixFunctionAdditive = this._select;
              setIdentity = this._setAdditiveIdentityOther;
              this.buffer = new Array(valueSize * 5);
              break;
            default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;
              this.buffer = new Float64Array(valueSize * 5);
          }
          this._mixBufferRegion = mixFunction;
          this._mixBufferRegionAdditive = mixFunctionAdditive;
          this._setIdentity = setIdentity;
          this._origIndex = 3;
          this._addIndex = 4;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          this.useCount = 0;
          this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
          let currentWeight = this.cumulativeWeight;
          if (currentWeight === 0) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[offset + i2] = buffer[i2];
            }
            currentWeight = weight;
          } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
          }
          this.cumulativeWeight = currentWeight;
        }
        accumulateAdditive(weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
          if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
          }
          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;
        }
        apply(accuIndex) {
          const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
          }
          if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
          }
          for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
            if (buffer[i2] !== buffer[i2 + stride]) {
              binding.setValue(buffer, offset);
              break;
            }
          }
        }
        saveOriginalState() {
          const binding = this.binding;
          const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
          binding.getValue(buffer, originalValueOffset);
          for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
            buffer[i2] = buffer[originalValueOffset + i2 % stride];
          }
          this._setIdentity();
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);
        }
        _setAdditiveIdentityNumeric() {
          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;
          for (let i2 = startIndex; i2 < endIndex; i2++) {
            this.buffer[i2] = 0;
          }
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;
          for (let i2 = 0; i2 < this.valueSize; i2++) {
            this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
          }
        }
        _select(buffer, dstOffset, srcOffset, t2, stride) {
          if (t2 >= 0.5) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[dstOffset + i2] = buffer[srcOffset + i2];
            }
          }
        }
        _slerp(buffer, dstOffset, srcOffset, t2) {
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
          const workOffset = this._workIndex * stride;
          Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
        }
        _lerp(buffer, dstOffset, srcOffset, t2, stride) {
          const s3 = 1 - t2;
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j = dstOffset + i2;
            buffer[j] = buffer[j] * s3 + buffer[srcOffset + i2] * t2;
          }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j = dstOffset + i2;
            buffer[j] = buffer[j] + buffer[srcOffset + i2] * t2;
          }
        }
      }
      const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
      const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
      const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
      const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
      const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
      const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
      const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
      const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
      const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
      const _supportedObjectNames = ["material", "materials", "bones"];
      class Composite {
        constructor(targetGroup, path, optionalParsedPath) {
          const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
          this._targetGroup = targetGroup;
          this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
          this.bind();
          const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
          if (binding !== void 0)
            binding.getValue(array, offset);
        }
        setValue(array, offset) {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].setValue(array, offset);
          }
        }
        bind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].bind();
          }
        }
        unbind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].unbind();
          }
        }
      }
      class PropertyBinding {
        constructor(rootNode, path, parsedPath) {
          this.path = path;
          this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
          this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
          this.rootNode = rootNode;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(root, path, parsedPath) {
          if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding(root, path, parsedPath);
          } else {
            return new PropertyBinding.Composite(root, path, parsedPath);
          }
        }
        static sanitizeNodeName(name) {
          return name.replace(/\s/g, "_").replace(_reservedRe, "");
        }
        static parseTrackName(trackName) {
          const matches = _trackRe.exec(trackName);
          if (!matches) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
          }
          const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
          };
          const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
          if (lastDot !== void 0 && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
              results.nodeName = results.nodeName.substring(0, lastDot);
              results.objectName = objectName;
            }
          }
          if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
          }
          return results;
        }
        static findNode(root, nodeName) {
          if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
          }
          if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== void 0) {
              return bone;
            }
          }
          if (root.children) {
            const searchNodeSubtree = function(children) {
              for (let i2 = 0; i2 < children.length; i2++) {
                const childNode = children[i2];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                  return childNode;
                }
                const result = searchNodeSubtree(childNode.children);
                if (result)
                  return result;
              }
              return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
              return subTreeNode;
            }
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(buffer, offset) {
          buffer[offset] = this.targetObject[this.propertyName];
        }
        _getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
            buffer[offset++] = source[i2];
          }
        }
        _getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
        _setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
          this.bind();
          this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
          this.bind();
          this.setValue(sourceArray, offset);
        }
        bind() {
          let targetObject = this.node;
          const parsedPath = this.parsedPath;
          const objectName = parsedPath.objectName;
          const propertyName = parsedPath.propertyName;
          let propertyIndex = parsedPath.propertyIndex;
          if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
          }
          if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch (objectName) {
              case "materials":
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                targetObject = targetObject.material.materials;
                break;
              case "bones":
                if (!targetObject.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                targetObject = targetObject.skeleton.bones;
                for (let i2 = 0; i2 < targetObject.length; i2++) {
                  if (targetObject[i2].name === objectIndex) {
                    objectIndex = i2;
                    break;
                  }
                }
                break;
              default:
                if (targetObject[objectName] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== void 0) {
              if (targetObject[objectIndex] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                return;
              }
              targetObject = targetObject[objectIndex];
            }
          }
          const nodeProperty = targetObject[propertyName];
          if (nodeProperty === void 0) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
          }
          let versioning = this.Versioning.None;
          this.targetObject = targetObject;
          if (targetObject.needsUpdate !== void 0) {
            versioning = this.Versioning.NeedsUpdate;
          } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let bindingType = this.BindingType.Direct;
          if (propertyIndex !== void 0) {
            if (propertyName === "morphTargetInfluences") {
              if (!targetObject.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (targetObject.geometry.isBufferGeometry) {
                if (!targetObject.geometry.morphAttributes) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  return;
                }
                if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                  propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                }
              } else {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                return;
              }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
          } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
          } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
          } else {
            this.propertyName = propertyName;
          }
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      }
      PropertyBinding.Composite = Composite;
      PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
      PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]];
      class AnimationObjectGroup {
        constructor() {
          this.uuid = generateUUID();
          this._objects = Array.prototype.slice.call(arguments);
          this.nCachedObjects_ = 0;
          const indices = {};
          this._indicesByUUID = indices;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            indices[arguments[i2].uuid] = i2;
          }
          this._paths = [];
          this._parsedPaths = [];
          this._bindings = [];
          this._bindingsIndicesByPath = {};
          const scope = this;
          this.stats = {
            objects: {
              get total() {
                return scope._objects.length;
              },
              get inUse() {
                return this.total - scope.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return scope._bindings.length;
            }
          };
        }
        add() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
          let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === void 0) {
              index = nObjects++;
              indicesByUUID[uuid] = index;
              objects.push(object);
              for (let j = 0, m2 = nBindings; j !== m2; ++j) {
                bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
              }
            } else if (index < nCachedObjects) {
              knownObject = objects[index];
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[uuid] = firstActiveIndex;
              objects[firstActiveIndex] = object;
              for (let j = 0, m2 = nBindings; j !== m2; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                let binding = bindingsForPath[index];
                bindingsForPath[index] = lastCached;
                if (binding === void 0) {
                  binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                }
                bindingsForPath[firstActiveIndex] = binding;
              }
            } else if (objects[index] !== knownObject) {
              console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0 && index >= nCachedObjects) {
              const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
              indicesByUUID[firstActiveObject.uuid] = index;
              objects[index] = firstActiveObject;
              indicesByUUID[uuid] = lastCachedIndex;
              objects[lastCachedIndex] = object;
              for (let j = 0, m2 = nBindings; j !== m2; ++j) {
                const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                bindingsForPath[index] = firstActive;
                bindingsForPath[lastCachedIndex] = binding;
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        uncache() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0) {
              delete indicesByUUID[uuid];
              if (index < nCachedObjects) {
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                objects[firstActiveIndex] = lastObject;
                objects.pop();
                for (let j = 0, m2 = nBindings; j !== m2; ++j) {
                  const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                  bindingsForPath[index] = lastCached;
                  bindingsForPath[firstActiveIndex] = last;
                  bindingsForPath.pop();
                }
              } else {
                const lastIndex = --nObjects, lastObject = objects[lastIndex];
                if (lastIndex > 0) {
                  indicesByUUID[lastObject.uuid] = index;
                }
                objects[index] = lastObject;
                objects.pop();
                for (let j = 0, m2 = nBindings; j !== m2; ++j) {
                  const bindingsForPath = bindings[j];
                  bindingsForPath[index] = bindingsForPath[lastIndex];
                  bindingsForPath.pop();
                }
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        subscribe_(path, parsedPath) {
          const indicesByPath = this._bindingsIndicesByPath;
          let index = indicesByPath[path];
          const bindings = this._bindings;
          if (index !== void 0)
            return bindings[index];
          const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
          index = bindings.length;
          indicesByPath[path] = index;
          paths.push(path);
          parsedPaths.push(parsedPath);
          bindings.push(bindingsForPath);
          for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
            const object = objects[i2];
            bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
          }
          return bindingsForPath;
        }
        unsubscribe_(path) {
          const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
          if (index !== void 0) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
          }
        }
      }
      AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
      class AnimationAction {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
          this._mixer = mixer;
          this._clip = clip;
          this._localRoot = localRoot;
          this.blendMode = blendMode;
          const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
          const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const interpolant = tracks[i2].createInterpolant(null);
            interpolants[i2] = interpolant;
            interpolant.settings = interpolantSettings;
          }
          this._interpolantSettings = interpolantSettings;
          this._interpolants = interpolants;
          this._propertyBindings = new Array(nTracks);
          this._cacheIndex = null;
          this._byClipCacheIndex = null;
          this._timeScaleInterpolant = null;
          this._weightInterpolant = null;
          this.loop = LoopRepeat;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this.timeScale = 1;
          this._effectiveTimeScale = 1;
          this.weight = 1;
          this._effectiveWeight = 1;
          this.repetitions = Infinity;
          this.paused = false;
          this.enabled = true;
          this.clampWhenFinished = false;
          this.zeroSlopeAtStart = true;
          this.zeroSlopeAtEnd = true;
        }
        play() {
          this._mixer._activateAction(this);
          return this;
        }
        stop() {
          this._mixer._deactivateAction(this);
          return this.reset();
        }
        reset() {
          this.paused = false;
          this.enabled = true;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(time) {
          this._startTime = time;
          return this;
        }
        setLoop(mode, repetitions) {
          this.loop = mode;
          this.repetitions = repetitions;
          return this;
        }
        setEffectiveWeight(weight) {
          this.weight = weight;
          this._effectiveWeight = this.enabled ? weight : 0;
          return this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(duration) {
          return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
          return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);
          if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
          }
          return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
          return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
          const weightInterpolant = this._weightInterpolant;
          if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
          }
          return this;
        }
        setEffectiveTimeScale(timeScale) {
          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;
          return this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(duration) {
          this.timeScale = this._clip.duration / duration;
          return this.stopWarping();
        }
        syncWith(action) {
          this.time = action.time;
          this.timeScale = action.timeScale;
          return this.stopWarping();
        }
        halt(duration) {
          return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
          const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
          let interpolant = this._timeScaleInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now3;
          times[1] = now3 + duration;
          values[0] = startTimeScale / timeScale;
          values[1] = endTimeScale / timeScale;
          return this;
        }
        stopWarping() {
          const timeScaleInterpolant = this._timeScaleInterpolant;
          if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
          }
          return this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(time, deltaTime, timeDirection, accuIndex) {
          if (!this.enabled) {
            this._updateWeight(time);
            return;
          }
          const startTime = this._startTime;
          if (startTime !== null) {
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
              return;
            }
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
          }
          deltaTime *= this._updateTimeScale(time);
          const clipTime = this._updateTime(deltaTime);
          const weight = this._updateWeight(time);
          if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch (this.blendMode) {
              case AdditiveAnimationBlendMode:
                for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulateAdditive(weight);
                }
                break;
              case NormalAnimationBlendMode:
              default:
                for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
          }
        }
        _updateWeight(time) {
          let weight = 0;
          if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              weight *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopFading();
                if (interpolantValue === 0) {
                  this.enabled = false;
                }
              }
            }
          }
          this._effectiveWeight = weight;
          return weight;
        }
        _updateTimeScale(time) {
          let timeScale = 0;
          if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              timeScale *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopWarping();
                if (timeScale === 0) {
                  this.paused = true;
                } else {
                  this.timeScale = timeScale;
                }
              }
            }
          }
          this._effectiveTimeScale = timeScale;
          return timeScale;
        }
        _updateTime(deltaTime) {
          const duration = this._clip.duration;
          const loop2 = this.loop;
          let time = this.time + deltaTime;
          let loopCount = this._loopCount;
          const pingPong = loop2 === LoopPingPong;
          if (deltaTime === 0) {
            if (loopCount === -1)
              return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
          }
          if (loop2 === LoopOnce) {
            if (loopCount === -1) {
              this._loopCount = 0;
              this._setEndings(true, true, false);
            }
            handle_stop: {
              if (time >= duration) {
                time = duration;
              } else if (time < 0) {
                time = 0;
              } else {
                this.time = time;
                break handle_stop;
              }
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime < 0 ? -1 : 1
              });
            }
          } else {
            if (loopCount === -1) {
              if (deltaTime >= 0) {
                loopCount = 0;
                this._setEndings(true, this.repetitions === 0, pingPong);
              } else {
                this._setEndings(this.repetitions === 0, true, pingPong);
              }
            }
            if (time >= duration || time < 0) {
              const loopDelta = Math.floor(time / duration);
              time -= duration * loopDelta;
              loopCount += Math.abs(loopDelta);
              const pending = this.repetitions - loopCount;
              if (pending <= 0) {
                if (this.clampWhenFinished)
                  this.paused = true;
                else
                  this.enabled = false;
                time = deltaTime > 0 ? duration : 0;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: deltaTime > 0 ? 1 : -1
                });
              } else {
                if (pending === 1) {
                  const atStart = deltaTime < 0;
                  this._setEndings(atStart, !atStart, pingPong);
                } else {
                  this._setEndings(false, false, pingPong);
                }
                this._loopCount = loopCount;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta
                });
              }
            } else {
              this.time = time;
            }
            if (pingPong && (loopCount & 1) === 1) {
              return duration - time;
            }
          }
          return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
          const settings = this._interpolantSettings;
          if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
          } else {
            if (atStart) {
              settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
              settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingEnd = WrapAroundEnding;
            }
          }
        }
        _scheduleFading(duration, weightNow, weightThen) {
          const mixer = this._mixer, now3 = mixer.time;
          let interpolant = this._weightInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now3;
          values[0] = weightNow;
          times[1] = now3 + duration;
          values[1] = weightThen;
          return this;
        }
      }
      class AnimationMixer extends EventDispatcher {
        constructor(root) {
          super();
          this._root = root;
          this._initMemoryManager();
          this._accuIndex = 0;
          this.time = 0;
          this.timeScale = 1;
        }
        _bindAction(action, prototypeAction) {
          const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
          let bindingsByName = bindingsByRoot[rootUuid];
          if (bindingsByName === void 0) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
          }
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const track = tracks[i2], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== void 0) {
              bindings[i2] = binding;
            } else {
              binding = bindings[i2];
              if (binding !== void 0) {
                if (binding._cacheIndex === null) {
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                }
                continue;
              }
              const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
              binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
              bindings[i2] = binding;
            }
            interpolants[i2].resultBuffer = binding.buffer;
          }
        }
        _activateAction(action) {
          if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
              const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
              this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
              this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
              const binding = bindings[i2];
              if (binding.useCount++ === 0) {
                this._lendBinding(binding);
                binding.saveOriginalState();
              }
            }
            this._lendAction(action);
          }
        }
        _deactivateAction(action) {
          if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
              const binding = bindings[i2];
              if (--binding.useCount === 0) {
                binding.restoreOriginalState();
                this._takeBackBinding(binding);
              }
            }
            this._takeBackAction(action);
          }
        }
        _initMemoryManager() {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          const scope = this;
          this.stats = {
            actions: {
              get total() {
                return scope._actions.length;
              },
              get inUse() {
                return scope._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return scope._bindings.length;
              },
              get inUse() {
                return scope._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return scope._controlInterpolants.length;
              },
              get inUse() {
                return scope._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(action) {
          const index = action._cacheIndex;
          return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
          const actions = this._actions, actionsByClip = this._actionsByClip;
          let actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip === void 0) {
            actionsForClip = {
              knownActions: [action],
              actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
          } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
          }
          action._cacheIndex = actions.length;
          actions.push(action);
          actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
          const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          action._cacheIndex = null;
          const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();
          action._byClipCacheIndex = null;
          const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
          delete actionByRoot[rootUuid];
          if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
          }
          this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (--binding.referenceCount === 0) {
              this._removeInactiveBinding(binding);
            }
          }
        }
        _lendAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;
          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;
          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;
        }
        _addInactiveBinding(binding, rootUuid, trackName) {
          const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
          let bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName === void 0) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
          }
          bindingByName[trackName] = binding;
          binding._cacheIndex = bindings.length;
          bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
          const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();
          delete bindingByName[trackName];
          if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
          }
        }
        _lendBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;
          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;
          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;
        }
        _lendControlInterpolant() {
          const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
          let interpolant = interpolants[lastActiveIndex];
          if (interpolant === void 0) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
          }
          return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
          const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;
          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;
        }
        clipAction(clip, optionalRoot, blendMode) {
          const root = optionalRoot || this._root, rootUuid = root.uuid;
          let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
          const clipUuid = clipObject !== null ? clipObject.uuid : clip;
          const actionsForClip = this._actionsByClip[clipUuid];
          let prototypeAction = null;
          if (blendMode === void 0) {
            if (clipObject !== null) {
              blendMode = clipObject.blendMode;
            } else {
              blendMode = NormalAnimationBlendMode;
            }
          }
          if (actionsForClip !== void 0) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
              return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
              clipObject = prototypeAction._clip;
          }
          if (clipObject === null)
            return null;
          const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
          this._bindAction(newAction, prototypeAction);
          this._addInactiveAction(newAction, clipUuid, rootUuid);
          return newAction;
        }
        existingAction(clip, optionalRoot) {
          const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            return actionsForClip.actionByRoot[rootUuid] || null;
          }
          return null;
        }
        stopAllAction() {
          const actions = this._actions, nActions = this._nActiveActions;
          for (let i2 = nActions - 1; i2 >= 0; --i2) {
            actions[i2].stop();
          }
          return this;
        }
        update(deltaTime) {
          deltaTime *= this.timeScale;
          const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
          for (let i2 = 0; i2 !== nActions; ++i2) {
            const action = actions[i2];
            action._update(time, deltaTime, timeDirection, accuIndex);
          }
          const bindings = this._bindings, nBindings = this._nActiveBindings;
          for (let i2 = 0; i2 !== nBindings; ++i2) {
            bindings[i2].apply(accuIndex);
          }
          return this;
        }
        setTime(timeInSeconds) {
          this.time = 0;
          for (let i2 = 0; i2 < this._actions.length; i2++) {
            this._actions[i2].time = 0;
          }
          return this.update(timeInSeconds);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(clip) {
          const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            const actionsToRemove = actionsForClip.knownActions;
            for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
              const action = actionsToRemove[i2];
              this._deactivateAction(action);
              const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
              action._cacheIndex = null;
              action._byClipCacheIndex = null;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
          }
        }
        uncacheRoot(root) {
          const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
          for (const clipUuid in actionsByClip) {
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== void 0) {
              this._deactivateAction(action);
              this._removeInactiveAction(action);
            }
          }
          const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName !== void 0) {
            for (const trackName in bindingByName) {
              const binding = bindingByName[trackName];
              binding.restoreOriginalState();
              this._removeInactiveBinding(binding);
            }
          }
        }
        uncacheAction(clip, optionalRoot) {
          const action = this.existingAction(clip, optionalRoot);
          if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
      }
      AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Uniform {
        constructor(value) {
          if (typeof value === "string") {
            console.warn("THREE.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
          }
          this.value = value;
        }
        clone() {
          return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
        }
      }
      class InstancedInterleavedBuffer extends InterleavedBuffer {
        constructor(array, stride, meshPerAttribute = 1) {
          super(array, stride);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        clone(data) {
          const ib = super.clone(data);
          ib.meshPerAttribute = this.meshPerAttribute;
          return ib;
        }
        toJSON(data) {
          const json = super.toJSON(data);
          json.isInstancedInterleavedBuffer = true;
          json.meshPerAttribute = this.meshPerAttribute;
          return json;
        }
      }
      InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
      class GLBufferAttribute {
        constructor(buffer, type, itemSize, elementSize, count) {
          this.buffer = buffer;
          this.type = type;
          this.itemSize = itemSize;
          this.elementSize = elementSize;
          this.count = count;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setBuffer(buffer) {
          this.buffer = buffer;
          return this;
        }
        setType(type, elementSize) {
          this.type = type;
          this.elementSize = elementSize;
          return this;
        }
        setItemSize(itemSize) {
          this.itemSize = itemSize;
          return this;
        }
        setCount(count) {
          this.count = count;
          return this;
        }
      }
      GLBufferAttribute.prototype.isGLBufferAttribute = true;
      class Raycaster {
        constructor(origin, direction, near = 0, far = Infinity) {
          this.ray = new Ray(origin, direction);
          this.near = near;
          this.far = far;
          this.camera = null;
          this.layers = new Layers();
          this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(origin, direction) {
          this.ray.set(origin, direction);
        }
        setFromCamera(coords, camera) {
          if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
          } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
          } else {
            console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
          }
        }
        intersectObject(object, recursive = true, intersects2 = []) {
          intersectObject(object, this, intersects2, recursive);
          intersects2.sort(ascSort);
          return intersects2;
        }
        intersectObjects(objects, recursive = true, intersects2 = []) {
          for (let i2 = 0, l = objects.length; i2 < l; i2++) {
            intersectObject(objects[i2], this, intersects2, recursive);
          }
          intersects2.sort(ascSort);
          return intersects2;
        }
      }
      function ascSort(a, b) {
        return a.distance - b.distance;
      }
      function intersectObject(object, raycaster, intersects2, recursive) {
        if (object.layers.test(raycaster.layers)) {
          object.raycast(raycaster, intersects2);
        }
        if (recursive === true) {
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            intersectObject(children[i2], raycaster, intersects2, true);
          }
        }
      }
      class Spherical {
        constructor(radius = 1, phi = 0, theta = 0) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        set(radius, phi, theta) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.phi = other.phi;
          this.theta = other.theta;
          return this;
        }
        makeSafe() {
          const EPS = 1e-6;
          this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x2, y, z) {
          this.radius = Math.sqrt(x2 * x2 + y * y + z * z);
          if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
          } else {
            this.theta = Math.atan2(x2, z);
            this.phi = Math.acos(clamp(y / this.radius, -1, 1));
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Cylindrical {
        constructor(radius = 1, theta = 0, y = 0) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        set(radius, theta, y) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.theta = other.theta;
          this.y = other.y;
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x2, y, z) {
          this.radius = Math.sqrt(x2 * x2 + z * z);
          this.theta = Math.atan2(x2, z);
          this.y = y;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const _vector$4 = /* @__PURE__ */ new Vector2();
      class Box2 {
        constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = Infinity;
          this.max.x = this.max.y = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      }
      Box2.prototype.isBox2 = true;
      const _startP = /* @__PURE__ */ new Vector34();
      const _startEnd = /* @__PURE__ */ new Vector34();
      class Line3 {
        constructor(start = new Vector34(), end = new Vector34()) {
          this.start = start;
          this.end = end;
        }
        set(start, end) {
          this.start.copy(start);
          this.end.copy(end);
          return this;
        }
        copy(line) {
          this.start.copy(line.start);
          this.end.copy(line.end);
          return this;
        }
        getCenter(target) {
          return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
          return target.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t2, target) {
          return this.delta(target).multiplyScalar(t2).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
          _startP.subVectors(point, this.start);
          _startEnd.subVectors(this.end, this.start);
          const startEnd2 = _startEnd.dot(_startEnd);
          const startEnd_startP = _startEnd.dot(_startP);
          let t2 = startEnd_startP / startEnd2;
          if (clampToLine) {
            t2 = clamp(t2, 0, 1);
          }
          return t2;
        }
        closestPointToPoint(point, clampToLine, target) {
          const t2 = this.closestPointToPointParameter(point, clampToLine);
          return this.delta(target).multiplyScalar(t2).add(this.start);
        }
        applyMatrix4(matrix) {
          this.start.applyMatrix4(matrix);
          this.end.applyMatrix4(matrix);
          return this;
        }
        equals(line) {
          return line.start.equals(this.start) && line.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const _vector$3 = /* @__PURE__ */ new Vector34();
      class SpotLightHelper extends Object3D2 {
        constructor(light, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry2 = new BufferGeometry3();
          const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
          for (let i2 = 0, j = 1, l = 32; i2 < l; i2++, j++) {
            const p1 = i2 / l * Math.PI * 2;
            const p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
          }
          geometry2.setAttribute("position", new Float32BufferAttribute2(positions, 3));
          const material2 = new LineBasicMaterial3({
            fog: false,
            toneMapped: false
          });
          this.cone = new LineSegments2(geometry2, material2);
          this.add(this.cone);
          this.update();
        }
        dispose() {
          this.cone.geometry.dispose();
          this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const coneLength = this.light.distance ? this.light.distance : 1e3;
          const coneWidth = coneLength * Math.tan(this.light.angle);
          this.cone.scale.set(coneWidth, coneWidth, coneLength);
          _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
          this.cone.lookAt(_vector$3);
          if (this.color !== void 0) {
            this.cone.material.color.set(this.color);
          } else {
            this.cone.material.color.copy(this.light.color);
          }
        }
      }
      const _vector$2 = /* @__PURE__ */ new Vector34();
      const _boneMatrix = /* @__PURE__ */ new Matrix4();
      const _matrixWorldInv = /* @__PURE__ */ new Matrix4();
      class SkeletonHelper extends LineSegments2 {
        constructor(object) {
          const bones = getBoneList(object);
          const geometry2 = new BufferGeometry3();
          const vertices = [];
          const colors = [];
          const color1 = new Color(0, 0, 1);
          const color2 = new Color(0, 1, 0);
          for (let i2 = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);
            }
          }
          geometry2.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry2.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material2 = new LineBasicMaterial3({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
          });
          super(geometry2, material2);
          this.type = "SkeletonHelper";
          this.isSkeletonHelper = true;
          this.root = object;
          this.bones = bones;
          this.matrix = object.matrixWorld;
          this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
          const bones = this.bones;
          const geometry2 = this.geometry;
          const position2 = geometry2.getAttribute("position");
          _matrixWorldInv.copy(this.root.matrixWorld).invert();
          for (let i2 = 0, j = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position2.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position2.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
              j += 2;
            }
          }
          geometry2.getAttribute("position").needsUpdate = true;
          super.updateMatrixWorld(force);
        }
      }
      function getBoneList(object) {
        const boneList = [];
        if (object && object.isBone) {
          boneList.push(object);
        }
        for (let i2 = 0; i2 < object.children.length; i2++) {
          boneList.push.apply(boneList, getBoneList(object.children[i2]));
        }
        return boneList;
      }
      class PointLightHelper extends Mesh3 {
        constructor(light, sphereSize, color) {
          const geometry2 = new SphereGeometry(sphereSize, 4, 2);
          const material2 = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          super(geometry2, material2);
          this.light = light;
          this.light.updateMatrixWorld();
          this.color = color;
          this.type = "PointLightHelper";
          this.matrix = this.light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.update();
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
        update() {
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            this.material.color.copy(this.light.color);
          }
        }
      }
      const _vector$1 = /* @__PURE__ */ new Vector34();
      const _color1 = /* @__PURE__ */ new Color();
      const _color2 = /* @__PURE__ */ new Color();
      class HemisphereLightHelper extends Object3D2 {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry2 = new OctahedronGeometry(size);
          geometry2.rotateY(Math.PI * 0.5);
          this.material = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          if (this.color === void 0)
            this.material.vertexColors = true;
          const position2 = geometry2.getAttribute("position");
          const colors = new Float32Array(position2.count * 3);
          geometry2.setAttribute("color", new BufferAttribute(colors, 3));
          this.add(new Mesh3(geometry2, this.material));
          this.update();
        }
        dispose() {
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        }
        update() {
          const mesh = this.children[0];
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            const colors = mesh.geometry.getAttribute("color");
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for (let i2 = 0, l = colors.count; i2 < l; i2++) {
              const color = i2 < l / 2 ? _color1 : _color2;
              colors.setXYZ(i2, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
          }
          mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }
      class GridHelper2 extends LineSegments2 {
        constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const center = divisions / 2;
          const step = size / divisions;
          const halfSize = size / 2;
          const vertices = [], colors = [];
          for (let i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i2 === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
          }
          const geometry2 = new BufferGeometry3();
          geometry2.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry2.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material2 = new LineBasicMaterial3({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry2, material2);
          this.type = "GridHelper";
        }
      }
      class PolarGridHelper extends LineSegments2 {
        constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const vertices = [];
          const colors = [];
          for (let i2 = 0; i2 <= radials; i2++) {
            const v = i2 / radials * (Math.PI * 2);
            const x2 = Math.sin(v) * radius;
            const z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x2, 0, z);
            const color = i2 & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
          }
          for (let i2 = 0; i2 <= circles; i2++) {
            const color = i2 & 1 ? color1 : color2;
            const r2 = radius - radius / circles * i2;
            for (let j = 0; j < divisions; j++) {
              let v = j / divisions * (Math.PI * 2);
              let x2 = Math.sin(v) * r2;
              let z = Math.cos(v) * r2;
              vertices.push(x2, 0, z);
              colors.push(color.r, color.g, color.b);
              v = (j + 1) / divisions * (Math.PI * 2);
              x2 = Math.sin(v) * r2;
              z = Math.cos(v) * r2;
              vertices.push(x2, 0, z);
              colors.push(color.r, color.g, color.b);
            }
          }
          const geometry2 = new BufferGeometry3();
          geometry2.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry2.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material2 = new LineBasicMaterial3({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry2, material2);
          this.type = "PolarGridHelper";
        }
      }
      const _v12 = /* @__PURE__ */ new Vector34();
      const _v22 = /* @__PURE__ */ new Vector34();
      const _v3 = /* @__PURE__ */ new Vector34();
      class DirectionalLightHelper extends Object3D2 {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          if (size === void 0)
            size = 1;
          let geometry2 = new BufferGeometry3();
          geometry2.setAttribute("position", new Float32BufferAttribute2([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
          const material2 = new LineBasicMaterial3({
            fog: false,
            toneMapped: false
          });
          this.lightPlane = new Line2(geometry2, material2);
          this.add(this.lightPlane);
          geometry2 = new BufferGeometry3();
          geometry2.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 0, 0, 1], 3));
          this.targetLine = new Line2(geometry2, material2);
          this.add(this.targetLine);
          this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose();
          this.lightPlane.material.dispose();
          this.targetLine.geometry.dispose();
          this.targetLine.material.dispose();
        }
        update() {
          _v12.setFromMatrixPosition(this.light.matrixWorld);
          _v22.setFromMatrixPosition(this.light.target.matrixWorld);
          _v3.subVectors(_v22, _v12);
          this.lightPlane.lookAt(_v22);
          if (this.color !== void 0) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
          } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
          }
          this.targetLine.lookAt(_v22);
          this.targetLine.scale.z = _v3.length();
        }
      }
      const _vector = /* @__PURE__ */ new Vector34();
      const _camera = /* @__PURE__ */ new Camera();
      class CameraHelper extends LineSegments2 {
        constructor(camera) {
          const geometry2 = new BufferGeometry3();
          const material2 = new LineBasicMaterial3({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
          });
          const vertices = [];
          const colors = [];
          const pointMap = {};
          const colorFrustum = new Color(16755200);
          const colorCone = new Color(16711680);
          const colorUp = new Color(43775);
          const colorTarget = new Color(16777215);
          const colorCross = new Color(3355443);
          addLine("n1", "n2", colorFrustum);
          addLine("n2", "n4", colorFrustum);
          addLine("n4", "n3", colorFrustum);
          addLine("n3", "n1", colorFrustum);
          addLine("f1", "f2", colorFrustum);
          addLine("f2", "f4", colorFrustum);
          addLine("f4", "f3", colorFrustum);
          addLine("f3", "f1", colorFrustum);
          addLine("n1", "f1", colorFrustum);
          addLine("n2", "f2", colorFrustum);
          addLine("n3", "f3", colorFrustum);
          addLine("n4", "f4", colorFrustum);
          addLine("p", "n1", colorCone);
          addLine("p", "n2", colorCone);
          addLine("p", "n3", colorCone);
          addLine("p", "n4", colorCone);
          addLine("u1", "u2", colorUp);
          addLine("u2", "u3", colorUp);
          addLine("u3", "u1", colorUp);
          addLine("c", "t", colorTarget);
          addLine("p", "c", colorCross);
          addLine("cn1", "cn2", colorCross);
          addLine("cn3", "cn4", colorCross);
          addLine("cf1", "cf2", colorCross);
          addLine("cf3", "cf4", colorCross);
          function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
          }
          function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === void 0) {
              pointMap[id] = [];
            }
            pointMap[id].push(vertices.length / 3 - 1);
          }
          geometry2.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry2.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          super(geometry2, material2);
          this.type = "CameraHelper";
          this.camera = camera;
          if (this.camera.updateProjectionMatrix)
            this.camera.updateProjectionMatrix();
          this.matrix = camera.matrixWorld;
          this.matrixAutoUpdate = false;
          this.pointMap = pointMap;
          this.update();
        }
        update() {
          const geometry2 = this.geometry;
          const pointMap = this.pointMap;
          const w = 1, h2 = 1;
          _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
          setPoint("c", pointMap, geometry2, _camera, 0, 0, -1);
          setPoint("t", pointMap, geometry2, _camera, 0, 0, 1);
          setPoint("n1", pointMap, geometry2, _camera, -w, -h2, -1);
          setPoint("n2", pointMap, geometry2, _camera, w, -h2, -1);
          setPoint("n3", pointMap, geometry2, _camera, -w, h2, -1);
          setPoint("n4", pointMap, geometry2, _camera, w, h2, -1);
          setPoint("f1", pointMap, geometry2, _camera, -w, -h2, 1);
          setPoint("f2", pointMap, geometry2, _camera, w, -h2, 1);
          setPoint("f3", pointMap, geometry2, _camera, -w, h2, 1);
          setPoint("f4", pointMap, geometry2, _camera, w, h2, 1);
          setPoint("u1", pointMap, geometry2, _camera, w * 0.7, h2 * 1.1, -1);
          setPoint("u2", pointMap, geometry2, _camera, -w * 0.7, h2 * 1.1, -1);
          setPoint("u3", pointMap, geometry2, _camera, 0, h2 * 2, -1);
          setPoint("cf1", pointMap, geometry2, _camera, -w, 0, 1);
          setPoint("cf2", pointMap, geometry2, _camera, w, 0, 1);
          setPoint("cf3", pointMap, geometry2, _camera, 0, -h2, 1);
          setPoint("cf4", pointMap, geometry2, _camera, 0, h2, 1);
          setPoint("cn1", pointMap, geometry2, _camera, -w, 0, -1);
          setPoint("cn2", pointMap, geometry2, _camera, w, 0, -1);
          setPoint("cn3", pointMap, geometry2, _camera, 0, -h2, -1);
          setPoint("cn4", pointMap, geometry2, _camera, 0, h2, -1);
          geometry2.getAttribute("position").needsUpdate = true;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      }
      function setPoint(point, pointMap, geometry2, camera, x2, y, z) {
        _vector.set(x2, y, z).unproject(camera);
        const points = pointMap[point];
        if (points !== void 0) {
          const position2 = geometry2.getAttribute("position");
          for (let i2 = 0, l = points.length; i2 < l; i2++) {
            position2.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
          }
        }
      }
      const _box = /* @__PURE__ */ new Box3();
      class BoxHelper extends LineSegments2 {
        constructor(object, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = new Float32Array(8 * 3);
          const geometry2 = new BufferGeometry3();
          geometry2.setIndex(new BufferAttribute(indices, 1));
          geometry2.setAttribute("position", new BufferAttribute(positions, 3));
          super(geometry2, new LineBasicMaterial3({
            color,
            toneMapped: false
          }));
          this.object = object;
          this.type = "BoxHelper";
          this.matrixAutoUpdate = false;
          this.update();
        }
        update(object) {
          if (object !== void 0) {
            console.warn("THREE.BoxHelper: .update() has no longer arguments.");
          }
          if (this.object !== void 0) {
            _box.setFromObject(this.object);
          }
          if (_box.isEmpty())
            return;
          const min = _box.min;
          const max = _box.max;
          const position2 = this.geometry.attributes.position;
          const array = position2.array;
          array[0] = max.x;
          array[1] = max.y;
          array[2] = max.z;
          array[3] = min.x;
          array[4] = max.y;
          array[5] = max.z;
          array[6] = min.x;
          array[7] = min.y;
          array[8] = max.z;
          array[9] = max.x;
          array[10] = min.y;
          array[11] = max.z;
          array[12] = max.x;
          array[13] = max.y;
          array[14] = min.z;
          array[15] = min.x;
          array[16] = max.y;
          array[17] = min.z;
          array[18] = min.x;
          array[19] = min.y;
          array[20] = min.z;
          array[21] = max.x;
          array[22] = min.y;
          array[23] = min.z;
          position2.needsUpdate = true;
          this.geometry.computeBoundingSphere();
        }
        setFromObject(object) {
          this.object = object;
          this.update();
          return this;
        }
        copy(source) {
          LineSegments2.prototype.copy.call(this, source);
          this.object = source.object;
          return this;
        }
      }
      class Box3Helper extends LineSegments2 {
        constructor(box, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
          const geometry2 = new BufferGeometry3();
          geometry2.setIndex(new BufferAttribute(indices, 1));
          geometry2.setAttribute("position", new Float32BufferAttribute2(positions, 3));
          super(geometry2, new LineBasicMaterial3({
            color,
            toneMapped: false
          }));
          this.box = box;
          this.type = "Box3Helper";
          this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(force) {
          const box = this.box;
          if (box.isEmpty())
            return;
          box.getCenter(this.position);
          box.getSize(this.scale);
          this.scale.multiplyScalar(0.5);
          super.updateMatrixWorld(force);
        }
      }
      class PlaneHelper extends Line2 {
        constructor(plane, size = 1, hex = 16776960) {
          const color = hex;
          const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
          const geometry2 = new BufferGeometry3();
          geometry2.setAttribute("position", new Float32BufferAttribute2(positions, 3));
          geometry2.computeBoundingSphere();
          super(geometry2, new LineBasicMaterial3({
            color,
            toneMapped: false
          }));
          this.type = "PlaneHelper";
          this.plane = plane;
          this.size = size;
          const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
          const geometry22 = new BufferGeometry3();
          geometry22.setAttribute("position", new Float32BufferAttribute2(positions2, 3));
          geometry22.computeBoundingSphere();
          this.add(new Mesh3(geometry22, new MeshBasicMaterial({
            color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
          })));
        }
        updateMatrixWorld(force) {
          let scale2 = -this.plane.constant;
          if (Math.abs(scale2) < 1e-8)
            scale2 = 1e-8;
          this.scale.set(0.5 * this.size, 0.5 * this.size, scale2);
          this.children[0].material.side = scale2 < 0 ? BackSide : FrontSide;
          this.lookAt(this.plane.normal);
          super.updateMatrixWorld(force);
        }
      }
      const _axis = /* @__PURE__ */ new Vector34();
      let _lineGeometry, _coneGeometry;
      class ArrowHelper2 extends Object3D2 {
        constructor(dir = new Vector34(0, 0, 1), origin = new Vector34(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
          super();
          this.type = "ArrowHelper";
          if (_lineGeometry === void 0) {
            _lineGeometry = new BufferGeometry3();
            _lineGeometry.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 0, 1, 0], 3));
            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
          }
          this.position.copy(origin);
          this.line = new Line2(_lineGeometry, new LineBasicMaterial3({
            color,
            toneMapped: false
          }));
          this.line.matrixAutoUpdate = false;
          this.add(this.line);
          this.cone = new Mesh3(_coneGeometry, new MeshBasicMaterial({
            color,
            toneMapped: false
          }));
          this.cone.matrixAutoUpdate = false;
          this.add(this.cone);
          this.setDirection(dir);
          this.setLength(length, headLength, headWidth);
        }
        setDirection(dir) {
          if (dir.y > 0.99999) {
            this.quaternion.set(0, 0, 0, 1);
          } else if (dir.y < -0.99999) {
            this.quaternion.set(1, 0, 0, 0);
          } else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
          }
        }
        setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
          this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
          this.line.updateMatrix();
          this.cone.scale.set(headWidth, headLength, headWidth);
          this.cone.position.y = length;
          this.cone.updateMatrix();
        }
        setColor(color) {
          this.line.material.color.set(color);
          this.cone.material.color.set(color);
        }
        copy(source) {
          super.copy(source, false);
          this.line.copy(source.line);
          this.cone.copy(source.cone);
          return this;
        }
      }
      class AxesHelper extends LineSegments2 {
        constructor(size = 1) {
          const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
          const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
          const geometry2 = new BufferGeometry3();
          geometry2.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry2.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material2 = new LineBasicMaterial3({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry2, material2);
          this.type = "AxesHelper";
        }
        setColors(xAxisColor, yAxisColor, zAxisColor) {
          const color = new Color();
          const array = this.geometry.attributes.color.array;
          color.set(xAxisColor);
          color.toArray(array, 0);
          color.toArray(array, 3);
          color.set(yAxisColor);
          color.toArray(array, 6);
          color.toArray(array, 9);
          color.set(zAxisColor);
          color.toArray(array, 12);
          color.toArray(array, 15);
          this.geometry.attributes.color.needsUpdate = true;
          return this;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      }
      class ShapePath {
        constructor() {
          this.type = "ShapePath";
          this.color = new Color();
          this.subPaths = [];
          this.currentPath = null;
        }
        moveTo(x2, y) {
          this.currentPath = new Path();
          this.subPaths.push(this.currentPath);
          this.currentPath.moveTo(x2, y);
          return this;
        }
        lineTo(x2, y) {
          this.currentPath.lineTo(x2, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
          return this;
        }
        splineThru(pts) {
          this.currentPath.splineThru(pts);
          return this;
        }
        toShapes(isCCW, noHoles) {
          function toShapesNoHoles(inSubpaths) {
            const shapes2 = [];
            for (let i2 = 0, l = inSubpaths.length; i2 < l; i2++) {
              const tmpPath2 = inSubpaths[i2];
              const tmpShape2 = new Shape();
              tmpShape2.curves = tmpPath2.curves;
              shapes2.push(tmpShape2);
            }
            return shapes2;
          }
          function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
              let edgeLowPt = inPolygon[p];
              let edgeHighPt = inPolygon[q];
              let edgeDx = edgeHighPt.x - edgeLowPt.x;
              let edgeDy = edgeHighPt.y - edgeLowPt.y;
              if (Math.abs(edgeDy) > Number.EPSILON) {
                if (edgeDy < 0) {
                  edgeLowPt = inPolygon[q];
                  edgeDx = -edgeDx;
                  edgeHighPt = inPolygon[p];
                  edgeDy = -edgeDy;
                }
                if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                  continue;
                if (inPt.y === edgeLowPt.y) {
                  if (inPt.x === edgeLowPt.x)
                    return true;
                } else {
                  const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                  if (perpEdge === 0)
                    return true;
                  if (perpEdge < 0)
                    continue;
                  inside = !inside;
                }
              } else {
                if (inPt.y !== edgeLowPt.y)
                  continue;
                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                  return true;
              }
            }
            return inside;
          }
          const isClockWise = ShapeUtils.isClockWise;
          const subPaths = this.subPaths;
          if (subPaths.length === 0)
            return [];
          if (noHoles === true)
            return toShapesNoHoles(subPaths);
          let solid, tmpPath, tmpShape;
          const shapes = [];
          if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
          }
          let holesFirst = !isClockWise(subPaths[0].getPoints());
          holesFirst = isCCW ? !holesFirst : holesFirst;
          const betterShapeHoles = [];
          const newShapes = [];
          let newShapeHoles = [];
          let mainIdx = 0;
          let tmpPoints;
          newShapes[mainIdx] = void 0;
          newShapeHoles[mainIdx] = [];
          for (let i2 = 0, l = subPaths.length; i2 < l; i2++) {
            tmpPath = subPaths[i2];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
              if (!holesFirst && newShapes[mainIdx])
                mainIdx++;
              newShapes[mainIdx] = {
                s: new Shape(),
                p: tmpPoints
              };
              newShapes[mainIdx].s.curves = tmpPath.curves;
              if (holesFirst)
                mainIdx++;
              newShapeHoles[mainIdx] = [];
            } else {
              newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
              });
            }
          }
          if (!newShapes[0])
            return toShapesNoHoles(subPaths);
          if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              betterShapeHoles[sIdx] = [];
            }
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              const sho = newShapeHoles[sIdx];
              for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                const ho = sho[hIdx];
                let hole_unassigned = true;
                for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                  if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                    if (sIdx !== s2Idx)
                      toChange.push({
                        froms: sIdx,
                        tos: s2Idx,
                        hole: hIdx
                      });
                    if (hole_unassigned) {
                      hole_unassigned = false;
                      betterShapeHoles[s2Idx].push(ho);
                    } else {
                      ambiguous = true;
                    }
                  }
                }
                if (hole_unassigned) {
                  betterShapeHoles[sIdx].push(ho);
                }
              }
            }
            if (toChange.length > 0) {
              if (!ambiguous)
                newShapeHoles = betterShapeHoles;
            }
          }
          let tmpHoles;
          for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
            tmpShape = newShapes[i2].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i2];
            for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
              tmpShape.holes.push(tmpHoles[j].h);
            }
          }
          return shapes;
        }
      }
      const _floatView = new Float32Array(1);
      const _int32View = new Int32Array(_floatView.buffer);
      class DataUtils {
        static toHalfFloat(val) {
          if (val > 65504) {
            console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504.");
            val = 65504;
          }
          _floatView[0] = val;
          const x2 = _int32View[0];
          let bits = x2 >> 16 & 32768;
          let m2 = x2 >> 12 & 2047;
          const e2 = x2 >> 23 & 255;
          if (e2 < 103)
            return bits;
          if (e2 > 142) {
            bits |= 31744;
            bits |= (e2 == 255 ? 0 : 1) && x2 & 8388607;
            return bits;
          }
          if (e2 < 113) {
            m2 |= 2048;
            bits |= (m2 >> 114 - e2) + (m2 >> 113 - e2 & 1);
            return bits;
          }
          bits |= e2 - 112 << 10 | m2 >> 1;
          bits += m2 & 1;
          return bits;
        }
      }
      const LineStrip = 0;
      const LinePieces = 1;
      const NoColors = 0;
      const FaceColors = 1;
      const VertexColors = 2;
      function MeshFaceMaterial(materials) {
        console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
        return materials;
      }
      function MultiMaterial(materials = []) {
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function() {
          return materials.slice();
        };
        return materials;
      }
      function PointCloud(geometry2, material2) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        return new Points(geometry2, material2);
      }
      function Particle(material2) {
        console.warn("THREE.Particle has been renamed to THREE.Sprite.");
        return new Sprite(material2);
      }
      function ParticleSystem(geometry2, material2) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        return new Points(geometry2, material2);
      }
      function PointCloudMaterial(parameters) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function ParticleBasicMaterial(parameters) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function ParticleSystemMaterial(parameters) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function Vertex(x2, y, z) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        return new Vector34(x2, y, z);
      }
      function DynamicBufferAttribute(array, itemSize) {
        console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
        return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
      }
      function Int8Attribute(array, itemSize) {
        console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
        return new Int8BufferAttribute(array, itemSize);
      }
      function Uint8Attribute(array, itemSize) {
        console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
        return new Uint8BufferAttribute(array, itemSize);
      }
      function Uint8ClampedAttribute(array, itemSize) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
        return new Uint8ClampedBufferAttribute(array, itemSize);
      }
      function Int16Attribute(array, itemSize) {
        console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
        return new Int16BufferAttribute(array, itemSize);
      }
      function Uint16Attribute(array, itemSize) {
        console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
        return new Uint16BufferAttribute(array, itemSize);
      }
      function Int32Attribute(array, itemSize) {
        console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
        return new Int32BufferAttribute(array, itemSize);
      }
      function Uint32Attribute(array, itemSize) {
        console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
        return new Uint32BufferAttribute(array, itemSize);
      }
      function Float32Attribute(array, itemSize) {
        console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
        return new Float32BufferAttribute2(array, itemSize);
      }
      function Float64Attribute(array, itemSize) {
        console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
        return new Float64BufferAttribute(array, itemSize);
      }
      Curve.create = function(construct, getPoint) {
        console.log("THREE.Curve.create() has been deprecated");
        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
      };
      Path.prototype.fromPoints = function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
      };
      function AxisHelper(size) {
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
        return new AxesHelper(size);
      }
      function BoundingBoxHelper(object, color) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        return new BoxHelper(object, color);
      }
      function EdgesHelper(object, hex) {
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        return new LineSegments2(new EdgesGeometry(object.geometry), new LineBasicMaterial3({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      GridHelper2.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      };
      SkeletonHelper.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      };
      function WireframeHelper(object, hex) {
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        return new LineSegments2(new WireframeGeometry(object.geometry), new LineBasicMaterial3({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      Loader.prototype.extractUrlBase = function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url);
      };
      Loader.Handlers = {
        add: function() {
          console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
        },
        get: function() {
          console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
        }
      };
      function XHRLoader(manager) {
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
        return new FileLoader(manager);
      }
      function BinaryTextureLoader(manager) {
        console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
        return new DataTextureLoader(manager);
      }
      Box2.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box2.prototype.empty = function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box2.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box2.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Box3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box3.prototype.empty = function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box3.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box3.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Box3.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Sphere.prototype.empty = function() {
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Frustum.prototype.setFromMatrix = function(m2) {
        console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
        return this.setFromProjectionMatrix(m2);
      };
      Line3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Matrix32.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix32.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
      };
      Matrix32.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      };
      Matrix32.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
        return attribute.applyMatrix3(this);
      };
      Matrix32.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      };
      Matrix32.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Matrix4.prototype.extractPosition = function(m2) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m2);
      };
      Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix4.prototype.getPosition = function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector34().setFromMatrixColumn(this, 3);
      };
      Matrix4.prototype.setRotationFromQuaternion = function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
      };
      Matrix4.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      Matrix4.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector4 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      };
      Matrix4.prototype.rotateAxis = function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
      };
      Matrix4.prototype.crossVector = function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      Matrix4.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      Matrix4.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      Matrix4.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      Matrix4.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      Matrix4.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
        return attribute.applyMatrix4(this);
      };
      Matrix4.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      };
      Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
      };
      Matrix4.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Plane.prototype.isIntersectionLine = function(line) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(line);
      };
      Quaternion.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return vector.applyQuaternion(this);
      };
      Quaternion.prototype.inverse = function() {
        console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
        return this.invert();
      };
      Ray.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Ray.prototype.isIntersectionPlane = function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
      };
      Ray.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Triangle.prototype.area = function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
      };
      Triangle.prototype.barycoordFromPoint = function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
      };
      Triangle.prototype.midpoint = function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
      };
      Triangle.prototypenormal = function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
      };
      Triangle.prototype.plane = function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
      };
      Triangle.barycoordFromPoint = function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a, b, c, target);
      };
      Triangle.normal = function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a, b, c, target);
      };
      Shape.prototype.extractAllPoints = function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
      };
      Shape.prototype.extrude = function(options2) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options2);
      };
      Shape.prototype.makeGeometry = function(options2) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options2);
      };
      Vector2.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector2.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector2.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector34.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      };
      Vector34.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      };
      Vector34.prototype.getPositionFromMatrix = function(m2) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m2);
      };
      Vector34.prototype.getScaleFromMatrix = function(m2) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m2);
      };
      Vector34.prototype.getColumnFromMatrix = function(index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
      };
      Vector34.prototype.applyProjection = function(m2) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m2);
      };
      Vector34.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector34.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector34.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector4.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector4.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Object3D2.prototype.getChildByName = function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
      };
      Object3D2.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      };
      Object3D2.prototype.translate = function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
      };
      Object3D2.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      };
      Object3D2.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(Object3D2.prototype, {
        eulerOrder: {
          get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
          },
          set: function(value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
          }
        },
        useQuaternion: {
          get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          },
          set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          }
        }
      });
      Mesh3.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      };
      Object.defineProperties(Mesh3.prototype, {
        drawMode: {
          get: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
            return TrianglesDrawMode;
          },
          set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
          }
        }
      });
      SkinnedMesh.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      PerspectiveCamera2.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== void 0)
          this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
      };
      Object.defineProperties(Light.prototype, {
        onlyShadow: {
          set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          }
        },
        shadowCameraFov: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = value;
          }
        },
        shadowCameraLeft: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = value;
          }
        },
        shadowCameraRight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = value;
          }
        },
        shadowCameraTop: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = value;
          }
        },
        shadowCameraBottom: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = value;
          }
        },
        shadowCameraNear: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = value;
          }
        },
        shadowCameraFar: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = value;
          }
        },
        shadowCameraVisible: {
          set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
          }
        },
        shadowBias: {
          set: function(value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
          }
        },
        shadowDarkness: {
          set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          }
        },
        shadowMapWidth: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
          }
        },
        shadowMapHeight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
          }
        }
      });
      Object.defineProperties(BufferAttribute.prototype, {
        length: {
          get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length;
          }
        },
        dynamic: {
          get: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            return this.usage === DynamicDrawUsage;
          },
          set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            this.setUsage(DynamicDrawUsage);
          }
        }
      });
      BufferAttribute.prototype.setDynamic = function(value) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      BufferAttribute.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, BufferAttribute.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      BufferGeometry3.prototype.addIndex = function(index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
      };
      BufferGeometry3.prototype.addAttribute = function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
          console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
          return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
          console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
          this.setIndex(attribute);
          return this;
        }
        return this.setAttribute(name, attribute);
      };
      BufferGeometry3.prototype.addDrawCall = function(start, count, indexOffset) {
        if (indexOffset !== void 0) {
          console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
      };
      BufferGeometry3.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
      };
      BufferGeometry3.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      };
      BufferGeometry3.prototype.removeAttribute = function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
      };
      BufferGeometry3.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(BufferGeometry3.prototype, {
        drawcalls: {
          get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
          }
        },
        offsets: {
          get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
          }
        }
      });
      InterleavedBuffer.prototype.setDynamic = function(value) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      InterleavedBuffer.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      ExtrudeGeometry.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      ExtrudeGeometry.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
      };
      ExtrudeGeometry.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Scene.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Uniform.prototype.onUpdate = function() {
        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
        return this;
      };
      Object.defineProperties(Material.prototype, {
        wrapAround: {
          get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          }
        },
        overdraw: {
          get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          }
        },
        wrapRGB: {
          get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new Color();
          }
        },
        shading: {
          get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = value === FlatShading;
          }
        },
        stencilMask: {
          get: function() {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            return this.stencilFuncMask;
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            this.stencilFuncMask = value;
          }
        },
        vertexTangents: {
          get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          },
          set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          }
        }
      });
      Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
          get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
          },
          set: function(value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
          }
        }
      });
      WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      WebGLRenderer.prototype.animate = function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
      };
      WebGLRenderer.prototype.getCurrentRenderTarget = function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
      };
      WebGLRenderer.prototype.getMaxAnisotropy = function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
      };
      WebGLRenderer.prototype.getPrecision = function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
      };
      WebGLRenderer.prototype.resetGLState = function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
      };
      WebGLRenderer.prototype.supportsFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
      };
      WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
      };
      WebGLRenderer.prototype.supportsStandardDerivatives = function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
      };
      WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
      };
      WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
      };
      WebGLRenderer.prototype.supportsBlendMinMax = function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
      };
      WebGLRenderer.prototype.supportsVertexTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
      };
      WebGLRenderer.prototype.supportsInstancedArrays = function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
      };
      WebGLRenderer.prototype.enableScissorTest = function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
      };
      WebGLRenderer.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      WebGLRenderer.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      WebGLRenderer.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      WebGLRenderer.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      };
      WebGLRenderer.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      };
      WebGLRenderer.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      };
      WebGLRenderer.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      WebGLRenderer.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      WebGLRenderer.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      };
      WebGLRenderer.prototype.getActiveMipMapLevel = function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
      };
      Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
          get: function() {
            return this.shadowMap.enabled;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
          }
        },
        shadowMapType: {
          get: function() {
            return this.shadowMap.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
          }
        },
        shadowMapCullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        context: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
            return this.getContext();
          }
        },
        vr: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
            return this.xr;
          }
        },
        gammaInput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
            return false;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          }
        },
        gammaOutput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            return false;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
          }
        },
        toneMappingWhitePoint: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
            return 1;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          }
        }
      });
      Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        renderReverseSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          }
        },
        renderSingleSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          }
        }
      });
      function WebGLRenderTargetCube(width, height, options2) {
        console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
        return new WebGLCubeRenderTarget(width, options2);
      }
      Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
          }
        },
        wrapT: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
          }
        },
        magFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
          }
        },
        minFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
          }
        },
        anisotropy: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
          }
        },
        offset: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = value;
          }
        },
        repeat: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = value;
          }
        },
        format: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = value;
          }
        },
        type: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = value;
          }
        },
        generateMipmaps: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
          }
        }
      });
      Audio.prototype.load = function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const scope = this;
        const audioLoader = new AudioLoader();
        audioLoader.load(file, function(buffer) {
          scope.setBuffer(buffer);
        });
        return this;
      };
      AudioAnalyser.prototype.getData = function() {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData();
      };
      CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
        return this.update(renderer, scene);
      };
      CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
        console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
        return this.renderTarget.clear(renderer, color, depth, stencil);
      };
      ImageUtils.crossOrigin = void 0;
      ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const loader = new TextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        const texture = loader.load(url, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const loader = new CubeTextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        const texture = loader.load(urls, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      };
      ImageUtils.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function JSONLoader() {
        console.error("THREE.JSONLoader has been removed.");
      }
      const SceneUtils = {
        createMultiMaterialObject: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        detach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        attach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        }
      };
      function LensFlare() {
        console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
      }
      function ParametricGeometry() {
        console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js");
        return new BufferGeometry3();
      }
      function TextGeometry() {
        console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js");
        return new BufferGeometry3();
      }
      function FontLoader() {
        console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
      }
      function Font() {
        console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
      }
      function ImmediateRenderObject() {
        console.error("THREE.ImmediateRenderObject has been removed.");
      }
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
          detail: {
            revision: REVISION
          }
        }));
      }
      if (typeof window !== "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = REVISION;
        }
      }
      exports2.ACESFilmicToneMapping = ACESFilmicToneMapping;
      exports2.AddEquation = AddEquation;
      exports2.AddOperation = AddOperation;
      exports2.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
      exports2.AdditiveBlending = AdditiveBlending;
      exports2.AlphaFormat = AlphaFormat;
      exports2.AlwaysDepth = AlwaysDepth;
      exports2.AlwaysStencilFunc = AlwaysStencilFunc;
      exports2.AmbientLight = AmbientLight;
      exports2.AmbientLightProbe = AmbientLightProbe;
      exports2.AnimationClip = AnimationClip;
      exports2.AnimationLoader = AnimationLoader;
      exports2.AnimationMixer = AnimationMixer;
      exports2.AnimationObjectGroup = AnimationObjectGroup;
      exports2.AnimationUtils = AnimationUtils;
      exports2.ArcCurve = ArcCurve;
      exports2.ArrayCamera = ArrayCamera;
      exports2.ArrowHelper = ArrowHelper2;
      exports2.Audio = Audio;
      exports2.AudioAnalyser = AudioAnalyser;
      exports2.AudioContext = AudioContext;
      exports2.AudioListener = AudioListener;
      exports2.AudioLoader = AudioLoader;
      exports2.AxesHelper = AxesHelper;
      exports2.AxisHelper = AxisHelper;
      exports2.BackSide = BackSide;
      exports2.BasicDepthPacking = BasicDepthPacking;
      exports2.BasicShadowMap = BasicShadowMap;
      exports2.BinaryTextureLoader = BinaryTextureLoader;
      exports2.Bone = Bone;
      exports2.BooleanKeyframeTrack = BooleanKeyframeTrack;
      exports2.BoundingBoxHelper = BoundingBoxHelper;
      exports2.Box2 = Box2;
      exports2.Box3 = Box3;
      exports2.Box3Helper = Box3Helper;
      exports2.BoxBufferGeometry = BoxGeometry;
      exports2.BoxGeometry = BoxGeometry;
      exports2.BoxHelper = BoxHelper;
      exports2.BufferAttribute = BufferAttribute;
      exports2.BufferGeometry = BufferGeometry3;
      exports2.BufferGeometryLoader = BufferGeometryLoader;
      exports2.ByteType = ByteType;
      exports2.Cache = Cache;
      exports2.Camera = Camera;
      exports2.CameraHelper = CameraHelper;
      exports2.CanvasRenderer = CanvasRenderer;
      exports2.CanvasTexture = CanvasTexture;
      exports2.CatmullRomCurve3 = CatmullRomCurve3;
      exports2.CineonToneMapping = CineonToneMapping;
      exports2.CircleBufferGeometry = CircleGeometry;
      exports2.CircleGeometry = CircleGeometry;
      exports2.ClampToEdgeWrapping = ClampToEdgeWrapping;
      exports2.Clock = Clock;
      exports2.Color = Color;
      exports2.ColorKeyframeTrack = ColorKeyframeTrack;
      exports2.CompressedTexture = CompressedTexture;
      exports2.CompressedTextureLoader = CompressedTextureLoader;
      exports2.ConeBufferGeometry = ConeGeometry;
      exports2.ConeGeometry = ConeGeometry;
      exports2.CubeCamera = CubeCamera;
      exports2.CubeReflectionMapping = CubeReflectionMapping;
      exports2.CubeRefractionMapping = CubeRefractionMapping;
      exports2.CubeTexture = CubeTexture;
      exports2.CubeTextureLoader = CubeTextureLoader;
      exports2.CubeUVReflectionMapping = CubeUVReflectionMapping;
      exports2.CubeUVRefractionMapping = CubeUVRefractionMapping;
      exports2.CubicBezierCurve = CubicBezierCurve;
      exports2.CubicBezierCurve3 = CubicBezierCurve3;
      exports2.CubicInterpolant = CubicInterpolant;
      exports2.CullFaceBack = CullFaceBack;
      exports2.CullFaceFront = CullFaceFront;
      exports2.CullFaceFrontBack = CullFaceFrontBack;
      exports2.CullFaceNone = CullFaceNone;
      exports2.Curve = Curve;
      exports2.CurvePath = CurvePath;
      exports2.CustomBlending = CustomBlending;
      exports2.CustomToneMapping = CustomToneMapping;
      exports2.CylinderBufferGeometry = CylinderGeometry;
      exports2.CylinderGeometry = CylinderGeometry;
      exports2.Cylindrical = Cylindrical;
      exports2.DataTexture = DataTexture;
      exports2.DataTexture2DArray = DataTexture2DArray;
      exports2.DataTexture3D = DataTexture3D;
      exports2.DataTextureLoader = DataTextureLoader;
      exports2.DataUtils = DataUtils;
      exports2.DecrementStencilOp = DecrementStencilOp;
      exports2.DecrementWrapStencilOp = DecrementWrapStencilOp;
      exports2.DefaultLoadingManager = DefaultLoadingManager;
      exports2.DepthFormat = DepthFormat;
      exports2.DepthStencilFormat = DepthStencilFormat;
      exports2.DepthTexture = DepthTexture;
      exports2.DirectionalLight = DirectionalLight;
      exports2.DirectionalLightHelper = DirectionalLightHelper;
      exports2.DiscreteInterpolant = DiscreteInterpolant;
      exports2.DodecahedronBufferGeometry = DodecahedronGeometry;
      exports2.DodecahedronGeometry = DodecahedronGeometry;
      exports2.DoubleSide = DoubleSide;
      exports2.DstAlphaFactor = DstAlphaFactor;
      exports2.DstColorFactor = DstColorFactor;
      exports2.DynamicBufferAttribute = DynamicBufferAttribute;
      exports2.DynamicCopyUsage = DynamicCopyUsage;
      exports2.DynamicDrawUsage = DynamicDrawUsage;
      exports2.DynamicReadUsage = DynamicReadUsage;
      exports2.EdgesGeometry = EdgesGeometry;
      exports2.EdgesHelper = EdgesHelper;
      exports2.EllipseCurve = EllipseCurve;
      exports2.EqualDepth = EqualDepth;
      exports2.EqualStencilFunc = EqualStencilFunc;
      exports2.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
      exports2.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
      exports2.Euler = Euler;
      exports2.EventDispatcher = EventDispatcher;
      exports2.ExtrudeBufferGeometry = ExtrudeGeometry;
      exports2.ExtrudeGeometry = ExtrudeGeometry;
      exports2.FaceColors = FaceColors;
      exports2.FileLoader = FileLoader;
      exports2.FlatShading = FlatShading;
      exports2.Float16BufferAttribute = Float16BufferAttribute;
      exports2.Float32Attribute = Float32Attribute;
      exports2.Float32BufferAttribute = Float32BufferAttribute2;
      exports2.Float64Attribute = Float64Attribute;
      exports2.Float64BufferAttribute = Float64BufferAttribute;
      exports2.FloatType = FloatType;
      exports2.Fog = Fog;
      exports2.FogExp2 = FogExp2;
      exports2.Font = Font;
      exports2.FontLoader = FontLoader;
      exports2.FrontSide = FrontSide;
      exports2.Frustum = Frustum;
      exports2.GLBufferAttribute = GLBufferAttribute;
      exports2.GLSL1 = GLSL1;
      exports2.GLSL3 = GLSL3;
      exports2.GammaEncoding = GammaEncoding;
      exports2.GreaterDepth = GreaterDepth;
      exports2.GreaterEqualDepth = GreaterEqualDepth;
      exports2.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
      exports2.GreaterStencilFunc = GreaterStencilFunc;
      exports2.GridHelper = GridHelper2;
      exports2.Group = Group;
      exports2.HalfFloatType = HalfFloatType;
      exports2.HemisphereLight = HemisphereLight;
      exports2.HemisphereLightHelper = HemisphereLightHelper;
      exports2.HemisphereLightProbe = HemisphereLightProbe;
      exports2.IcosahedronBufferGeometry = IcosahedronGeometry;
      exports2.IcosahedronGeometry = IcosahedronGeometry;
      exports2.ImageBitmapLoader = ImageBitmapLoader;
      exports2.ImageLoader = ImageLoader;
      exports2.ImageUtils = ImageUtils;
      exports2.ImmediateRenderObject = ImmediateRenderObject;
      exports2.IncrementStencilOp = IncrementStencilOp;
      exports2.IncrementWrapStencilOp = IncrementWrapStencilOp;
      exports2.InstancedBufferAttribute = InstancedBufferAttribute;
      exports2.InstancedBufferGeometry = InstancedBufferGeometry;
      exports2.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
      exports2.InstancedMesh = InstancedMesh;
      exports2.Int16Attribute = Int16Attribute;
      exports2.Int16BufferAttribute = Int16BufferAttribute;
      exports2.Int32Attribute = Int32Attribute;
      exports2.Int32BufferAttribute = Int32BufferAttribute;
      exports2.Int8Attribute = Int8Attribute;
      exports2.Int8BufferAttribute = Int8BufferAttribute;
      exports2.IntType = IntType;
      exports2.InterleavedBuffer = InterleavedBuffer;
      exports2.InterleavedBufferAttribute = InterleavedBufferAttribute;
      exports2.Interpolant = Interpolant;
      exports2.InterpolateDiscrete = InterpolateDiscrete;
      exports2.InterpolateLinear = InterpolateLinear;
      exports2.InterpolateSmooth = InterpolateSmooth;
      exports2.InvertStencilOp = InvertStencilOp;
      exports2.JSONLoader = JSONLoader;
      exports2.KeepStencilOp = KeepStencilOp;
      exports2.KeyframeTrack = KeyframeTrack;
      exports2.LOD = LOD;
      exports2.LatheBufferGeometry = LatheGeometry;
      exports2.LatheGeometry = LatheGeometry;
      exports2.Layers = Layers;
      exports2.LensFlare = LensFlare;
      exports2.LessDepth = LessDepth;
      exports2.LessEqualDepth = LessEqualDepth;
      exports2.LessEqualStencilFunc = LessEqualStencilFunc;
      exports2.LessStencilFunc = LessStencilFunc;
      exports2.Light = Light;
      exports2.LightProbe = LightProbe;
      exports2.Line = Line2;
      exports2.Line3 = Line3;
      exports2.LineBasicMaterial = LineBasicMaterial3;
      exports2.LineCurve = LineCurve;
      exports2.LineCurve3 = LineCurve3;
      exports2.LineDashedMaterial = LineDashedMaterial;
      exports2.LineLoop = LineLoop;
      exports2.LinePieces = LinePieces;
      exports2.LineSegments = LineSegments2;
      exports2.LineStrip = LineStrip;
      exports2.LinearEncoding = LinearEncoding;
      exports2.LinearFilter = LinearFilter;
      exports2.LinearInterpolant = LinearInterpolant;
      exports2.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
      exports2.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
      exports2.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
      exports2.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
      exports2.LinearToneMapping = LinearToneMapping;
      exports2.Loader = Loader;
      exports2.LoaderUtils = LoaderUtils;
      exports2.LoadingManager = LoadingManager;
      exports2.LoopOnce = LoopOnce;
      exports2.LoopPingPong = LoopPingPong;
      exports2.LoopRepeat = LoopRepeat;
      exports2.LuminanceAlphaFormat = LuminanceAlphaFormat;
      exports2.LuminanceFormat = LuminanceFormat;
      exports2.MOUSE = MOUSE;
      exports2.Material = Material;
      exports2.MaterialLoader = MaterialLoader;
      exports2.Math = MathUtils;
      exports2.MathUtils = MathUtils;
      exports2.Matrix3 = Matrix32;
      exports2.Matrix4 = Matrix4;
      exports2.MaxEquation = MaxEquation;
      exports2.Mesh = Mesh3;
      exports2.MeshBasicMaterial = MeshBasicMaterial;
      exports2.MeshDepthMaterial = MeshDepthMaterial;
      exports2.MeshDistanceMaterial = MeshDistanceMaterial;
      exports2.MeshFaceMaterial = MeshFaceMaterial;
      exports2.MeshLambertMaterial = MeshLambertMaterial;
      exports2.MeshMatcapMaterial = MeshMatcapMaterial;
      exports2.MeshNormalMaterial = MeshNormalMaterial2;
      exports2.MeshPhongMaterial = MeshPhongMaterial;
      exports2.MeshPhysicalMaterial = MeshPhysicalMaterial;
      exports2.MeshStandardMaterial = MeshStandardMaterial;
      exports2.MeshToonMaterial = MeshToonMaterial;
      exports2.MinEquation = MinEquation;
      exports2.MirroredRepeatWrapping = MirroredRepeatWrapping;
      exports2.MixOperation = MixOperation;
      exports2.MultiMaterial = MultiMaterial;
      exports2.MultiplyBlending = MultiplyBlending;
      exports2.MultiplyOperation = MultiplyOperation;
      exports2.NearestFilter = NearestFilter;
      exports2.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
      exports2.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
      exports2.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
      exports2.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
      exports2.NeverDepth = NeverDepth;
      exports2.NeverStencilFunc = NeverStencilFunc;
      exports2.NoBlending = NoBlending;
      exports2.NoColors = NoColors;
      exports2.NoToneMapping = NoToneMapping2;
      exports2.NormalAnimationBlendMode = NormalAnimationBlendMode;
      exports2.NormalBlending = NormalBlending;
      exports2.NotEqualDepth = NotEqualDepth;
      exports2.NotEqualStencilFunc = NotEqualStencilFunc;
      exports2.NumberKeyframeTrack = NumberKeyframeTrack;
      exports2.Object3D = Object3D2;
      exports2.ObjectLoader = ObjectLoader;
      exports2.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
      exports2.OctahedronBufferGeometry = OctahedronGeometry;
      exports2.OctahedronGeometry = OctahedronGeometry;
      exports2.OneFactor = OneFactor;
      exports2.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
      exports2.OneMinusDstColorFactor = OneMinusDstColorFactor;
      exports2.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
      exports2.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
      exports2.OrthographicCamera = OrthographicCamera;
      exports2.PCFShadowMap = PCFShadowMap2;
      exports2.PCFSoftShadowMap = PCFSoftShadowMap;
      exports2.PMREMGenerator = PMREMGenerator;
      exports2.ParametricGeometry = ParametricGeometry;
      exports2.Particle = Particle;
      exports2.ParticleBasicMaterial = ParticleBasicMaterial;
      exports2.ParticleSystem = ParticleSystem;
      exports2.ParticleSystemMaterial = ParticleSystemMaterial;
      exports2.Path = Path;
      exports2.PerspectiveCamera = PerspectiveCamera2;
      exports2.Plane = Plane;
      exports2.PlaneBufferGeometry = PlaneGeometry2;
      exports2.PlaneGeometry = PlaneGeometry2;
      exports2.PlaneHelper = PlaneHelper;
      exports2.PointCloud = PointCloud;
      exports2.PointCloudMaterial = PointCloudMaterial;
      exports2.PointLight = PointLight;
      exports2.PointLightHelper = PointLightHelper;
      exports2.Points = Points;
      exports2.PointsMaterial = PointsMaterial;
      exports2.PolarGridHelper = PolarGridHelper;
      exports2.PolyhedronBufferGeometry = PolyhedronGeometry;
      exports2.PolyhedronGeometry = PolyhedronGeometry;
      exports2.PositionalAudio = PositionalAudio;
      exports2.PropertyBinding = PropertyBinding;
      exports2.PropertyMixer = PropertyMixer;
      exports2.QuadraticBezierCurve = QuadraticBezierCurve;
      exports2.QuadraticBezierCurve3 = QuadraticBezierCurve3;
      exports2.Quaternion = Quaternion;
      exports2.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
      exports2.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
      exports2.REVISION = REVISION;
      exports2.RGBADepthPacking = RGBADepthPacking;
      exports2.RGBAFormat = RGBAFormat;
      exports2.RGBAIntegerFormat = RGBAIntegerFormat;
      exports2.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
      exports2.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
      exports2.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
      exports2.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
      exports2.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
      exports2.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
      exports2.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
      exports2.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
      exports2.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
      exports2.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
      exports2.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
      exports2.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
      exports2.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
      exports2.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
      exports2.RGBA_BPTC_Format = RGBA_BPTC_Format;
      exports2.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
      exports2.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
      exports2.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
      exports2.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
      exports2.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
      exports2.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
      exports2.RGBDEncoding = RGBDEncoding;
      exports2.RGBEEncoding = RGBEEncoding;
      exports2.RGBEFormat = RGBEFormat;
      exports2.RGBFormat = RGBFormat;
      exports2.RGBIntegerFormat = RGBIntegerFormat;
      exports2.RGBM16Encoding = RGBM16Encoding;
      exports2.RGBM7Encoding = RGBM7Encoding;
      exports2.RGB_ETC1_Format = RGB_ETC1_Format;
      exports2.RGB_ETC2_Format = RGB_ETC2_Format;
      exports2.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
      exports2.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
      exports2.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
      exports2.RGFormat = RGFormat;
      exports2.RGIntegerFormat = RGIntegerFormat;
      exports2.RawShaderMaterial = RawShaderMaterial;
      exports2.Ray = Ray;
      exports2.Raycaster = Raycaster;
      exports2.RectAreaLight = RectAreaLight;
      exports2.RedFormat = RedFormat;
      exports2.RedIntegerFormat = RedIntegerFormat;
      exports2.ReinhardToneMapping = ReinhardToneMapping;
      exports2.RepeatWrapping = RepeatWrapping;
      exports2.ReplaceStencilOp = ReplaceStencilOp;
      exports2.ReverseSubtractEquation = ReverseSubtractEquation;
      exports2.RingBufferGeometry = RingGeometry;
      exports2.RingGeometry = RingGeometry;
      exports2.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
      exports2.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
      exports2.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
      exports2.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
      exports2.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
      exports2.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
      exports2.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
      exports2.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
      exports2.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
      exports2.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
      exports2.Scene = Scene;
      exports2.SceneUtils = SceneUtils;
      exports2.ShaderChunk = ShaderChunk;
      exports2.ShaderLib = ShaderLib;
      exports2.ShaderMaterial = ShaderMaterial;
      exports2.ShadowMaterial = ShadowMaterial;
      exports2.Shape = Shape;
      exports2.ShapeBufferGeometry = ShapeGeometry;
      exports2.ShapeGeometry = ShapeGeometry;
      exports2.ShapePath = ShapePath;
      exports2.ShapeUtils = ShapeUtils;
      exports2.ShortType = ShortType;
      exports2.Skeleton = Skeleton;
      exports2.SkeletonHelper = SkeletonHelper;
      exports2.SkinnedMesh = SkinnedMesh;
      exports2.SmoothShading = SmoothShading;
      exports2.Sphere = Sphere;
      exports2.SphereBufferGeometry = SphereGeometry;
      exports2.SphereGeometry = SphereGeometry;
      exports2.Spherical = Spherical;
      exports2.SphericalHarmonics3 = SphericalHarmonics3;
      exports2.SplineCurve = SplineCurve;
      exports2.SpotLight = SpotLight;
      exports2.SpotLightHelper = SpotLightHelper;
      exports2.Sprite = Sprite;
      exports2.SpriteMaterial = SpriteMaterial;
      exports2.SrcAlphaFactor = SrcAlphaFactor;
      exports2.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
      exports2.SrcColorFactor = SrcColorFactor;
      exports2.StaticCopyUsage = StaticCopyUsage;
      exports2.StaticDrawUsage = StaticDrawUsage;
      exports2.StaticReadUsage = StaticReadUsage;
      exports2.StereoCamera = StereoCamera;
      exports2.StreamCopyUsage = StreamCopyUsage;
      exports2.StreamDrawUsage = StreamDrawUsage;
      exports2.StreamReadUsage = StreamReadUsage;
      exports2.StringKeyframeTrack = StringKeyframeTrack;
      exports2.SubtractEquation = SubtractEquation;
      exports2.SubtractiveBlending = SubtractiveBlending;
      exports2.TOUCH = TOUCH;
      exports2.TangentSpaceNormalMap = TangentSpaceNormalMap;
      exports2.TetrahedronBufferGeometry = TetrahedronGeometry;
      exports2.TetrahedronGeometry = TetrahedronGeometry;
      exports2.TextGeometry = TextGeometry;
      exports2.Texture = Texture;
      exports2.TextureLoader = TextureLoader;
      exports2.TorusBufferGeometry = TorusGeometry;
      exports2.TorusGeometry = TorusGeometry;
      exports2.TorusKnotBufferGeometry = TorusKnotGeometry;
      exports2.TorusKnotGeometry = TorusKnotGeometry;
      exports2.Triangle = Triangle;
      exports2.TriangleFanDrawMode = TriangleFanDrawMode;
      exports2.TriangleStripDrawMode = TriangleStripDrawMode;
      exports2.TrianglesDrawMode = TrianglesDrawMode;
      exports2.TubeBufferGeometry = TubeGeometry;
      exports2.TubeGeometry = TubeGeometry;
      exports2.UVMapping = UVMapping;
      exports2.Uint16Attribute = Uint16Attribute;
      exports2.Uint16BufferAttribute = Uint16BufferAttribute;
      exports2.Uint32Attribute = Uint32Attribute;
      exports2.Uint32BufferAttribute = Uint32BufferAttribute;
      exports2.Uint8Attribute = Uint8Attribute;
      exports2.Uint8BufferAttribute = Uint8BufferAttribute;
      exports2.Uint8ClampedAttribute = Uint8ClampedAttribute;
      exports2.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
      exports2.Uniform = Uniform;
      exports2.UniformsLib = UniformsLib;
      exports2.UniformsUtils = UniformsUtils;
      exports2.UnsignedByteType = UnsignedByteType;
      exports2.UnsignedInt248Type = UnsignedInt248Type;
      exports2.UnsignedIntType = UnsignedIntType;
      exports2.UnsignedShort4444Type = UnsignedShort4444Type;
      exports2.UnsignedShort5551Type = UnsignedShort5551Type;
      exports2.UnsignedShort565Type = UnsignedShort565Type;
      exports2.UnsignedShortType = UnsignedShortType;
      exports2.VSMShadowMap = VSMShadowMap;
      exports2.Vector2 = Vector2;
      exports2.Vector3 = Vector34;
      exports2.Vector4 = Vector4;
      exports2.VectorKeyframeTrack = VectorKeyframeTrack;
      exports2.Vertex = Vertex;
      exports2.VertexColors = VertexColors;
      exports2.VideoTexture = VideoTexture;
      exports2.WebGL1Renderer = WebGL1Renderer;
      exports2.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
      exports2.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
      exports2.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
      exports2.WebGLRenderTarget = WebGLRenderTarget;
      exports2.WebGLRenderTargetCube = WebGLRenderTargetCube;
      exports2.WebGLRenderer = WebGLRenderer;
      exports2.WebGLUtils = WebGLUtils;
      exports2.WireframeGeometry = WireframeGeometry;
      exports2.WireframeHelper = WireframeHelper;
      exports2.WrapAroundEnding = WrapAroundEnding;
      exports2.XHRLoader = XHRLoader;
      exports2.ZeroCurvatureEnding = ZeroCurvatureEnding;
      exports2.ZeroFactor = ZeroFactor;
      exports2.ZeroSlopeEnding = ZeroSlopeEnding;
      exports2.ZeroStencilOp = ZeroStencilOp;
      exports2.sRGBEncoding = sRGBEncoding;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/.pnpm/three@0.135.0/node_modules/three/examples/jsm/controls/OrbitControls.js
var init_OrbitControls = __esm({
  "node_modules/.pnpm/three@0.135.0/node_modules/three/examples/jsm/controls/OrbitControls.js"() {
    init_shims();
  }
});

// node_modules/.pnpm/three@0.135.0/node_modules/three/examples/jsm/helpers/VertexNormalsHelper.js
var import_three, _v1, _v2, _normalMatrix;
var init_VertexNormalsHelper = __esm({
  "node_modules/.pnpm/three@0.135.0/node_modules/three/examples/jsm/helpers/VertexNormalsHelper.js"() {
    init_shims();
    import_three = __toModule(require_three());
    _v1 = new import_three.Vector3();
    _v2 = new import_three.Vector3();
    _normalMatrix = new import_three.Matrix3();
  }
});

// .svelte-kit/output/server/chunks/index-fc0d8390.js
var index_fc0d8390_exports = {};
__export(index_fc0d8390_exports, {
  default: () => _2,
  load: () => load2
});
function getFnFromLinePart1(line) {
  const [start, n] = line.split(" ");
  switch (start) {
    case "forward":
      return [1, (val) => val + Number(n)];
    case "down":
      return [0, (val) => val + Number(n)];
    case "up":
      return [0, (val) => val - Number(n)];
  }
}
function* part12(lines) {
  let horizontal = 0;
  let depth = 0;
  for (const line of lines) {
    const [t2, fn] = getFnFromLinePart1(line);
    if (t2 === 1) {
      horizontal = fn(horizontal);
    } else {
      depth = fn(depth);
    }
    yield { depth, horizontal };
  }
}
function getFnFromLinePart2(line) {
  const [start, n] = line.split(" ");
  switch (start) {
    case "forward":
      return [
        1,
        (pos, aim) => ({
          position: pos + Number(n),
          depth: Number(n) * aim
        })
      ];
    case "down":
      return [0, (val) => val + Number(n)];
    case "up":
      return [0, (val) => val - Number(n)];
  }
}
function* part22(lines) {
  let horizontal = 0;
  let aim = 0;
  let depth = 0;
  for (const line of lines) {
    const [t2, fn] = getFnFromLinePart2(line);
    if (t2 === 1) {
      const { position: position2, depth: d } = fn(horizontal, aim);
      horizontal = position2;
      depth += d;
    } else {
      aim = fn(aim);
    }
    yield { depth, aim, horizontal };
  }
}
function setup(self2) {
  const root = getContext(ROOT);
  const parent = getContext(PARENT) || root.scene;
  if (self2) {
    setContext(PARENT, self2);
    parent.add(self2);
    onDestroy(() => {
      parent.remove(self2);
      root.invalidate();
    });
  }
  return {
    root,
    parent,
    self: self2
  };
}
function set_root(context) {
  setContext(ROOT, context);
  return context;
}
function transform(object, position2, rotation2, scale2) {
  object.position.set(position2[0], position2[1], position2[2]);
  object.rotation.set(rotation2[0], rotation2[1], rotation2[2], rotation2[3]);
  if (typeof scale2 === "number") {
    object.scale.set(scale2, scale2, scale2);
  } else {
    object.scale.set(scale2[0], scale2[1], scale2[2]);
  }
}
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
function get_interpolator(a, b) {
  if (a === b || a !== a)
    return () => a;
  const type = typeof a;
  if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
    throw new Error("Cannot interpolate values of different type");
  }
  if (Array.isArray(a)) {
    const arr = b.map((bi, i2) => {
      return get_interpolator(a[i2], bi);
    });
    return (t2) => arr.map((fn) => fn(t2));
  }
  if (type === "object") {
    if (!a || !b)
      throw new Error("Object cannot be null");
    if (is_date(a) && is_date(b)) {
      a = a.getTime();
      b = b.getTime();
      const delta = b - a;
      return (t2) => new Date(a + t2 * delta);
    }
    const keys = Object.keys(b);
    const interpolators = {};
    keys.forEach((key) => {
      interpolators[key] = get_interpolator(a[key], b[key]);
    });
    return (t2) => {
      const result = {};
      keys.forEach((key) => {
        result[key] = interpolators[key](t2);
      });
      return result;
    };
  }
  if (type === "number") {
    const delta = b - a;
    return (t2) => a + t2 * delta;
  }
  throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
  const store = writable2(value);
  let task;
  let target_value = value;
  function set(new_value, opts) {
    if (value == null) {
      store.set(value = new_value);
      return Promise.resolve();
    }
    target_value = new_value;
    let previous_task = task;
    let started = false;
    let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
    if (duration === 0) {
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      store.set(value = target_value);
      return Promise.resolve();
    }
    const start = now() + delay;
    let fn;
    task = loop((now2) => {
      if (now2 < start)
        return true;
      if (!started) {
        fn = interpolate(value, new_value);
        if (typeof duration === "function")
          duration = duration(value, new_value);
        started = true;
      }
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      const elapsed = now2 - start;
      if (elapsed > duration) {
        store.set(value = new_value);
        return false;
      }
      store.set(value = fn(easing(elapsed / duration)));
      return true;
    });
    return task.promise;
  }
  return {
    set,
    update: (fn, opts) => set(fn(target_value, value), opts),
    subscribe: store.subscribe
  };
}
var THREE, import_three2, TYPE, ROOT, PARENT, css2, Canvas, position, rotation, scale, geometry, material, Mesh2, Primitive, PerspectiveCamera_1, SubmarineCanvas, _2;
var init_index_fc0d8390 = __esm({
  ".svelte-kit/output/server/chunks/index-fc0d8390.js"() {
    init_shims();
    init_app_7566ed49();
    init_loadInput_5557da5b();
    THREE = __toModule(require_three());
    import_three2 = __toModule(require_three());
    init_OrbitControls();
    init_VertexNormalsHelper();
    init_index_3b04c25a();
    init_ssr();
    (function(TYPE2) {
      TYPE2[TYPE2["DEPTH"] = 0] = "DEPTH";
      TYPE2[TYPE2["POSITION"] = 1] = "POSITION";
    })(TYPE || (TYPE = {}));
    ROOT = {};
    PARENT = {};
    css2 = {
      code: ".container.svelte-1uqz219,canvas.svelte-1uqz219{position:absolute;width:100%;height:100%;left:0;top:0}",
      map: null
    };
    Canvas = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { background = null } = $$props;
      let { environment = null } = $$props;
      let { fog = null } = $$props;
      let { overrideMaterial = null } = $$props;
      let { precision = "highp" } = $$props;
      let { powerPreference = "default" } = $$props;
      let { alpha = false } = $$props;
      let { premultipliedAlpha = true } = $$props;
      let { antialias = false } = $$props;
      let { stencil = true } = $$props;
      let { preserveDrawingBuffer = false } = $$props;
      let { failIfMajorPerformanceCaveat = false } = $$props;
      let { depth = true } = $$props;
      let { logarithmicDepthBuffer = false } = $$props;
      let { autoClear = true } = $$props;
      let { autoClearColor = true } = $$props;
      let { autoClearDepth = true } = $$props;
      let { autoClearStencil = true } = $$props;
      let { checkShaderErrors = true } = $$props;
      let { gammaFactor = 2 } = $$props;
      let { localClippingEnabled = false } = $$props;
      let { physicallyCorrectLights = false } = $$props;
      let { outputEncoding = void 0 } = $$props;
      let { clippingPlanes = [] } = $$props;
      let { shadows = void 0 } = $$props;
      let { toneMapping = THREE.NoToneMapping } = $$props;
      let { toneMappingExposure = 1 } = $$props;
      let { width = void 0 } = $$props;
      let { height = void 0 } = $$props;
      let { pixelRatio = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1 } = $$props;
      function info() {
        return root.renderer.info;
      }
      let _width;
      let _height;
      let container;
      let frame = null;
      const run2 = (fn) => fn();
      const invalidate = () => {
        if (frame)
          return;
        frame = requestAnimationFrame(() => {
          frame = null;
          before_render.forEach(run2);
          root.renderer.render(root.scene, root.camera.object);
        });
      };
      const before_render = [];
      const root = set_root({
        canvas: null,
        scene: null,
        renderer: null,
        camera: {
          object: null,
          callback: () => {
            console.warn("no camera is set");
          },
          set: (camera, callback) => {
            root.camera.object = camera;
            root.camera.callback = callback;
            if (root.controls.callback) {
              root.controls.callback(root.camera.object, root.canvas);
            }
            invalidate();
          }
        },
        controls: {
          object: null,
          callback: null,
          set: (callback) => {
            root.controls.callback = callback;
            if (root.camera.object) {
              root.controls.object = callback(root.camera.object, root.canvas);
            }
          }
        },
        before_render(fn) {
          before_render.push(fn);
          onDestroy(() => {
            const i2 = before_render.indexOf(fn);
            before_render.splice(i2, 1);
          });
        },
        invalidate
      });
      if ($$props.background === void 0 && $$bindings.background && background !== void 0)
        $$bindings.background(background);
      if ($$props.environment === void 0 && $$bindings.environment && environment !== void 0)
        $$bindings.environment(environment);
      if ($$props.fog === void 0 && $$bindings.fog && fog !== void 0)
        $$bindings.fog(fog);
      if ($$props.overrideMaterial === void 0 && $$bindings.overrideMaterial && overrideMaterial !== void 0)
        $$bindings.overrideMaterial(overrideMaterial);
      if ($$props.precision === void 0 && $$bindings.precision && precision !== void 0)
        $$bindings.precision(precision);
      if ($$props.powerPreference === void 0 && $$bindings.powerPreference && powerPreference !== void 0)
        $$bindings.powerPreference(powerPreference);
      if ($$props.alpha === void 0 && $$bindings.alpha && alpha !== void 0)
        $$bindings.alpha(alpha);
      if ($$props.premultipliedAlpha === void 0 && $$bindings.premultipliedAlpha && premultipliedAlpha !== void 0)
        $$bindings.premultipliedAlpha(premultipliedAlpha);
      if ($$props.antialias === void 0 && $$bindings.antialias && antialias !== void 0)
        $$bindings.antialias(antialias);
      if ($$props.stencil === void 0 && $$bindings.stencil && stencil !== void 0)
        $$bindings.stencil(stencil);
      if ($$props.preserveDrawingBuffer === void 0 && $$bindings.preserveDrawingBuffer && preserveDrawingBuffer !== void 0)
        $$bindings.preserveDrawingBuffer(preserveDrawingBuffer);
      if ($$props.failIfMajorPerformanceCaveat === void 0 && $$bindings.failIfMajorPerformanceCaveat && failIfMajorPerformanceCaveat !== void 0)
        $$bindings.failIfMajorPerformanceCaveat(failIfMajorPerformanceCaveat);
      if ($$props.depth === void 0 && $$bindings.depth && depth !== void 0)
        $$bindings.depth(depth);
      if ($$props.logarithmicDepthBuffer === void 0 && $$bindings.logarithmicDepthBuffer && logarithmicDepthBuffer !== void 0)
        $$bindings.logarithmicDepthBuffer(logarithmicDepthBuffer);
      if ($$props.autoClear === void 0 && $$bindings.autoClear && autoClear !== void 0)
        $$bindings.autoClear(autoClear);
      if ($$props.autoClearColor === void 0 && $$bindings.autoClearColor && autoClearColor !== void 0)
        $$bindings.autoClearColor(autoClearColor);
      if ($$props.autoClearDepth === void 0 && $$bindings.autoClearDepth && autoClearDepth !== void 0)
        $$bindings.autoClearDepth(autoClearDepth);
      if ($$props.autoClearStencil === void 0 && $$bindings.autoClearStencil && autoClearStencil !== void 0)
        $$bindings.autoClearStencil(autoClearStencil);
      if ($$props.checkShaderErrors === void 0 && $$bindings.checkShaderErrors && checkShaderErrors !== void 0)
        $$bindings.checkShaderErrors(checkShaderErrors);
      if ($$props.gammaFactor === void 0 && $$bindings.gammaFactor && gammaFactor !== void 0)
        $$bindings.gammaFactor(gammaFactor);
      if ($$props.localClippingEnabled === void 0 && $$bindings.localClippingEnabled && localClippingEnabled !== void 0)
        $$bindings.localClippingEnabled(localClippingEnabled);
      if ($$props.physicallyCorrectLights === void 0 && $$bindings.physicallyCorrectLights && physicallyCorrectLights !== void 0)
        $$bindings.physicallyCorrectLights(physicallyCorrectLights);
      if ($$props.outputEncoding === void 0 && $$bindings.outputEncoding && outputEncoding !== void 0)
        $$bindings.outputEncoding(outputEncoding);
      if ($$props.clippingPlanes === void 0 && $$bindings.clippingPlanes && clippingPlanes !== void 0)
        $$bindings.clippingPlanes(clippingPlanes);
      if ($$props.shadows === void 0 && $$bindings.shadows && shadows !== void 0)
        $$bindings.shadows(shadows);
      if ($$props.toneMapping === void 0 && $$bindings.toneMapping && toneMapping !== void 0)
        $$bindings.toneMapping(toneMapping);
      if ($$props.toneMappingExposure === void 0 && $$bindings.toneMappingExposure && toneMappingExposure !== void 0)
        $$bindings.toneMappingExposure(toneMappingExposure);
      if ($$props.width === void 0 && $$bindings.width && width !== void 0)
        $$bindings.width(width);
      if ($$props.height === void 0 && $$bindings.height && height !== void 0)
        $$bindings.height(height);
      if ($$props.pixelRatio === void 0 && $$bindings.pixelRatio && pixelRatio !== void 0)
        $$bindings.pixelRatio(pixelRatio);
      if ($$props.info === void 0 && $$bindings.info && info !== void 0)
        $$bindings.info(info);
      $$result.css.add(css2);
      {
        if (root.scene) {
          root.scene.background = background;
          root.scene.environment = environment;
          root.scene.fog = fog;
          root.scene.overrideMaterial = overrideMaterial;
        }
      }
      {
        if (root.renderer) {
          root.renderer.autoClear = autoClear;
          root.renderer.autoClearColor = autoClearColor;
          root.renderer.autoClearDepth = autoClearDepth;
          root.renderer.autoClearStencil = autoClearStencil;
          root.renderer.debug.checkShaderErrors = checkShaderErrors;
          root.renderer.gammaFactor = gammaFactor;
          root.renderer.localClippingEnabled = localClippingEnabled;
          root.renderer.physicallyCorrectLights = physicallyCorrectLights;
          if (outputEncoding != null)
            root.renderer.outputEncoding = outputEncoding;
          root.renderer.clippingPlanes = clippingPlanes;
          root.renderer.toneMapping = toneMapping;
          root.renderer.toneMappingExposure = toneMappingExposure;
          if (shadows) {
            root.renderer.shadowMap.enabled = true;
            root.renderer.shadowMap.autoUpdate = true;
            root.renderer.shadowMap.type = shadows === true ? THREE.PCFShadowMap : shadows;
          } else {
            root.renderer.shadowMap.enabled = false;
          }
          invalidate();
        }
      }
      {
        if (root.renderer) {
          const w = width !== void 0 ? width : _width;
          const h2 = height !== void 0 ? height : _height;
          root.renderer.setSize(w, h2, false);
          root.camera.callback(w, h2);
          root.renderer.setPixelRatio(pixelRatio);
          invalidate();
        }
      }
      return `

<div class="${"container svelte-1uqz219"}"${add_attribute("this", container, 0)}><canvas class="${"svelte-1uqz219"}"${add_attribute("this", root.canvas, 0)}></canvas>

	${root.scene ? `${slots.default ? slots.default({}) : ``}` : ``}
</div>`;
    });
    position = [0, 0, 0];
    rotation = [0, 0, 0];
    scale = [1, 1, 1];
    geometry = new THREE.BufferGeometry();
    material = new THREE.MeshNormalMaterial();
    Mesh2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { geometry: geometry$1 = geometry } = $$props;
      let { material: material$1 = material } = $$props;
      let { position: position$1 = position } = $$props;
      let { rotation: rotation$1 = rotation } = $$props;
      let { scale: scale$1 = scale } = $$props;
      let { castShadow = false } = $$props;
      let { receiveShadow = false } = $$props;
      let { frustumCulled = true } = $$props;
      let { renderOrder = 0 } = $$props;
      const { root, self: self2 } = setup(new THREE.Mesh(geometry$1, material$1));
      if ($$props.geometry === void 0 && $$bindings.geometry && geometry$1 !== void 0)
        $$bindings.geometry(geometry$1);
      if ($$props.material === void 0 && $$bindings.material && material$1 !== void 0)
        $$bindings.material(material$1);
      if ($$props.position === void 0 && $$bindings.position && position$1 !== void 0)
        $$bindings.position(position$1);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation$1 !== void 0)
        $$bindings.rotation(rotation$1);
      if ($$props.scale === void 0 && $$bindings.scale && scale$1 !== void 0)
        $$bindings.scale(scale$1);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      {
        {
          if (self2.geometry && geometry$1 !== self2.geometry) {
            self2.geometry.dispose();
          }
          self2.geometry = geometry$1;
          self2.material = material$1;
          self2.castShadow = castShadow;
          self2.receiveShadow = receiveShadow;
          self2.frustumCulled = frustumCulled;
          self2.renderOrder = renderOrder;
          transform(self2, position$1, rotation$1, scale$1);
          root.invalidate();
        }
      }
      return `${slots.default ? slots.default({}) : ``}`;
    });
    Primitive = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { object } = $$props;
      let { position: position$1 = position } = $$props;
      let { rotation: rotation$1 = rotation } = $$props;
      let { scale: scale$1 = scale } = $$props;
      const { root, self: self2 } = setup(new THREE.Object3D());
      let previous;
      if ($$props.object === void 0 && $$bindings.object && object !== void 0)
        $$bindings.object(object);
      if ($$props.position === void 0 && $$bindings.position && position$1 !== void 0)
        $$bindings.position(position$1);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation$1 !== void 0)
        $$bindings.rotation(rotation$1);
      if ($$props.scale === void 0 && $$bindings.scale && scale$1 !== void 0)
        $$bindings.scale(scale$1);
      {
        {
          if (previous) {
            self2.remove(previous);
          }
          if (object) {
            self2.add(object);
          }
          previous = object;
          root.invalidate();
        }
      }
      {
        {
          transform(self2, position$1, rotation$1, scale$1);
          root.invalidate();
        }
      }
      return `${object ? `${slots.default ? slots.default({}) : ``}` : ``}`;
    });
    PerspectiveCamera_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { fov = 45 } = $$props;
      let { near = 0.1 } = $$props;
      let { far = 2e3 } = $$props;
      let { zoom = 1 } = $$props;
      let { viewOffset = void 0 } = $$props;
      let { position: position2 = [0, 0, 5] } = $$props;
      let { target = [0, 0, 0] } = $$props;
      const { root, self: self2 } = setup(new import_three2.PerspectiveCamera());
      const target_vector = new import_three2.Vector3();
      root.camera.set(self2, (w, h2) => {
        self2.aspect = w / h2;
        self2.updateProjectionMatrix();
      });
      if ($$props.fov === void 0 && $$bindings.fov && fov !== void 0)
        $$bindings.fov(fov);
      if ($$props.near === void 0 && $$bindings.near && near !== void 0)
        $$bindings.near(near);
      if ($$props.far === void 0 && $$bindings.far && far !== void 0)
        $$bindings.far(far);
      if ($$props.zoom === void 0 && $$bindings.zoom && zoom !== void 0)
        $$bindings.zoom(zoom);
      if ($$props.viewOffset === void 0 && $$bindings.viewOffset && viewOffset !== void 0)
        $$bindings.viewOffset(viewOffset);
      if ($$props.position === void 0 && $$bindings.position && position2 !== void 0)
        $$bindings.position(position2);
      if ($$props.target === void 0 && $$bindings.target && target !== void 0)
        $$bindings.target(target);
      {
        {
          self2.fov = fov;
          self2.near = near;
          self2.far = far;
          self2.zoom = zoom;
          if (viewOffset) {
            self2.setViewOffset(viewOffset.fullWidth, viewOffset.fullHeight, viewOffset.x, viewOffset.y, viewOffset.width, viewOffset.height);
          }
          self2.position.set(position2[0], position2[1], position2[2]);
          target_vector.set(target[0], target[1], target[2]);
          self2.lookAt(target_vector);
          self2.updateProjectionMatrix();
          root.invalidate();
        }
      }
      return ``;
    });
    SubmarineCanvas = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $depth, $$unsubscribe_depth;
      let $horizontal, $$unsubscribe_horizontal;
      let $aim, $$unsubscribe_aim;
      let { size } = $$props;
      let { xScale = 1 } = $$props;
      let { genFn } = $$props;
      genFn();
      let submarine;
      const depth = tweened(0);
      $$unsubscribe_depth = subscribe(depth, (value) => $depth = value);
      const horizontal = tweened(0);
      $$unsubscribe_horizontal = subscribe(horizontal, (value) => $horizontal = value);
      const aim = tweened(0);
      $$unsubscribe_aim = subscribe(aim, (value) => $aim = value);
      let hLineGeometry;
      let dLineGeometry;
      let wrapper = { width: 0, height: 0 };
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      if ($$props.xScale === void 0 && $$bindings.xScale && xScale !== void 0)
        $$bindings.xScale(xScale);
      if ($$props.genFn === void 0 && $$bindings.genFn && genFn !== void 0)
        $$bindings.genFn(genFn);
      {
        {
          const hPoints = [
            new THREE.Vector3($horizontal / size, 0, 0),
            new THREE.Vector3($horizontal / size, 0, $depth / size)
          ];
          hLineGeometry = new THREE.BufferGeometry().setFromPoints(hPoints);
          const dPoints = [
            new THREE.Vector3(0, 0, $depth / size),
            new THREE.Vector3($horizontal / size, 0, $depth / size)
          ];
          dLineGeometry = new THREE.BufferGeometry().setFromPoints(dPoints);
        }
      }
      $$unsubscribe_depth();
      $$unsubscribe_horizontal();
      $$unsubscribe_aim();
      return `${$aim ? `<div class="${"text-lg"}">Current Aim: <code>${escape3(Math.floor($aim))}</code></div>` : ``}
<div class="${"relative text-gray-300 w-full aspect-square h-52 md:h-72 lg:h-96 max-w-sm"}"><div class="${"absolute left-8 z-50 block"}"${add_attribute("style", `top: ${20 + $depth / (size / 2) * wrapper.height}px;`, 0)}>depth <code>${escape3(Math.floor($depth))}</code></div>
	<div class="${"absolute top-6 z-50 block"}"${add_attribute("style", `left: ${20 + $horizontal / (size / 2) * wrapper.width}px;`, 0)}>position <code>${escape3(Math.floor($horizontal / xScale))}</code></div>
	${validate_component(Canvas, "SC.Canvas").$$render($$result, { antialias: true }, {}, {
        default: () => `${validate_component(PerspectiveCamera_1, "SC.PerspectiveCamera").$$render($$result, {
          position: [0, 1, 0],
          zoom: 0.78,
          viewOffset: {
            fullHeight: 1,
            fullWidth: 1,
            height: 0.5,
            width: 0.5,
            x: 0.48,
            y: 0.48
          }
        }, {}, {})}
		${validate_component(Primitive, "SC.Primitive").$$render($$result, {
          object: new THREE.GridHelper(1),
          position: [0, 0, 0]
        }, {}, {})}
		${validate_component(Primitive, "SC.Primitive").$$render($$result, {
          object: new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 0.5, void 0, 0.05, 0.03)
        }, {}, {})}
		${validate_component(Primitive, "SC.Primitive").$$render($$result, {
          object: new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 0.5, void 0, 0.05, 0.03)
        }, {}, {})}
		${validate_component(Primitive, "SC.Primitive").$$render($$result, {
          object: new THREE.Line(hLineGeometry, new THREE.LineBasicMaterial({ color: "white" }))
        }, {}, {})}
		${validate_component(Primitive, "SC.Primitive").$$render($$result, {
          object: new THREE.Line(dLineGeometry, new THREE.LineBasicMaterial({ color: "white" }))
        }, {}, {})}
		${validate_component(Mesh2, "SC.Mesh").$$render($$result, {
          geometry: new THREE.PlaneGeometry(0.05, 0.05),
          material: submarine,
          rotation: [Math.PI / 2, 0, 0],
          position: [$horizontal / size, 0, $depth / size]
        }, {}, {})}`
      })}</div>`;
    });
    _2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { input } = $$props;
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      return `<h3 class="${"text-6xl"}">Dive!</h3>
<section class="${"space-y-4 mt-4"}"><h4 class="${"text-2xl font-bold"}">Part 1</h4>
	${validate_component(SubmarineCanvas, "SubmarineCanvas").$$render($$result, {
        genFn: () => part12(input.split("\n")),
        size: 4e3,
        xScale: 0.8
      }, {}, {})}</section>
<section class="${"space-y-4 mt-4"}"><h4 class="${"text-2xl font-bold"}">Part 2</h4>
	${validate_component(SubmarineCanvas, "SubmarineCanvas").$$render($$result, {
        genFn: () => part22(input.split("\n")),
        size: 2e6,
        xScale: 350
      }, {}, {})}</section>`;
    });
  }
});

// .svelte-kit/output/server/chunks/index-88eb2383.js
var index_88eb2383_exports = {};
__export(index_88eb2383_exports, {
  default: () => _3,
  load: () => load2
});
function mostCommonBit(bucket) {
  const ones = bucket.filter((v) => v === "1");
  return ones.length >= bucket.length / 2 ? "1" : "0";
}
function leastCommonBit(bucket) {
  const zeroes = bucket.filter((v) => v === "0");
  return zeroes.length <= bucket.length / 2 ? "0" : "1";
}
function invertBits(n) {
  return n.map((v) => v === "1" ? "0" : "1");
}
function* part13(lines) {
  const buckets = Array(12).fill(null).map(() => []);
  lines.forEach((bit) => Array.from(bit).forEach((b, i2) => buckets[i2].push(b)));
  const mostCommon = [];
  for (const bucket of buckets) {
    mostCommon.push(mostCommonBit(bucket));
    yield mostCommon;
  }
  const gamma = parseInt(mostCommon.join(""), 2);
  const epsilon = parseInt(invertBits(mostCommon).join(""), 2);
  return gamma * epsilon;
}
function* part23(lines) {
  let oxCandidates = [...lines];
  let coCandidates = [...lines];
  const mostCommon = [];
  const leastCommon = [];
  for (let i2 = 0; oxCandidates.length > 1 || coCandidates.length > 1; i2++) {
    if (oxCandidates.length > 1) {
      const oxBucket = oxCandidates.map((line) => line[i2]);
      mostCommon.push(mostCommonBit(oxBucket));
      oxCandidates = oxCandidates.filter((line) => line[i2] === mostCommon[i2]);
    }
    if (coCandidates.length > 1) {
      const coBucket = coCandidates.map((line) => line[i2]);
      leastCommon.push(leastCommonBit(coBucket));
      coCandidates = coCandidates.filter((line) => line[i2] === leastCommon[i2]);
    }
    yield { oxCandidates, mostCommon, leastCommon, coCandidates };
  }
  return parseInt(oxCandidates[0], 2) * parseInt(coCandidates[0], 2);
}
var DecBinNumber, Part1, Part2, _3;
var init_index_88eb2383 = __esm({
  ".svelte-kit/output/server/chunks/index-88eb2383.js"() {
    init_shims();
    init_app_7566ed49();
    init_loadInput_5557da5b();
    init_ssr();
    DecBinNumber = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { bit } = $$props;
      if ($$props.bit === void 0 && $$bindings.bit && bit !== void 0)
        $$bindings.bit(bit);
      return `${bit.length ? `<code>${escape3(bit.join(""))}</code>
	<sub class="${"mr-4"}">2</sub>
	<code>${escape3(parseInt(bit.join(""), 2))}</code>
	<sub>10</sub>` : ``}`;
    });
    Part1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { input } = $$props;
      part13(input);
      let mostCommon = [];
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      return `<button class="${"btn btn-outline"}">Next Most Common</button>
<div class="${"text-lg font-bold"}"><p>Gamma Rate
		<br>
		${validate_component(DecBinNumber, "DecBinNumber").$$render($$result, { bit: mostCommon }, {}, {})}</p>
	<p>Epsilon
		<br>
		${validate_component(DecBinNumber, "DecBinNumber").$$render($$result, { bit: invertBits(mostCommon) }, {}, {})}</p>
	${``}</div>
<div class="${"columns-1 md:columns-3 lg:columns-5"}">${each(input, (num) => `<code>${each(num, (n, i2) => `<span class="${["transition", mostCommon[i2] === n ? "text-red-500" : ""].join(" ").trim()}">${escape3(n)}</span>`)}
		</code>`)}</div>`;
    });
    Part2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { input } = $$props;
      let oxCandidates = [...input];
      let coCandidates = [...input];
      let mostCommon = [];
      let leastCommon = [];
      part23(input);
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      return `<button class="${["btn btn-outline", ""].join(" ").trim()}" ${""}>Filter Lists</button>
<button class="${"btn btn-secondary"}">reset</button>
<div class="${"grid grid-cols-2 space-x-8"}"><div><p class="${"text-lg font-bold mb-2"}">Oxygen (most common bit)
			<br>
			${validate_component(DecBinNumber, "DecBinNumber").$$render($$result, { bit: mostCommon }, {}, {})}</p>
		<div class="${"inline-flex flex-wrap"}">${each(oxCandidates, (ox) => `<code class="${"inline-block mr-2"}">${escape3(ox)}</code>`)}</div></div>
	<div><p class="${"text-lg font-bold mb-2"}">CO2 (least common bit)
			<br>
			${validate_component(DecBinNumber, "DecBinNumber").$$render($$result, { bit: leastCommon }, {}, {})}</p>
		<div class="${"inline-flex flex-wrap"}">${each(coCandidates, (co) => `<code class="${"inline-block mr-2"}">${escape3(co)}</code>`)}</div></div></div>`;
    });
    _3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { input } = $$props;
      let comp = Part1;
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      return `<h3 class="${"text-6xl"}">Binary Diagnostics</h3>
<div class="${"tabs mt-4"}"><button class="${["tab text-lg tab-bordered", comp === Part1 ? "tab-active" : ""].join(" ").trim()}">Part 1</button>
	<button class="${["tab text-lg tab-bordered", comp === Part2 ? "tab-active" : ""].join(" ").trim()}">Part 2</button></div>
<section class="${"space-y-4 mt-4 min-w-full"}">${validate_component(comp || missing_component, "svelte:component").$$render($$result, { input: input.split("\n") }, {}, {})}</section>`;
    });
  }
});

// .svelte-kit/output/server/chunks/runner-e9c7baf3.js
function useRunner(callback) {
  let runner;
  onDestroy(stop);
  function run2() {
    runner = window.setInterval(callback, 1e3);
  }
  function stop() {
    if (runner) {
      clearInterval(runner);
      runner = void 0;
    }
  }
  const running = () => runner !== void 0;
  return { run: run2, stop, running };
}
var init_runner_e9c7baf3 = __esm({
  ".svelte-kit/output/server/chunks/runner-e9c7baf3.js"() {
    init_shims();
    init_app_7566ed49();
  }
});

// .svelte-kit/output/server/chunks/index-263e501b.js
var index_263e501b_exports = {};
__export(index_263e501b_exports, {
  default: () => _4,
  load: () => load2
});
function transposeField(field) {
  const columns = [];
  field.forEach((row) => {
    row.forEach(([n, isSet], i2) => {
      if (!columns[i2]) {
        columns.push([]);
      }
      columns[i2].push([n, isSet]);
    });
  });
  return columns;
}
function setMaxCount(field) {
  const trueCount = (row) => row.filter((v) => v[1]).length;
  const columns = transposeField(field);
  const counts = [...field.map((row) => trueCount(row)), ...columns.map((col) => trueCount(col))];
  return Math.max(...counts);
}
function setNumber(field, n) {
  return field.map((row) => row.map(([num, isSet]) => [num, isSet || num === n]));
}
function makeFields(input) {
  return input.filter((v) => v !== "").reduce((acc, v, i2) => {
    const bucket = Math.floor(i2 / 5);
    if (!acc[bucket]) {
      acc.push([]);
    }
    const row = v.split(" ").filter((v2) => v2 !== "").reduce((row2, v2) => [...row2, [Number(v2), false]], []);
    acc[bucket].push(row);
    return acc;
  }, []);
}
function makeNumbers(line) {
  return line.split(",").map((v) => Number(v));
}
function getSum(field) {
  const sum = field.reduce((acc, row) => acc + row.reduce((rowSum, [n, set]) => set ? rowSum : rowSum + n, 0), 0);
  return sum;
}
function* part14(numbers, fields) {
  const localFields = fields.map((field) => ({ field, count: 0 }));
  for (const number of numbers) {
    for (const i2 in localFields) {
      localFields[i2].field = setNumber(localFields[i2].field, number);
      localFields[i2].count = setMaxCount(localFields[i2].field);
    }
    const winner = localFields.find(({ count }) => count === 5);
    if (winner) {
      const sum = getSum(winner.field);
      return [number, localFields, sum * number];
    }
    yield [number, localFields];
  }
}
function* part24(numbers, fields) {
  let loser;
  const localFields = fields.map((field) => ({ field, count: 0 }));
  for (const number of numbers) {
    for (const i2 in localFields) {
      localFields[i2].field = setNumber(localFields[i2].field, number);
      localFields[i2].count = setMaxCount(localFields[i2].field);
    }
    const losers = localFields.filter(({ count }) => count < 5);
    if (losers.length === 1) {
      loser = losers[0];
    }
    if (loser?.count === 5) {
      const sum = getSum(loser.field);
      return [number, localFields, sum * number];
    }
    yield [number, localFields];
  }
}
var FieldBox, _4;
var init_index_263e501b = __esm({
  ".svelte-kit/output/server/chunks/index-263e501b.js"() {
    init_shims();
    init_app_7566ed49();
    init_loadInput_5557da5b();
    init_runner_e9c7baf3();
    init_ssr();
    FieldBox = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { field } = $$props;
      let { done } = $$props;
      if ($$props.field === void 0 && $$bindings.field && field !== void 0)
        $$bindings.field(field);
      if ($$props.done === void 0 && $$bindings.done && done !== void 0)
        $$bindings.done(done);
      return `<div${add_attribute("class", `card shadow-lg ${done ? "ring-2 ring-red-300 animate-pulse" : " "}`, 0)}><div class="${"card-body flex-initial"}"><div class="${"max-w-max grid place-content-center grid-cols-5 grid-rows-5 gap-2"}">${each(field, (row) => `${each(row, ([n, isSet]) => `<code${add_classes([isSet ? "text-red-500" : ""].join(" ").trim())}>${escape3(n)}</code>`)}`)}</div></div></div>`;
    });
    _4 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { input } = $$props;
      const [numbersLine, ...rest] = input.split("\n");
      const numbers = makeNumbers(numbersLine);
      const fields = makeFields(rest);
      let gen;
      let activePart = 1;
      let done = false;
      let result = 0;
      let drawn = [];
      let localFields = [];
      const handleClick2 = () => {
        if (!done) {
          const res = gen.next();
          done = res.done;
          const [n, fs] = res.value;
          drawn = [...drawn, n];
          localFields = fs;
          if (done) {
            result = res.value[2];
          }
        }
      };
      const { run: run2, stop, running } = useRunner(handleClick2);
      function init2(active) {
        done = false;
        result = 0;
        drawn = [];
        localFields = fields.map((field) => ({ field, count: 0 }));
        gen = active === 1 ? part14(numbers, fields) : part24(numbers, fields);
        stop();
      }
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      {
        init2(activePart);
      }
      return `<h3 class="${"text-6xl"}">Binary Diagnostics</h3>
<div class="${"tabs mt-4"}"><button class="${["tab text-lg tab-bordered", "tab-active"].join(" ").trim()}">Part 1</button>
	<button class="${["tab text-lg tab-bordered", ""].join(" ").trim()}">Part 2</button></div>
<section class="${"flex flex-col gap-4 mt-4 min-w-full"}">${result ? `<div>Result: ${escape3(result)}</div>` : ``}
	<div><button class="${["btn btn-outline", done ? "btn-disabled" : ""].join(" ").trim()}" ${done ? "disabled" : ""}>${running ? `Stop` : `run`}</button>
		<button class="${["btn btn-outline", done ? "btn-disabled" : ""].join(" ").trim()}" ${done ? "disabled" : ""}>Draw next number
		</button>
		<button class="${"btn btn-secondary"}">Reset</button></div>
	<p>Numbers:
		${each(drawn, (n) => `<code>${escape3(n)}
			</code>`)}</p>
	<div class="${"flex flex-row flex-wrap justify-between"}">${each(localFields.sort((a, b) => b.count - a.count), ({ field, count }) => `${validate_component(FieldBox, "FieldBox").$$render($$result, { field, done: count === 5 }, {}, {})}`)}</div></section>`;
    });
  }
});

// .svelte-kit/output/server/chunks/index-c4314b21.js
var index_c4314b21_exports = {};
__export(index_c4314b21_exports, {
  default: () => _5,
  load: () => load2
});
function makePipe(line) {
  const [left, right] = line.split(" -> ");
  const start = left.split(",").map((n) => Number(n));
  const end = right.split(",").map((n) => Number(n));
  return [start, end];
}
function pointIsOnLine(point, pipe) {
  const [start, end] = pipe;
  const minX = Math.min(start[0], end[0]);
  const maxX = Math.max(start[0], end[0]);
  const minY = Math.min(start[1], end[1]);
  const maxY = Math.max(start[1], end[1]);
  if (minX <= point[0] && point[0] <= maxX && minY <= point[1] && point[1] <= maxY) {
    const slope = (end[1] - start[1]) / (end[0] / start[0]);
    if (slope === Infinity || slope === 0) {
      return true;
    }
    const fn = (x2) => slope * x2;
    return fn(point[0]) === point[1];
  }
  return false;
}
function makeField(pointFn = () => 0) {
  return Array.from(Array(1e3)).map((_, y) => Array.from(Array(1e3)).map((_22, x2) => pointFn([Number(x2), Number(y)])));
}
function getIntersectedField(pipes) {
  return makeField((point) => pipes.filter((p) => pointIsOnLine(point, p)).length);
}
function countIntersections(field) {
  return field.reduce((total, row) => total + row.filter((n) => n > 1).length, 0);
}
function* part15(pipes) {
  let field = makeField();
  for (const i2 in pipes) {
    const slice = pipes.slice(0, Number(i2) + 1);
    field = getIntersectedField(slice);
    yield { field, pipes: slice };
  }
  return countIntersections(field);
}
function handleClick() {
}
var _5;
var init_index_c4314b21 = __esm({
  ".svelte-kit/output/server/chunks/index-c4314b21.js"() {
    init_shims();
    init_app_7566ed49();
    init_runner_e9c7baf3();
    init_loadInput_5557da5b();
    init_ssr();
    _5 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { input } = $$props;
      const lines = input.split("\n");
      let done = false;
      let result = 0;
      const pipes = lines.map((line) => makePipe(line));
      const { run: run2, stop, running } = useRunner(handleClick);
      function init2(active) {
        done = false;
        result = 0;
        part15(pipes);
        stop();
      }
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      {
        init2();
      }
      return `<h3 class="${"text-6xl"}">U tryna get the pipe?</h3>
<div class="${"tabs mt-4"}"><button class="${["tab text-lg tab-bordered", "tab-active"].join(" ").trim()}">Part 1</button>
	</div>
<section class="${"flex flex-col gap-4 mt-4 min-w-full"}">${result ? `<div>Result: ${escape3(result)}</div>` : ``}
	<div><button class="${["btn btn-outline", done ? "btn-disabled" : ""].join(" ").trim()}" ${done ? "disabled" : ""}>${running ? `Stop` : `run`}</button>
		<button class="${["btn btn-outline", done ? "btn-disabled" : ""].join(" ").trim()}" ${done ? "disabled" : ""}>Draw next number
		</button>
		<button class="${"btn btn-secondary"}">Reset</button></div></section>`;
    });
  }
});

// .svelte-kit/output/server/chunks/app-7566ed49.js
function noop3() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop3;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function escape3(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    str += fn(items[i2], i2);
  }
  return str;
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css22) => css22.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape3(value)) : `"${value}"`}`}`;
}
function add_classes(classes) {
  return classes ? ` class="${classes}"` : "";
}
function afterUpdate() {
}
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
function set_prerendering(value) {
}
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-8e86cb96.js",
      css: [assets + "/_app/assets/start-d5b4de3e.css", assets + "/_app/assets/vendor-595ca423.css"],
      js: [assets + "/_app/start-8e86cb96.js", assets + "/_app/chunks/vendor-7fda9ec9.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
async function load_component(file) {
  const { entry, css: css22, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css22.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var identity, is_client, now, raf, tasks, current_component, escaped2, missing_component, on_destroy, css3, Root, base, assets, user_hooks, template, options, default_settings, empty, manifest, get_hooks, module_lookup, metadata_lookup;
var init_app_7566ed49 = __esm({
  ".svelte-kit/output/server/chunks/app-7566ed49.js"() {
    init_shims();
    init_ssr();
    identity = (x2) => x2;
    is_client = typeof window !== "undefined";
    now = is_client ? () => window.performance.now() : () => Date.now();
    raf = is_client ? (cb) => requestAnimationFrame(cb) : noop3;
    tasks = new Set();
    Promise.resolve();
    escaped2 = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
    css3 = {
      code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
      map: null
    };
    Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { stores } = $$props;
      let { page: page2 } = $$props;
      let { components } = $$props;
      let { props_0 = null } = $$props;
      let { props_1 = null } = $$props;
      let { props_2 = null } = $$props;
      setContext("__svelte__", stores);
      afterUpdate(stores.page.notify);
      if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
        $$bindings.stores(stores);
      if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
        $$bindings.page(page2);
      if ($$props.components === void 0 && $$bindings.components && components !== void 0)
        $$bindings.components(components);
      if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
        $$bindings.props_0(props_0);
      if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
        $$bindings.props_1(props_1);
      if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
        $$bindings.props_2(props_2);
      $$result.css.add(css3);
      {
        stores.page.set(page2);
      }
      return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
        default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
          default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
        })}` : ``}`
      })}

${``}`;
    });
    base = "";
    assets = "";
    user_hooks = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module"
    });
    template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<meta name="description" content="" />\n		<link rel="icon" href="/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
    options = null;
    default_settings = { paths: { "base": "", "assets": "" } };
    empty = () => ({});
    manifest = {
      assets: [{ "file": "favicon.png", "size": 1571, "type": "image/png" }, { "file": "input/1.txt", "size": 9459, "type": "text/plain" }, { "file": "input/2.txt", "size": 7684, "type": "text/plain" }, { "file": "input/3.txt", "size": 12999, "type": "text/plain" }, { "file": "input/4.txt", "size": 7889, "type": "text/plain" }, { "file": "input/5.txt", "size": 9265, "type": "text/plain" }, { "file": "jrswish.png", "size": 59743, "type": "image/png" }, { "file": "submarine.png", "size": 14827, "type": "image/png" }, { "file": "yudodis.jpg", "size": 65708, "type": "image/jpeg" }],
      layout: "src/routes/__layout.svelte",
      error: ".svelte-kit/build/components/error.svelte",
      routes: [
        {
          type: "page",
          pattern: /^\/$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/days\/1\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/days/1.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/days\/2\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/days/2/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/days\/3\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/days/3/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/days\/4\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/days/4/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/days\/5\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/days/5/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        }
      ]
    };
    get_hooks = (hooks) => ({
      getSession: hooks.getSession || (() => ({})),
      handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
      handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
      externalFetch: hooks.externalFetch || fetch
    });
    module_lookup = {
      "src/routes/__layout.svelte": () => Promise.resolve().then(() => (init_layout_0a3d2c91(), layout_0a3d2c91_exports)),
      ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(() => (init_error_0a901032(), error_0a901032_exports)),
      "src/routes/index.svelte": () => Promise.resolve().then(() => (init_index_f2eaf764(), index_f2eaf764_exports)),
      "src/routes/days/1.svelte": () => Promise.resolve().then(() => (init_c066b6(), c066b6_exports)),
      "src/routes/days/2/index.svelte": () => Promise.resolve().then(() => (init_index_fc0d8390(), index_fc0d8390_exports)),
      "src/routes/days/3/index.svelte": () => Promise.resolve().then(() => (init_index_88eb2383(), index_88eb2383_exports)),
      "src/routes/days/4/index.svelte": () => Promise.resolve().then(() => (init_index_263e501b(), index_263e501b_exports)),
      "src/routes/days/5/index.svelte": () => Promise.resolve().then(() => (init_index_c4314b21(), index_c4314b21_exports))
    };
    metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-5c411722.js", "css": ["assets/pages/__layout.svelte-d40785dc.css", "assets/vendor-595ca423.css"], "js": ["pages/__layout.svelte-5c411722.js", "chunks/vendor-7fda9ec9.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-b4407396.js", "css": ["assets/vendor-595ca423.css"], "js": ["error.svelte-b4407396.js", "chunks/vendor-7fda9ec9.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-c847dd71.js", "css": ["assets/vendor-595ca423.css"], "js": ["pages/index.svelte-c847dd71.js", "chunks/vendor-7fda9ec9.js"], "styles": [] }, "src/routes/days/1.svelte": { "entry": "pages/days/1.svelte-e959ad03.js", "css": ["assets/vendor-595ca423.css"], "js": ["pages/days/1.svelte-e959ad03.js", "chunks/vendor-7fda9ec9.js", "chunks/loadInput-5557da5b.js"], "styles": [] }, "src/routes/days/2/index.svelte": { "entry": "pages/days/2/index.svelte-a7a1f73a.js", "css": ["assets/vendor-595ca423.css"], "js": ["pages/days/2/index.svelte-a7a1f73a.js", "chunks/vendor-7fda9ec9.js", "chunks/loadInput-5557da5b.js"], "styles": [] }, "src/routes/days/3/index.svelte": { "entry": "pages/days/3/index.svelte-25fb8ff5.js", "css": ["assets/vendor-595ca423.css"], "js": ["pages/days/3/index.svelte-25fb8ff5.js", "chunks/vendor-7fda9ec9.js", "chunks/loadInput-5557da5b.js"], "styles": [] }, "src/routes/days/4/index.svelte": { "entry": "pages/days/4/index.svelte-5cfeb162.js", "css": ["assets/vendor-595ca423.css"], "js": ["pages/days/4/index.svelte-5cfeb162.js", "chunks/vendor-7fda9ec9.js", "chunks/loadInput-5557da5b.js", "chunks/runner-a4586c6f.js"], "styles": [] }, "src/routes/days/5/index.svelte": { "entry": "pages/days/5/index.svelte-c5b26307.js", "css": ["assets/vendor-595ca423.css"], "js": ["pages/days/5/index.svelte-c5b26307.js", "chunks/vendor-7fda9ec9.js", "chunks/runner-a4586c6f.js", "chunks/loadInput-5557da5b.js"], "styles": [] } };
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});
init_shims();

// .svelte-kit/output/server/app.js
init_shims();
init_ssr();
init_app_7566ed49();

// .svelte-kit/netlify/entry.js
init();
async function handler(event) {
  const { path, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const encoding = isBase64Encoded ? "base64" : headers["content-encoding"] || "utf-8";
  const rawBody = typeof body === "string" ? Buffer.from(body, encoding) : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (!rendered) {
    return {
      statusCode: 404,
      body: "Not found"
    };
  }
  const partial_response = {
    statusCode: rendered.status,
    ...split_headers(rendered.headers)
  };
  if (rendered.body instanceof Uint8Array) {
    return {
      ...partial_response,
      isBase64Encoded: true,
      body: Buffer.from(rendered.body).toString("base64")
    };
  }
  return {
    ...partial_response,
    body: rendered.body
  };
}
function split_headers(headers) {
  const h2 = {};
  const m2 = {};
  for (const key in headers) {
    const value = headers[key];
    const target = Array.isArray(value) ? m2 : h2;
    target[key] = value;
  }
  return {
    headers: h2,
    multiValueHeaders: m2
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
